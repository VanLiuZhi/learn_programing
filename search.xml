<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Apollo配置中心</title>
      <link href="/2020/07/13/Web/Apollo/"/>
      <url>/2020/07/13/Web/Apollo/</url>
      
        <content type="html"><![CDATA[<p>Apollo配置中心</p><h2 id="各模块的作用"><a href="#各模块的作用" class="headerlink" title="各模块的作用"></a>各模块的作用</h2><p><code>Config Service</code>提供配置的读取、推送等功能，服务对象是<code>Apollo客户端</code><br><code>Admin Service</code>提供配置的修改、发布等功能，服务对象是<code>Apollo Portal（管理界面）</code><br><code>Config Service</code>和<code>Admin Service</code>都是多实例、无状态部署，所以需要将自己注册到Eureka中并保持心跳<br>在Eureka之上我们架了一层<code>Meta Server</code>用于封装Eureka的服务发现接口<br>Client通过域名访问Meta Server获取Config Service服务列表（IP+Port），而后直接通过IP+Port访问服务，同时在Client侧会做load balance、错误重试<br>Portal通过域名访问Meta Server获取Admin Service服务列表（IP+Port），而后直接通过IP+Port访问服务，同时在Portal侧会做load balance、错误重试<br>为了简化部署，我们实际上会把Config Service、Eureka和Meta Server三个逻辑角色部署在同一个JVM进程中</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Middleware </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Future</title>
      <link href="/2020/03/30/Review/future/"/>
      <url>/2020/03/30/Review/future/</url>
      
        <content type="html"><![CDATA[<ol><li>先删缓存再改数据库</li></ol><p>可能会有这样的问题</p><p>并发，1读，1写</p><ul><li><code>写1</code>先删了<code>缓存</code></li><li>这个时候<code>读1</code>发现没<code>缓存</code>，就读数据库准备写到<code>缓存</code></li><li>然后<code>写1</code>要把数据写到<code>数据库</code></li><li>接着<code>读1</code>把自己读到的数据写到<code>缓存</code></li></ul><p>这样缓存是<code>读1</code>放入的旧数据，数据库是<code>写1</code>放入的新数据，出现不一致</p><ol start="2"><li>先读数据库，再删除缓存</li></ol><ul><li>一开始没有缓存，读写并发</li><li>读操作先进来，发现没有缓存，去数据库中读数据，这个时候因为某种原因卡了，没有及时把数据放入缓存</li><li>写的操作进来了，修改了数据库，删除了缓存</li><li>读操作恢复，把老数据写进了缓存</li></ul><p>这种情况下，读操作本来是要马上写缓存的，但是被写操作抢先了，写了新的数据进入，写操作的删除缓存没意义了，被后面读操作覆盖了</p><p>其实这种情况很极端了，但是会存在，因为并发，操作不是原子的</p><p>但是写一般是比较慢的，除非你读慢于写，才会发生</p><ol start="3"><li>延迟双删</li></ol><p>延迟双删就是写中，先删除缓存，后修改数据库，最后延迟一定时间，再次删除缓存</p><p>这样写保证缓存不是旧缓存，是2情况的一种延时策略，缓存由读操作去建立，写操作保证不要写入旧缓存，否则读一直是旧缓存</p><ol start="4"><li>内存队列，消息队列</li></ol><p>在3中，如果第二次删除失败了，那么就会有2的情况发生，上面3点都存在以下问题</p><ul><li>修改数据库、删除缓存这两个操作耦合在了一起，没有很好的做到单一职责；</li><li>如果写操作比较频繁，可能会对Redis造成一定的压力；</li><li>如果删除缓存失败，该怎么办？</li></ul><p>写操作只是修改数据库，然后把数据的Id放在内存队列里面，后台会有一个线程消费内存队列里面的数据，删除缓存，如果缓存删除失败，可以重试多次</p><p>生产考虑用消息队列，这样各个部门的数据都可以入队列，然后在容器或者整个服务里面启动一个服务，专门去消费队列，删除缓存</p><p>很好的解决了缓存不一致的问题，但是存在一定的延迟</p><p>说了这么多，有没有发现有点CAP的影子，保证了可用性，缺牺牲了一致性，但是保证了最终一致性</p><h2 id="事件多播器"><a href="#事件多播器" class="headerlink" title="事件多播器"></a>事件多播器</h2><h2 id="让你去实现一个注册中心，你会怎么做？"><a href="#让你去实现一个注册中心，你会怎么做？" class="headerlink" title="让你去实现一个注册中心，你会怎么做？"></a>让你去实现一个注册中心，你会怎么做？</h2><h2 id="让你实现一个消息中间件，比如kafka，你会怎么做？"><a href="#让你实现一个消息中间件，比如kafka，你会怎么做？" class="headerlink" title="让你实现一个消息中间件，比如kafka，你会怎么做？"></a>让你实现一个消息中间件，比如kafka，你会怎么做？</h2><h2 id="dubbo调用的请求参数和返回参数无法使用泛型是因为什么"><a href="#dubbo调用的请求参数和返回参数无法使用泛型是因为什么" class="headerlink" title="dubbo调用的请求参数和返回参数无法使用泛型是因为什么"></a>dubbo调用的请求参数和返回参数无法使用泛型是因为什么</h2><h2 id="dubbo-知识点"><a href="#dubbo-知识点" class="headerlink" title="dubbo 知识点"></a>dubbo 知识点</h2><p>service 标签 暴露的服务<br>reference 标签 服务引用，标识从注册用心引用其它服务给自己用</p><p>推荐使用 Hessian 序列化</p><h2 id="zk"><a href="#zk" class="headerlink" title="zk"></a>zk</h2><p>容器连接客户端</p><p>docker exec -it zookeeper /opt/zookeeper-3.4.13/bin/zkCli.sh -server 127.0.0.1:2181<br>docker exec -it zookeeper /opt/zookeeper-3.4.13/bin/zkServer.sh status</p><h2 id="zk选举"><a href="#zk选举" class="headerlink" title="zk选举"></a>zk选举</h2><p>通常节点数要是偶数，因为集群过半投票后，才能选出新的leader，选不出就不提供服务</p><p>脑裂: 实际是不会有脑裂的，因为不满足过半条件，集群不再提供服务（过半机制防止脑裂）</p><p>假设有5台，过半就是5/2余数2，要大于2才行，也就是3，不能是等于2。也就是说集群必须存活着3台才能选举出新的leader，所以在5台组成的集群中，只能挂2台</p><p>在考虑选举的时候，是所有的，包括挂了的作为总数来计算，上面的例子就是5。假设总共有6台，分在2个机房，一个机房A 3台，另一个B也是3台，由于6/2等3，需要4台才能选出leader，所以AB机房都选不出，服务不可用。如果是AB分配是4，2那么A机房能选出leader，整个集群只有一个leader，这也是过半原则要大于的原因，如果是大于等于，在AB分配3，3的情况下，AB都满足等于3，都会选出leader，那就脑裂了</p><p>还有一个知识点就是部署最好是奇数，虽然奇数，偶数的集群都能选出leader，都不会脑裂，但是奇数能节约资源</p><p>5的情况下，运行挂2台(5/2 余 2，需要3台才能进行选举，所以容错是2台)，6的情况下，也是运行挂2台，那么我用5台就好了，节约资源</p><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>源码流程</p><p>AnnotationConfigApplicationContext 通过注解配置创建context</p><p>在构造函数中，做了下面的事情</p><p>// 1.初始化bean定义读取器和扫描器<br>// 2.调用父类GenericApplicationContext无参构造函数，初始化一个BeanFactory：DefaultListableBeanFactory<br>// 3.注册Spring自带的bean，共5个 包括:<br>//  ConfigurationClassPostProcessor<br>//  AutowiredAnnotationBeanPostProcessor  CommonAnnotationBeanPostProcessor<br>//     EventListenerMethodProcessor  DefaultEventListenerFactory</p><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>用starter风格的依赖，自动配置，除非你要显示的修改参数</p><p>然后直接创建分页对象PageHelper.startPage(pageNum, pageSize)，传递分页参数，然后获取查询对象，然后把查询对象赋值给pageInfo，返回分页数据(返回的数据中有很多字段，最好重新封装一下)</p><ol><li>数据结构，算法</li></ol><p>看视频部分，一次过，总结一些小东西即可，B+树，红黑树要会，还有hash表，堆</p><p>以前用过的一致性hash，hash环</p><ol start="2"><li>基础</li></ol><p>基础语法<br>反射，代理，class对象<br>新语法，lambda，流处理</p><ol start="2"><li>语言扩展相关</li></ol><p>jvm,juc（并发容器，并发编程，AQS等）</p><ol start="3"><li>框架，构建工具</li></ol><p>maven，Spring，Spring boot</p><ol start="4"><li>数据库</li></ol><p>MySQL 原理，存储引擎，innodb，索引，锁，事务，事务隔离</p><p>读写分离，主从同步</p><p>框架结合: 读写分离配置，多数据源配置，事务声名怎么用，分布式事务怎么用</p><p>优化，扩展</p><p>innodb_flush_log_at_trx_commit MySql日志何时写入硬盘的参数<br>load data infile 从文件把数据写入表中<br>存储过程upset，适合去重，利用upset，有就更新，无就创建<br>ETL，是英文Extract-Transform-Load的缩写，用来描述将数据从来源端经过抽取（extract）、转换（transform）、加载（load）至目的端的过程。ETL一词较常用在数据仓库，但其对象并不限于数据仓库。</p><ol start="5"><li>Redis</li></ol><p>集群，数据结构，红锁，分布式事务</p><ol start="6"><li>中间件</li></ol><p>kafka,rocketmq</p><ol start="7"><li>微服务,分布式，soa</li></ol><p>k8s, spring cloud ，dubbo</p><ol start="8"><li><p>能力开放平台</p></li><li><p>分布式锁</p></li></ol><p>链接:<a href="https://pan.baidu.com/s/1pCViJ2lYrrl-k3-ic8ADZg" target="_blank" rel="noopener">https://pan.baidu.com/s/1pCViJ2lYrrl-k3-ic8ADZg</a>  密码:mimx</p><p>vanliuzhi.github.io</p><h2 id="常用的微服务限流架构："><a href="#常用的微服务限流架构：" class="headerlink" title="常用的微服务限流架构："></a>常用的微服务限流架构：</h2><p>接入层（api-gateway）限流：<br>单实例；<br>多实例：分布式限流算法；<br>调用外部限流服务限流：<br>微服务收到请求后，通过限流服务暴露的 RPC 接口查询是否超过阈值；<br>需单独部署限流服务；<br>切面层限流（SDK）：<br>限流功能集成在微服务系统切面层，与业务解耦；<br>可结合远程配置中心使用；<br>常用的限流策略包括：</p><p>拒绝策略：<br>超过阈值直接返回错误；<br>调用方可做熔断降级处理。<br>延迟处理：<br>前端设置一个流量缓冲池，将所有的请求全部缓冲进这个池子，不立即处理。然后后端真正的业务处理程序从这个池子中取出请求依次处理，常见的可以用队列模式来实现（MQ：削峰填谷）；<br>用异步的方式去减少了后端的处理压力。<br>特权处理：<br>这个模式需要将用户进行分类，通过预设的分类，让系统优先处理需要高保障的用户群体，其它用户群的请求就会延迟处理或者直接不处理。<br>常用的限流算法包括：</p><p>固定时间窗口限流：<br>首先需要选定一个时间起点，之后每次接口请求到来都累加计数器，如果在当前时间窗口内，根据限流规则（比如每秒钟最大允许 100 次接口请求），累加访问次数超过限流值，则限流熔断拒绝接口请求。当进入下一个时间窗口之后，计数器清零重新计数；<br>缺点在于：限流策略过于粗略，无法应对两个时间窗口临界时间内的突发流量。<br>滑动时间窗口算法：</p><p>流量经过滑动时间窗口算法整形之后，可以保证任意时间窗口内，都不会超过最大允许的限流值，从流量曲线上来看会更加平滑，可以部分解决上面提到的临界突发流量问题，是对固定时间窗口算法的一种改进；<br>缺点在于：需要记录在时间窗口内每个接口请求到达的时间点，对内存的占用会比较多。<br>令牌桶算法：</p><p>接口限制 t 秒内最大访问次数为 n，则每隔 t/n 秒会放一个 token 到桶中；<br>桶中最多可以存放 b 个 token，如果 token 到达时令牌桶已经满了，那么这个 token 会被丢弃；<br>接口请求会先从令牌桶中取 token，拿到 token 则处理接口请求，拿不到 token 就阻塞或者拒绝服务。<br>漏桶算法：</p><p>对于取令牌的频率也有限制，要按照 t/n 固定的速度来取令牌；<br>实现往往依赖于队列，请求到达如果队列未满则直接放入队列，然后有一个处理器按照固定频率从队列头取出请求进行处理。如果请求量大，则会导致队列满，那么新来的请求就会被抛弃；<br>令牌桶和漏桶算法的算法思想大体类似，漏桶算法作为令牌桶限流算法的改进版本。<br>令牌桶算法和漏桶算法，在某些场景下（内存消耗、应对突发流量），这两种算法会优于时间窗口算法成为首选。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散分片算法研究</title>
      <link href="/2020/01/05/Web/sharding/"/>
      <url>/2020/01/05/Web/sharding/</url>
      
        <content type="html"><![CDATA[<h2 id="一致性应该满足的标准"><a href="#一致性应该满足的标准" class="headerlink" title="一致性应该满足的标准"></a>一致性应该满足的标准</h2><ul><li>平衡性(Balance)</li></ul><p>平衡性也就是说负载均衡，是指客户端hash后的请求应该能够分散到不同的服务器上去。一致性hash可以做到每个服务器都进行处理请求，但是不能保证每个服务器处理的请求的数量大致相同。</p><ul><li>单调性(Monotonicity)</li></ul><p>单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应该能够保证已分配的内容可以被映射到新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。<br>比如，之前有三台服务器A、B、C，某个key被映射到B当中，当新增服务器D后，这个key要么被映射到之前的B中，要么被映射到新增的D中，而不应该映射到A或者C当中。</p><ul><li>分散性(Spread)</li></ul><p>分布式环境中，客户端请求时候可能不知道所有服务器的存在，可能只知道其中一部分服务器，在客户端看来他看到的部分服务器会形成一个完整的hash环。如果多个客户端都把部分服务器作为一个完整hash环，那么可能会导致，同一个用户的请求被路由到不同的服务器进行处理。这种情况显然是应该避免的，因为它不能保证同一个用户的请求落到同一个服务器。所谓分散性是指上述情况发生的严重程度。</p><ul><li>负载(Load)</li></ul><p>负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>公用哈希函数和哈希环</li></ul><p>hash函数取值范围0, 2^32</p><ul><li>节点(Node)映射至哈希环</li></ul><p>节点就是服务器</p><ul><li>对象(Object)映射于哈希环</li></ul><p>对象就是要请求到服务器上的数据</p><ul><li>对象(Object)映射至节点(Node)</li></ul><p>请求和服务器对应关系</p><h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p>节点数太少的时候，各节点映射的对象数量严重不均衡(数据倾斜)；相反，节点数越多越密集，数据在哈希环上的分布就越均匀<br>复制倍数为 2^32 时，就达到绝对的均匀，通常可取复制倍数为32或更高<br>虚拟节点哈希值的计算方法调整为：对“节点的IP(或机器名)+虚拟节点的序号(1~N)”作哈希</p><p>删除节点: 数据会映射到下一个节点上，原始节点是A，会映射到A的下一个节点<br>增加节点: 数据会映射到上一个节点上，原始节点是A，会映射到A的上一个节点</p><p>这里要考虑有虚节点的情况，通过来说增加和删除都是要把所有虚节点都去除的</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud 微服务实践</title>
      <link href="/2019/11/01/Java/spring-cloud/"/>
      <url>/2019/11/01/Java/spring-cloud/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Java/Java-spring.jpg" alt="image"></p><h2 id="版本简介"><a href="#版本简介" class="headerlink" title="版本简介"></a>版本简介</h2><p>spring cloud的版本比较特殊，它不是常见的版本号形式，而是由英文单词+SR+数字的形式，英文单词由伦敦地铁命名。这种版本命名也不是什么新鲜事，比如英伟达就用物理学家名字命名自己的GPU架构</p><p>Spring Cloud版本发布记录可详见：<a href="https://github.com/spring-cloud/spring-cloud-release/releases" target="_blank" rel="noopener">https://github.com/spring-cloud/spring-cloud-release/releases</a> ，从中我们可清晰看到Spring Cloud版本发布的时间及先后顺序</p><p>Spring Cloud版本演进计划：<a href="https://github.com/spring-cloud/spring-cloud-release/milestones" target="_blank" rel="noopener">https://github.com/spring-cloud/spring-cloud-release/milestones</a> ，从中我们可了解Spring Cloud的版本演进计划，例如计划什么时间点发布什么版本等</p><h2 id="SOA"><a href="#SOA" class="headerlink" title="SOA"></a>SOA</h2><p>面向服务的架构（SOA）Service-Oriented Architecture，它将应用程序的不同功能进行拆分，并通过服务之间定义的接口联系起来，一般来说接口定义应该是中立的，即独立于平台和编程语言的，这样使得不同语言的服务能有一种统一的方式进行交互</p><h2 id="各种组件"><a href="#各种组件" class="headerlink" title="各种组件"></a>各种组件</h2><p><code>Eureka</code>: Spring Cloud用来提供服务发现和注册的组件<br><code>Ribbon</code>: 提供服务负载均衡的组件<br><code>Feign</code>: 封装服务直接的请求调用，不用指定point，这样服务ip端口变化时仍然能够访问<br><code>Hystrix</code>: 提供服务熔断, Turbine做集群监控<br><code>Zuul</code>: 提供服务网关<br><code>Config</code>: 提供统一服务配置<br><code>Sleuth</code>: 提供服务调用链，用于排查问题，和ZipKin配合使用，ZipKin提供可视化页面<br><code>Consul</code>: 是一个服务网格（微服务间的 TCP/IP，负责服务之间的网络调用、限流、熔断和监控）解决方案，它是一个一个分布式的，高度可用的系统，而且开发使用都很简便。它提供了一个功能齐全的控制平面，主要特点是：服务发现、健康检查、键值存储、安全服务通信、多数据中心<br><code>Gateway</code>: Spring-cloud 的网关服务</p><h2 id="如何使用多实例"><a href="#如何使用多实例" class="headerlink" title="如何使用多实例"></a>如何使用多实例</h2><p>这个也是我从接口api中摸索出来的，如果有更好的方式可以改进</p><p>首先服务是支持多实例的，以consul为例，我们可以配置服务名称和实例名称，服务名称通过下面两种方式设置</p><pre><code>spring.cloud.consul.discovery.service-name  显示设置spring.application.name  默认</code></pre><p>服务名称相同的归为同一个服务，然后有实例名称</p><pre><code>spring.cloud.consul.discovery.instance-id 显示设置，不设置，默认是服务名称加port</code></pre><p>当我们只有一个服务的时候，实例只有一个，当我们启动多个实例的时候，服务名称相同的归在一起</p><ol><li>如何启动多个实例？可以用profiles的形式</li></ol><pre class="line-numbers language-yml"><code class="language-yml">spring:  application:    name: rrdtool-store-service-star  cloud:    consul:      host: ${CONSUL_HOST:localhost}      port: ${CONSUL_PORT:8500}      discovery:        instance-id: ${spring.application.name}-${server.port}---server:  port: 8920spring:  profiles: node1---server:  port: 8921spring:  profiles: node2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是这样会有问题</p><p>Consul把InstanceId作为唯一标识，而Spring Cloud Consul默认的InstanceId是 <code>${spring.application.name}-${server.port}</code> 。</p><p>这样导致的问题是：某个微服务即使有多个实例，只要端口相同，那么Consul上依然只会保留1条数据！也就是说我们如果在不同的机器上用一样的端口，就会有这个问题。要想解决这个问题，只需要让不同实例，拥有不同的InstanceId即可。</p><p>解决方案: 再加一个唯一标识，或者自定义实例id，当然这个做法就不推荐了，除非有必要(ConsulAutoRegistration相关代码可以做)</p><p><code>${spring.cloud.client.ip-address}</code> 或 <code>${spring.cloud.client.hostname}</code></p><ol start="2"><li>多个实例有什么用？</li></ol><p>在feign请求服务的时候，我们设置的是服务名称，然后负载均衡策略会轮询调用具体的实例</p><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p>如何使用: 启动一个eureka service，各个微服务通过配置client把自己注册到eureka service</p><p>eureka service主要配置，起多个服务实现高可用，注意它是AP架构。下面通过一个工程的不同profiles启动多个service实现高可用，如果是部署在一台主机上，hostname不能少</p><p>依赖: spring-cloud-starter-netflix-eureka-client spring-cloud-starter-netflix-eureka-server，在启动类上加上<code>@EnableEurekaServer</code>注解</p><p>service端配置</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 由于是高可用，所以要同步数据</span>    <span class="token comment" spellcheck="true"># 是否要注册到其他Eureka Server实例</span>    <span class="token key atrule">register-with-eureka</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token comment" spellcheck="true"># 是否要从其他Eureka Server实例获取数据</span>    <span class="token key atrule">fetch-registry</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>          <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>8761/eureka/<span class="token punctuation">,</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>8762/eureka/<span class="token punctuation">---</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">profiles</span><span class="token punctuation">:</span> peer1<span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8761</span><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">instance</span><span class="token punctuation">:</span>    <span class="token key atrule">hostname</span><span class="token punctuation">:</span> peer1<span class="token punctuation">---</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">profiles</span><span class="token punctuation">:</span> peer2<span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8762</span><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">instance</span><span class="token punctuation">:</span>    <span class="token key atrule">hostname</span><span class="token punctuation">:</span> peer2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>client端加入服务</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># 指定eureka server通信地址，注意/eureka/小尾巴不能少，如果是有多个service，建议配置多个地址</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>8761/eureka/  <span class="token key atrule">instance</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 是否注册IP到eureka server，如不指定或设为false，那就会注册主机名到eureka server</span>    <span class="token key atrule">prefer-ip-address</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><p>Ribbon不在本节讨论</p><p>依赖: spring-cloud-starter-netfilx-ribbon</p><p>可以把ip+端口用服务名来代替，Ribbon可实现精确到目标服务的细粒度配置</p><p>Ribbon的负载均衡和Nginx的区别：Nginx是集中式的，把所有请求发到Nginx上，然后分发到服务消费者。ribbon是在客户端做的负载均衡，然后去请求服务消费者。Nginx多了一层客户端发到Nginx的过程</p><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><ol><li><p>依赖: spring-cloud-starter-openfeign</p></li><li><p>添加注解到启动类上</p></li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 扫描api包里的FeignClient</span><span class="token annotation punctuation">@EnableFeignClients</span><span class="token punctuation">(</span>basePackages <span class="token operator">=</span> <span class="token punctuation">{</span>CommonConstant<span class="token punctuation">.</span>BASE_PACKAGE<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="4"><li>编写Feign Client：</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"microservice-provider-user"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserFeignClient</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/users/{id}"</span><span class="token punctuation">)</span>  User <span class="token function">findById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> Long id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样一个Feign Client就完成了，其中，@FeignClient 注解中的microservice-provider-user是想要请求服务的名称，这是用来创建Ribbon Client的（Feign整合了Ribbon）。在本例中，由于使用了Eureka，所以Ribbon会把microservice-provider-user 解析成Eureka Server中的服务。</p><p>除此之外，还可使用url属性指定请求的URL（URL可以是完整的URL或主机名），例如@FeignClient(name = “abcde”, url = “<a href="http://localhost:8000/&quot;" target="_blank" rel="noopener">http://localhost:8000/"</a>) 。此时，name可以是任意值，但不可省略，否则应用将无法启动！</p><ol start="5"><li>通过Feign Client访问服务接口</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/movies"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MovieController</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Autowired</span>  <span class="token keyword">private</span> UserFeignClient userFeignClient<span class="token punctuation">;</span>  <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/users/{id}"</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> User <span class="token function">findById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> Long id<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>userFeignClient<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="应用容错"><a href="#应用容错" class="headerlink" title="应用容错"></a>应用容错</h2><p>什么是容错，就是当服务中的某个服务挂了的时候，允许这种情况，并有对应的补救。如果没有容错机制，那么A请求B，B挂了，但是A还要一直请求B，导致系统大量的资源被占用无法释放</p><ol><li>超时</li></ol><p>超时是一种比较容易的机制，比如就设置2秒，2秒没返回就释放资源</p><ol start="2"><li>舱壁模式</li></ol><p>先了解一下船舱构造——一般来说，现代的轮船都会分很多舱室，舱室之间用钢板焊死，彼此隔离。这样即使有某个/某些船舱进水，也不会影响其他舱室，浮力够，船不会沉</p><p>这种机制在程序上就是分配资源，比如A服务和B服务都只能使用系统资源的20%，这样B服务挂了也就会影响系统20%的资源</p><p>或者这样：A调用a，B调用b。AB共享同样的资源，比如线程池，当a挂了，那么B服务就被A拖死了，如果AB使用独立的线程池，那么顶多就是A把自己的线程池占满了，不会影响B</p><ol start="3"><li>断路器</li></ol><p>软件世界的断路器可以这样理解：实时监测应用，如果发现在一定时间内失败次数/失败率达到一定阈值，就“跳闸”，断路器打开——此时，请求直接返回，而不去调用原本调用的逻辑。</p><p>跳闸一段时间后（例如15秒），断路器会进入半开状态，这是一个瞬间态，此时允许一次请求调用该调的逻辑，如果成功，则断路器关闭，应用正常调用；<br>如果调用依然不成功，断路器继续回到打开状态，过段时间再进入半开状态尝试——通过”跳闸“，应用可以保护自己，而且避免浪费资源；<br>而通过半开的设计，可实现应用的“自我修复“。</p><h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><p>监控端点配置</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">management</span><span class="token punctuation">:</span>  <span class="token key atrule">endpoint</span><span class="token punctuation">:</span>    <span class="token key atrule">health</span><span class="token punctuation">:</span>      <span class="token key atrule">show-details</span><span class="token punctuation">:</span> always<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注解用法: @HystrixCommand(fallbackMethod = “findByIdFallback”) 用注解的形式加到方法上，不过一都是配合Feign使用，不推荐单独使用</p><p>默认Feign是不启用Hystrix的，需要添加如下配置启用Hystrix，这样所有的Feign Client都会受到Hystrix保护</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">feign</span><span class="token punctuation">:</span>  <span class="token key atrule">hystrix</span><span class="token punctuation">:</span>    <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>断路器实现</code></p><p>在注解上配置，有fallback和fallbackFactory，工厂多了一层封装(就是为了工厂模式嘛)，工厂模式有异常(不知道是不是要用异常一定要用工厂模式，fallback没有传递异常的地方)</p><p><code>@FeignClient(value = ServiceConstant.USER_SERVICE, configuration = CustomFeignConfig.class, fallbackFactory = UserServiceClientFallbackFactory.class)</code></p><p>Feign本身已经整合了Hystrix，可直接使用@FeignClient(value = “microservice-provider-user”, fallback = XXX.class) 来指定fallback类，fallback类继承@FeignClient所标注的接口</p><p>启动类加@EnableCircuitBreaker，引入spring-cloud-starter-hystrix(整合hystrix，其实feign中自带了hystrix，引入该依赖主要是为了使用其中的hystrix-metrics-event-stream，用于dashboard)</p><p>Hystrix服务监控点暴露</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">management</span><span class="token punctuation">:</span>  <span class="token key atrule">endpoints</span><span class="token punctuation">:</span>    <span class="token key atrule">web</span><span class="token punctuation">:</span>      <span class="token key atrule">exposure</span><span class="token punctuation">:</span>        <span class="token key atrule">include</span><span class="token punctuation">:</span> <span class="token string">'hystrix.stream'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问任意Feign Client接口的API后，再访问<a href="http://IP:PORT/actuator/hystrix.stream" target="_blank" rel="noopener">http://IP:PORT/actuator/hystrix.stream</a> ，就会展示一大堆Hystrix监控数据了</p><p><strong>特别注意：如果没有指定fallback，接口报500，但是我们可以修改默认的设置，这样就不用每个接口都在不可用的情况下返回异常了</strong></p><ol><li>fallback</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExaminationServiceClientFallbackImpl</span> <span class="token keyword">implements</span> <span class="token class-name">ExaminationServiceClient</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 对 ExaminationServiceClient 的各个接口实现，做短路时的处理</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li>fallbackFactory</li></ol><p>可以看到实现方法<code>T create(Throwable cause);</code>可以获取到异常</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExaminationServiceClientFallbackFactory</span> <span class="token keyword">implements</span> <span class="token class-name">FallbackFactory</span><span class="token operator">&lt;</span>ExaminationServiceClient<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> ExaminationServiceClient <span class="token function">create</span><span class="token punctuation">(</span>Throwable throwable<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ExaminationServiceClientFallbackImpl examinationServiceClientFallback <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExaminationServiceClientFallbackImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        examinationServiceClientFallback<span class="token punctuation">.</span><span class="token function">setThrowable</span><span class="token punctuation">(</span>throwable<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> examinationServiceClientFallback<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从源码中可以看到，不做配置，默认实现类是抛出FINE级别日志，当然前提是配置了日志</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">FallbackFactory</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/**   * Returns an instance of the fallback appropriate for the given cause   *   * @param cause corresponds to {@link com.netflix.hystrix.AbstractCommand#getExecutionException()}   *        often, but not always an instance of {@link FeignException}.   */</span>  T <span class="token function">create</span><span class="token punctuation">(</span>Throwable cause<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/** Returns a constant fallback after logging the cause to FINE level. */</span>  <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Default</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">FallbackFactory</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// jul to not add a dependency</span>    <span class="token keyword">final</span> Logger logger<span class="token punctuation">;</span>    <span class="token keyword">final</span> T constant<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Default</span><span class="token punctuation">(</span>T constant<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">(</span>constant<span class="token punctuation">,</span> Logger<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>Default<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">Default</span><span class="token punctuation">(</span>T constant<span class="token punctuation">,</span> Logger logger<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>constant <span class="token operator">=</span> <span class="token function">checkNotNull</span><span class="token punctuation">(</span>constant<span class="token punctuation">,</span> <span class="token string">"fallback"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>logger <span class="token operator">=</span> <span class="token function">checkNotNull</span><span class="token punctuation">(</span>logger<span class="token punctuation">,</span> <span class="token string">"logger"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> T <span class="token function">create</span><span class="token punctuation">(</span>Throwable cause<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isLoggable</span><span class="token punctuation">(</span>Level<span class="token punctuation">.</span>FINE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        logger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Level<span class="token punctuation">.</span>FINE<span class="token punctuation">,</span> <span class="token string">"fallback due to: "</span> <span class="token operator">+</span> cause<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cause<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> constant<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> constant<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="监控可视化"><a href="#监控可视化" class="headerlink" title="监控可视化"></a>监控可视化</h3><p>添加依赖spring-cloud-starter-netflix-hystrix-dashboard，启动类加注解：@EnableHystrixDashboard</p><p>但是这个只能监控一个服务，还可以配合Turbine，监控数据聚合-Turbine</p><p>添加依赖</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--监控可视化--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-hystrix-dashboard<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--监控数据聚合-Turbine--></span><span class="token comment" spellcheck="true">&lt;!-- 因为用了consul，需要排除eureka依赖 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-turbine<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置要监控的服务，这样在这个服务下就能监控到其它服务了</p><pre class="line-numbers language-yml"><code class="language-yml">server:  port: 9186# 监控数据聚合turbine:  appConfig: consul,auth-service,exam-service,user-service,gateway-service,msc-service  aggregator:    clusterConfig: CONSUL,AUTH-SERVICE,EXAM-SERVICE,USER-SERVICE,GATEWAY-SERVICE,MSC-SERVICE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Consule"><a href="#Consule" class="headerlink" title="Consule"></a>Consule</h2><p>服务网格是把现有的微服务直接的通信部分整合，更加的细致</p><p>如何使用: 由于consule是go编写的，CP架构，部署完成后，Spring只需要关注clien如何加入即可完成集成</p><p>consule的功能比较丰富，也可以用它来代替config-service，依赖 <code>spring-cloud-starter-consul-config</code></p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>consul agent -server -client=0.0.0.0 -bootstrap-expect=3 -data-dir=/Users/liuzhi/cloud/data/ -node=server1</p><p>consul agent -dev</p><h2 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h2><p>是一种统一配置管理的方案，简单来说要这样使用: 部署一个config service，这个服务有各个微服务需要用到的配置文件信息，然后可以通过restful或client与config service进行交互，这样各个微服务就能获取到配置参数了</p><p>对于这个config service它是可以动态修改的，可以高可用；另外还有一个概念就是配置文件的存储方式，有git，mysql，本地文件系统等形式</p><p>如何使用: 要启动一个cloud service服务，然后其它服务去这里读取配置文件，基本就是这么一个流程。</p><p>关于高可用: </p><ol><li><p>存储仓库的高可用，如果是第三方git，本身高可用(除非你网络有问题)，当然实际肯定用自己搭建的，就需要准备高可用，存储也是，文件系统高可用</p></li><li><p>服务高可用，可以使用注册中心，把多个service注册到服务中心，clien也是从注册中心读取配置。如果不用注册中心，就需要负载均衡器做高可用。当然soa架构，肯定是有注册中心的 </p></li></ol><p>关于动态刷新: 这里我有个疑问，假如是通过<code>@Value</code>读取的配置文件，那么刷新后用新的值，确实没问题，但是像数据库配置这种，刷新后应该是要重启才行吧(简单属性和比较复杂的配置属性)，未完待续</p><p>数据库配置是已经装配好bean工厂了，理论需要重启，没去式了。config服务会缓存配置信息，所以修改后其它服务取到的都是未修改之前的数据，所以热刷新还是有必要的，开发阶段就不用一直重启配置服务了(因为jrebel无法对资源文件监控，所以还是要重启，推荐尽快跟上热刷新)</p><p>实现动态刷新:</p><ol><li>引入依赖</li><li>开启监控点</li><li>加上注解</li></ol><p>bus，是通过消息广播，一个客户端刷新后，通知其它服务刷新</p><p>注意，在使用了security后，刷新接口会报403异常，需要加入访问权限</p><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>项目结构规划</p><p>config-service 的client配置的连接service端的配置文件要写bootstrap中，原因如下:</p><ol><li>bootstrap.yml文件中的内容不能放到application.yml中，否则config部分无法被加载</li><li>因为config部分的配置先于application.yml被加载，而bootstrap.yml中的配置会先于application.yml加载</li><li>bootstarp配置文件是从云端加载配置文件。优先级高于application，项目启动时，会先去加载自带的配置文件(框架自己的)，然后加载bootstrap配置文件，将加载到的内容放入到application中</li></ol><p>上面是什么意思呢？这是一个很重要的点，首先对于config-service来说，正常部署使用即可；而对于依赖于config-service配置的其它微服务来说，由于系统启动的时候就需要加载配置文件，绑定config-server的URL，然后在加载application配置。如果bootstrap文件找不到或者没有配置server的URL，系统会默认URL为<a href="http://127.0.0.1:8888(当然是你使用spring-cloud-starter-config依赖才是这个逻辑)" target="_blank" rel="noopener">http://127.0.0.1:8888(当然是你使用spring-cloud-starter-config依赖才是这个逻辑)</a></p><p>可以看到引入依赖后，不配置的默认输出</p><pre class="line-numbers language-log"><code class="language-log">2020-02-20 17:13:40.418  INFO 36775 --- [  restartedMain] c.c.c.ConfigServicePropertySourceLocator : Fetching config from server at : http://localhost:88882020-02-20 17:13:40.554  INFO 36775 --- [  restartedMain] c.c.c.ConfigServicePropertySourceLocator : Connect Timeout Exception on Url - http://localhost:8888. Will be trying the next url if available2020-02-20 17:13:40.554  WARN 36775 --- [  restartedMain] c.c.c.ConfigServicePropertySourceLocator : Could not locate PropertySource: I/O error on GET request for "http://localhost:8888/application/default": Connection refused (Connection refused); nested exception is java.net.ConnectException: Connection refused (Connection refused)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们直接配置在application中就会导致读取不到配置文件，这个时候的报错大多数都是读取不到配置文件的错误，另外可能有人把配置文件在application也准备一份，这种情况不会报错(因为读取不到，使用了本地的，编译通过)，但是client是没有使用config-service的，这种情况也是要注意的</p><p>当我们在代码中使用配置文件的值绑定到属性的时候，service端有用service，没有用本地，本地没有报错</p><h2 id="spring-boot-admin"><a href="#spring-boot-admin" class="headerlink" title="spring boot admin"></a>spring boot admin</h2><p>用于管理和监控SpringBoot应用程序</p><p>应用程序作为Spring Boot Admin Client向为Spring Boot Admin Server注册（通过HTTP）或使用SpringCloud注册中心（例如Eureka，Consul）发现<br>UI是的AngularJs应用程序，展示Spring Boot Admin Client的Actuator端点上的一些监控</p><p>如何使用</p><ol><li>首先我们要单独部署一个服务，这个服务就是admin的服务，作为service端，其它spring boot应用作为client端。依赖spring-boot-admin-starter-server，然后启动类加上注解 @EnableAdminServer</li><li>其它spring boot应用作为client端加入到admin服务中，这里需要注意，具体如下</li></ol><p>如果没用注册中心，客户端是要配置下面的参数的，就是通过http去注册</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">boot</span><span class="token punctuation">:</span>    <span class="token key atrule">admin</span><span class="token punctuation">:</span>      <span class="token key atrule">client</span><span class="token punctuation">:</span>        <span class="token key atrule">url</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//$<span class="token punctuation">{</span>ADMIN_HOST<span class="token punctuation">:</span>localhost<span class="token punctuation">}</span><span class="token punctuation">:</span>$<span class="token punctuation">{</span>ADMIN_PORT<span class="token punctuation">:</span><span class="token number">8520</span><span class="token punctuation">}</span>/admin        <span class="token key atrule">username</span><span class="token punctuation">:</span> $<span class="token punctuation">{</span>ADMIN_USERNAME<span class="token punctuation">:</span>admin<span class="token punctuation">}</span>        <span class="token key atrule">password</span><span class="token punctuation">:</span> $<span class="token punctuation">{</span>ADMIN_PASSWORD<span class="token punctuation">:</span>exVan1234<span class="token punctuation">}</span>        <span class="token key atrule">instance</span><span class="token punctuation">:</span>          <span class="token key atrule">service-base-url</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//$<span class="token punctuation">{</span>USER_SERVICE_HOST<span class="token punctuation">:</span>localhost<span class="token punctuation">}</span><span class="token punctuation">:</span>$<span class="token punctuation">{</span>server.port<span class="token punctuation">}</span>          <span class="token key atrule">metadata</span><span class="token punctuation">:</span>            <span class="token key atrule">tags</span><span class="token punctuation">:</span>              <span class="token key atrule">environment</span><span class="token punctuation">:</span> dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果配置了注册中心，可以不需要这个配置，甚至依赖都不需要。但是这种情况发现admin有些许差异</p><p>推荐：使用注册中心的话，也把依赖和配置加上</p><p><code>注意</code>: Spring Boot Admin 不是 Spring Boot starter 风格的，需要注意版本号，启动失败，大概率是版本不兼容的问题</p><p>关于存储: 发现监控服务的一些配置添加后，下次启动还有效，换浏览器无效，猜测是用了浏览器来缓存配置和添加的监控点设置吧，不深入了</p><p>关于security: 配置后需要鉴权才能访问admin服务</p><h2 id="触发自我保护机制"><a href="#触发自我保护机制" class="headerlink" title="触发自我保护机制"></a>触发自我保护机制</h2><p>部署起spring cloud相关组件后，在Eureka页面有时会报这个异常</p><p><code>EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY'RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.</code></p><p>Euerka Service和Euerka Client之间，默认30秒进行一次心跳，出现这个异常是因为client少于一定的阈值，server不会删除注册信息，这就有可能导致在调用微服务时，实际上服务并不存在。 这种保护状态实际上是考虑了client和server之间的心跳是因为网络问题，而非服务本身问题，不能简单的删除注册信息</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机基础知识补充</title>
      <link href="/2019/10/20/blog/computer-base/"/>
      <url>/2019/10/20/blog/computer-base/</url>
      
        <content type="html"><![CDATA[<p>计算机基础知识补充，基础是重中之重</p><a id="more"></a><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>这里只讨论整数</p><ul><li><p>正数的原码和反码，补码是一样的</p></li><li><p>负数的反码等于原码保留符号位，其余位取反；补码为保留符号位，其余位取反加1</p></li></ul><p>两个整数相加，无论正负，可以转换成两个数的补码相加，相加的结果进位超出的去掉，计算时最高位不考虑符号位的问题，以此把减法变加法</p><p>48 + (-29) = 19</p><p>原码:<br>48   00011 0000<br>-29  1001  1101</p><p>补码:<br>48   0011  0000<br>-29  1110  0011</p><p>两个补码相加  0001 0011  10进制为19，用加法在不用考虑符号位的情况下，实现了减法，</p><p><code>在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理。此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路</code></p><h2 id="左移右移"><a href="#左移右移" class="headerlink" title="左移右移"></a>左移右移</h2><p>计算规则: 符号位要参与移动运算，除了<code>负数右移</code>往最高位补1外，其余情况均在空位处补0，在不考虑符号位，只看绝对值的情况下，左移是扩大数值2倍，右移是缩小数值两倍，不过这是近似的结果，而且位移导致符号位是不确定的，</p><p>运算符号写法 <code>&lt;&lt; or &gt;&gt;</code>，<code>&gt;&gt;&gt;</code> 三个的代表无符号右移动，没有<code>&lt;&lt;&lt;</code>。<code>&gt;&gt;&gt;</code>移动时，最高位均补0，正数不断右移动最小值0，负数最小值1</p><h2 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h2><p>如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。和与运算相反</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>记住，在各种编程语言中，计算得到的浮点数都是精度不准确的，所以不要轻易返回浮点数</p><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>哈希是摘要算法</p><p><a href="https://www.cnblogs.com/aspirant/p/11470928.html" target="_blank" rel="noopener">https://www.cnblogs.com/aspirant/p/11470928.html</a></p><p>一、何为加载因子？<br>加载因子是表示Hsah表中元素的填满的程度.若:加载因子越大,填满的元素越多,好处是,空间利用率高了,但:冲突的机会加大了.反之,加载因子越小,填满的元素越少,好处是:冲突的机会减小了,但:空间浪费多了.</p><p>冲突的机会越大,则查找的成本越高.反之,查找的成本越小.因而,查找时间就越小. </p><p>因此,必须在 “冲突的机会”与”空间利用率”之间寻找一种平衡与折衷. 这种平衡与折衷本质上是数据结构中有名的”时-空”矛盾的平衡与折衷.</p><p>二、HashMap中的加载因子<br>HashMap默认的加载因子是0.75，最大容量是16，因此可以得出HashMap的默认容量是：0.75*16=12。容量超过12就要进行再哈希，重新计算哈希表，原来的要删除</p><p>用户可以自定义最大容量和加载因子。</p><p>HashMap 包含如下几个构造器：</p><p>HashMap()：构建一个初始容量为 16，负载因子为 0.75 的 HashMap。</p><p>HashMap(int initialCapacity)：构建一个初始容量为 initialCapacity，负载因子为 0.75 的 HashMap。</p><p>HashMap(int initialCapacity, float loadFactor)：以指定初始容量、指定的负载因子创建一个 HashMap。</p><h2 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h2><p>RTTI（Run-Time Type Identification)，通过运行时类型信息程序能够使用基类的指针或引用来检查这些指针或引用所指的对象的实际派生类型。</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>网关和路由器最大的区别是是否连接相似的网络。如果连接相似的网络，则称为路由器。而连接不相似的网络，称为网关。（个人认为这个关字可以从海关上来理解，出关，海关）</p><p>相似的网络和不相似的网络有两种不同的含义。</p><p>逻辑层面：</p><p>相似的网络：如果都是互联网上的两个网络，我们称为相似的网络。不相似的网络：如果一个是私网，一个是公网。我们称为不相似的网络。</p><p>物理层面：</p><p>相似的网络：都是以太网或者同一种介质的网络。<br>不相似的网络：一边是以太，一边是SDH或者ATM等</p><p>子网（Sub-net）出口路由器就叫网关了，后面还有很多中继路由器。所以网关一定是路由器，但路由器不一定用来做网关</p><p><code>TTL  Time to live</code> 域名解析在DNS服务器中存留时间        </p><p>实际指转发的最大跳数，主机发送ip包的时候，在网络中转发，转发一次该值减1，为了防止无限转发和循环而设置这个值。如果变成1还没到目标地址，即为超时</p><h2 id="月份复习"><a href="#月份复习" class="headerlink" title="月份复习"></a>月份复习</h2><p>january 一月 简称 Jan</p><p>February 二月 简称 Feb</p><p>March 三月 简称 Mar</p><p>April 四月 简称 Apr</p><p>May 五月 简称 May</p><p>June 六月 简称 Jun</p><p>July 七月 简称 Jul</p><p>August 八月 简称 Aug</p><p>Septemper 九月 简称 Sep</p><p>October 十月 简称 Oct</p><p>November 十一 月 简称 Nov</p><p>December 十二月 简称 Dec</p><h2 id="kill-9"><a href="#kill-9" class="headerlink" title="kill -9"></a>kill -9</h2><p>使用 kill -l 查看系统支持的信号</p><p>kill和kill -9，两个命令在linux中都有杀死进程的效果，然而两命令的执行过程却大有不同，在程序中如果用错了，可能会造成莫名其妙的现象</p><p>执行kill（不加 -* 默认kill -15）命令，系统会发送一个SIGTERM信号给对应的程序。当程序接收到该signal信号后，将会发生以下事情：</p><ul><li><p>程序立刻停止</p></li><li><p>当程序释放相应资源后再停止</p></li><li><p>程序可能仍然继续运行</p></li></ul><p>大部分程序接收到SIGTERM信号后，会先释放自己的资源，然后再停止。但是也有程序可能接收信号后，做一些其他的事情（如果程序正在等待IO，可能就不会立马做出响应，我在使用wkhtmltopdf转pdf的项目中遇到这现象），也就是说，SIGTERM多半是会被阻塞的</p><p>然而kill -9命令，系统给对应程序发送的信号是SIGKILL，即exit。exit信号不会被系统阻塞，所以kill -9能顺利杀掉进程</p><p>小结：在使用 kill -9 前，应该先使用 kill -15，给目标进程一个清理善后工作的机会。如果没有，可能会留下一些不完整的文件或状态，从而影响服务的再次启动。</p><p>通常，应该发送15，等一两秒钟，如果没效果，发送2，如果还不行，发送1。如果还不行，那你应该把那个程序删掉，因为那个程序写的太烂了！</p><p><code>不要使用kill -9。不要用收割机来修剪花盆里的花</code></p><p>总之，在使用kill -9前，你应该先使用kill -15，给目标进程一个清理善后工作的机会。(进程也许无法捕捉或直接忽略SIGKILL信号，但它们可以，通常也是能够捕捉SIGTERM信号的。)如果你不留机会让进程完成清理工作，它们会留下一些不完整的文件或状态，当系统重启时，程序将无法理解这些状态</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Technology技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FormData 表单对象</title>
      <link href="/2019/08/06/Web/form/"/>
      <url>/2019/08/06/Web/form/</url>
      
        <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>FormData 对象，可以创建表单对象，通过append方法添加字段，也可以传入表单DOM对象，获取页面已经输入的值（不过该方法在element-ui中无用），猜测<br>是因为DOM被Vue托管，属性已经发生改变，无法被原生对象FormData获取到数据，所以要注意使用FormData对象后，如何和后端交互的问题，可以参考代码。</p><p>ContentType指的是请求体的编码类型，常见的类型共有3种：</p><ol><li>application/x-www-form-urlencoded<br>浏览器原生表单<form>默认的提交数据的方式（就是没有设置enctype属性），POST提交数据的默认方式。</form></li></ol><p>application/x-www-form-urlencoded 方式提交数据</p><p>POST <a href="http://www.example.com" target="_blank" rel="noopener">http://www.example.com</a> HTTP/1.1<br>Content-Type: application/x-www-form-urlencoded;charset=utf-8</p><p><code>下面是浏览器传递时数据的格式</code><br>name=qwe&amp;pwd=123</p><ol start="2"><li>multipart/form-data，和第一种类似，但是如果是文件上传，那么要用这个enctype</li></ol><p>Request URL:<a href="http://127.0.0.1:8000/index/" target="_blank" rel="noopener">http://127.0.0.1:8000/index/</a><br>Content-Type:multipart/form-data; boundary=—-WebKitFormBoundaryExT8avmSnrECoDbP</p><p><code>下面是浏览器传递时数据的格式，可以看到加了很多内容</code><br>——WebKitFormBoundaryExT8avmSnrECoDbP<br>Content-Disposition: form-data; name=”name”</p><p>qwe<br>——WebKitFormBoundaryExT8avmSnrECoDbP<br>Content-Disposition: form-data; name=”pwd”</p><p>123<br>——WebKitFormBoundaryExT8avmSnrECoDbP<br>Content-Disposition: form-data; name=”icon”; filename=”0fbc751ff63fa8cf3302b03889b9421e65d6592301”<br>Content-Type: application/octet-stream</p><p>——WebKitFormBoundaryExT8avmSnrECoDbP–</p><ol start="3"><li>application/json<br>application/json 这个 Content-Type 常作为作为响应头，现在页经常使用它作为请求头，用来告诉服务端消息主题是序列化后的JSON字符串。</li></ol><p>由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前后端分类中OPTIONS请求，如何避免OPTIONS请求</title>
      <link href="/2019/08/06/Web/options/"/>
      <url>/2019/08/06/Web/options/</url>
      
        <content type="html"><![CDATA[<p>如何避免OPTIONS请求</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>场景：在调用后端接口的时候会出现两次请求：OPTIONS请求和GET请求。OPTIONS请求耗费了一定的时间，需减少OPTIONS请求。</p><p>查找原因是浏览器对简单跨域请求和复杂跨域请求的处理区别。</p><p>XMLHttpRequest会遵守同源策略(same-origin policy). 也即脚本只能访问相同协议/相同主机名/相同端口的资源, 如果要突破这个限制, 那就是所谓的跨域, 此时需要遵守跨域资源共享标准CORS(Cross-Origin Resource Sharing)机制。</p><p>浏览器将CORS请求分为两类：简单请求（simple request）和非简单请求（not-simple-request）。</p><p>简单请求浏览器请求不会触发预检请求，而非简单请求会触发预检请求。这两种方式怎么区分？</p><p>同时满足下列以下条件，就属于简单请求，否则属于非简单请求（参考HTTP访问控制（CORS））</p><ol><li><p>请求方式只能是：GET、POST、HEAD</p></li><li><p>HTTP请求头限制这几种字段（不得人为设置该集合之外的其他首部字段）:</p></li></ol><p>Accept、Accept-Language、Content-Language、Content-Type（需要注意额外的限制）、DPR、Downlink、Save-Data、Viewport-Width、Width</p><ol start="3"><li><p>Content-type只能取：application/x-www-form-urlencoded、multipart/form-data、text/plain</p></li><li><p>请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。</p></li><li><p>请求中没有使用 ReadableStream 对象。</p></li></ol><p>非简单请求 会在正式通信之前，增加一次HTTP请求，称之为预检请求。浏览器会先发起OPTIONS方法到服务器，以获知服务器是否允许该实际请求。</p><p><code>----------------------</code></p><p>由此可知，若要我们的请求满足简单请求就可以避免发起OPTIONS请求了。</p><p>但是</p><ol><li><p>我们系统请求中除了GET/POST还有PUT,DELETE，不能满足</p></li><li><p>我们系统有做业务模块权限，请求头里需要带有用户验证信息，第二点也不满足</p></li><li><p>我们的Content-Type绝大多数是application/json，还是不满足</p></li></ol><p>然后只能寄希望于减少发起OPTIONS请求的次数，也就是说还是会用，但不是每次都用，查到的方法如下：</p><p>后端在请求的返回头部添加：</p><p>Access-Control-Max-Age：（number）  。数值代表preflight request  （预检请求）的返回结果（即 Access-Control-Allow-Methods 和Access-Control-Allow-Headers 提供的信息） 可以被缓存多久，单位是秒。</p><p>例如：将预检请求的结果缓存10分钟：</p><p>Access-Control-Max-Age: 600 </p><p>不同浏览器有不同的上限。在Firefox中，上限是24h（即86400秒），而在Chromium 中则是10min（即600秒）。Chromium 同时规定了一个默认值 5 秒。<br>如果值为 -1，则表示禁用缓存，每一次请求都需要提供预检请求，即用OPTIONS请求进行检测。</p><p>Access-Control-Max-Age方法对完全一样的url的缓存设置生效，多一个参数也视为不同url。也就是说，如果设置了10分钟的缓存，在10分钟内，所有请求第一次会产生options请求，第二次以及第二次以后就只发送真正的请求了。</p><p>原文出处：<a href="https://blog.csdn.net/xiaoxiong_jiaxin/article/details/88060663" target="_blank" rel="noopener">https://blog.csdn.net/xiaoxiong_jiaxin/article/details/88060663</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>理解什么是OPTIONS请求，什么时候会有OPTIONS请求，由于这个是可以避免的，尽量不要在生产上出现</p><h2 id="vue中"><a href="#vue中" class="headerlink" title="vue中"></a>vue中</h2><p>vue使用的是代理，没有跨域，当然这是在开发阶段，上线也可以考虑使用代理，Nginx，或vue自己的代理</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springSecurity安全框架</title>
      <link href="/2019/07/28/Java/springSecurity/"/>
      <url>/2019/07/28/Java/springSecurity/</url>
      
        <content type="html"><![CDATA[<p>springSecurity安全框架学习笔记，使用配置总结</p><a id="more"></a><h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><p>如果要对Web资源进行保护，最好的办法莫过于Filter，要想对方法调用进行保护，最好的办法莫过于AOP</p><p>Security主要思想就是通过filter来实现的，整个流程包含各种过滤器</p><ol><li>主要过滤器  </li></ol><p>WebAsyncManagerIntegrationFilter<br>SecurityContextPersistenceFilter<br>HeaderWriterFilter<br>CorsFilter<br>LogoutFilter<br>RequestCacheAwareFilter<br>SecurityContextHolderAwareRequestFilter<br>AnonymousAuthenticationFilter<br>SessionManagementFilter<br>ExceptionTranslationFilter<br>FilterSecurityInterceptor<br>UsernamePasswordAuthenticationFilter<br>BasicAuthenticationFilter        </p><ol start="2"><li>框架的核心组件</li></ol><p>SecurityContextHolder 提供对SecurityContext的访问<br>SecurityContext 持有Authentication对象和其他可能需要的信息<br>AuthenticationManager 认证管理器，其中可以包含多个AuthenticationProvider<br>ProviderManager 对象为AuthenticationManager接口的实现类<br>AuthenticationProvider 主要用来进行认证操作的类 调用其中的authenticate()方法去进行认证操作<br>Authentication Spring Security方式的认证主体<br>GrantedAuthority 对认证主题的应用层面的授权，含当前用户的权限信息，通常使用角色表示<br>UserDetails 构建Authentication对象必须的信息，可以自定义，可能需要访问DB得到<br>UserDetailsService 通过username构建UserDetails对象，通过loadUserByUsername根据userName获取UserDetail对象 （可以在这里基于自身业务进行自定义的实现  如通过数据库，xml,缓存获取等）</p><h2 id="UserDetailsService"><a href="#UserDetailsService" class="headerlink" title="UserDetailsService"></a>UserDetailsService</h2><p>这是一个接口，实现后需要返回一个框架自身的User类型对象，User又是UserDetails的实现</p><p>主要实现loadUserByUsername方法，就是如何通过用户名获取用户对象，这个用户对象必须是框架提供的类型，并且包括了相关的权限信息</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Description * @Author VanLiuZhi * @Date 2020-02-18 15:01 */</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyUserDetailsUserService</span> <span class="token keyword">implements</span> <span class="token class-name">UserDetailsService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> UserDetails <span class="token function">loadUserByUsername</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token keyword">throws</span> UsernameNotFoundException <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span>                <span class="token string">"User"</span><span class="token punctuation">,</span>                PasswordEncoderFactories<span class="token punctuation">.</span><span class="token function">createDelegatingPasswordEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span><span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                AuthorityUtils<span class="token punctuation">.</span><span class="token function">commaSeparatedStringToAuthorityList</span><span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面是一个模拟，通过用户名加载到都是一样的User对象，实际应该去数据库查询</p><p><strong>关于密码加密的形式，我找到两种说法，这里做个记录。在我的比较新的版本中，已经不会出现方式一的问题了</strong></p><p>不过我也测试出了很多有价值的东西，在配置文件中配置<code>passwordEncoder</code>，使用<code>PasswordEncoderFactories.createDelegatingPasswordEncoder()</code>，和<code>userDetailsService</code>实现类中，也使用同样的(看上图的代码)，那么就是正常的。猜测原来默认不配置应该是使用<code>PasswordEncoderFactories.createDelegatingPasswordEncoder()</code>进行加密，后来改了，新版本的默认加密编码就用<code>BCryptPasswordEncoder()</code></p><p>总结就是要统一，测试版本5.1.7，推荐使用方式二</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// config文件中</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span>AuthenticationManagerBuilder auth<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    auth<span class="token punctuation">.</span><span class="token function">userDetailsService</span><span class="token punctuation">(</span>userDetailsService<span class="token punctuation">)</span><span class="token punctuation">.</span>            <span class="token function">passwordEncoder</span><span class="token punctuation">(</span><span class="token function">passwordEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> PasswordEncoder <span class="token function">passwordEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> PasswordEncoderFactories<span class="token punctuation">.</span><span class="token function">createDelegatingPasswordEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>方式一:</p><p>不能直接创建 <code>BCryptPasswordEncoder</code> 对象来加密， 这种加密方式 没有 <code>{bcrypt}</code> 前缀<br>会导致在 matches 时导致获取不到加密的算法出现 <code>java.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id "null"</code>  问题。<br>问题原因是 Spring Security5 使用 DelegatingPasswordEncoder(委托)  替代 NoOpPasswordEncoder，并且 默认使用  BCryptPasswordEncoder 加密（注意 DelegatingPasswordEncoder 委托加密方法 BCryptPasswordEncoder 加密前 添加了加密类型的前缀）<br><a href="https://blog.csdn.net/alinyua/article/details/80219500" target="_blank" rel="noopener">https://blog.csdn.net/alinyua/article/details/80219500</a></p><p>方式二: </p><ol><li>在配置中声名一个bean</li></ol><p>@Bean<br>public PasswordEncoder passwordEncoder() {<br>    return new BCryptPasswordEncoder();<br>}</p><ol start="2"><li>UserDetailsService实现类注入</li></ol><p>@Autowired<br>private PasswordEncoder passwordEncoder;</p><ol start="3"><li>加密</li></ol><p>passwordEncoder.encode(“123456”)</p></blockquote><p>两种方式加密的结果，确实是多了个前缀，具体可以看源码</p><p>$2a$10$oUpt1tFddYCQXy0V3EEt6uM1V2BzRnYrGbcBhpOUFq1egzS2ocYZO<br><code>{bcrypt}</code>$2a$10$CZWyE3FxdYfvYRGdTBVYue2i5PISShMxtgSnVJ4zs0RPyb9QLkJbW</p><h2 id="Security-Config"><a href="#Security-Config" class="headerlink" title="Security Config"></a>Security Config</h2><p>Security配置，是继承覆盖父类的形式，围绕着两个方面来</p><ol><li>安全策略配置自定义</li><li>用户详情和密码加密方法自定义</li></ol><p>最简单的实现就是覆盖两个方法，一个负责对请求资源的权限设置，比如哪些路径需要登录。还有另外一个方法，配置认证，就是配置怎么去认证，输入的账号密码是否正确</p><p>刚才对UserDetailService的实现在这里就用到了</p><h3 id="用到的注解"><a href="#用到的注解" class="headerlink" title="用到的注解"></a>用到的注解</h3><p><code>@EnableWebSecurity</code><br>启用WebSecurity，都要配置</p><p><code>@EnableGlobalMethodSecurity(prePostEnabled=true)</code><br>要开启Spring方法级安全，在添加了@Configuration注解的类上再添加@EnableGlobalMethodSecurity注解即可，对请求方法做权限控制，一般都要用</p><p>查看注解，发现它还提供了很多类型</p><p><code>prePostEnabled</code>： 确定 前置注解[@PreAuthorize,@PostAuthorize,..] 是否启用<br><code>securedEnabled</code>： 确定安全注解 [@Secured] 是否启用<br><code>jsr250Enabled</code>： 确定 JSR-250注解 [@RolesAllowed..]是否启用</p><p>可以启用多种类型的注解，但是在方法中只能生效一种</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@EnableWebSecurity</span><span class="token annotation punctuation">@EnableGlobalMethodSecurity</span><span class="token punctuation">(</span>prePostEnabled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span> securedEnabled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebSecurityConfig</span> <span class="token keyword">extends</span> <span class="token class-name">WebSecurityConfigurerAdapter</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在方法中使用，多数是在controller层用</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>  List<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token function">findAllUsers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token annotation punctuation">@PreAuthorize</span><span class="token punctuation">(</span><span class="token string">"hasAnyRole('user')"</span><span class="token punctuation">)</span>  <span class="token keyword">void</span> <span class="token function">updateUser</span><span class="token punctuation">(</span>User user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 下面不能设置两个注解，如果设置两个，只有其中一个生效</span>    <span class="token comment" spellcheck="true">// @PreAuthorize("hasAnyRole('user')")</span>  <span class="token annotation punctuation">@Secured</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token string">"ROLE_user"</span><span class="token punctuation">,</span> <span class="token string">"ROLE_admin"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token keyword">void</span> <span class="token function">deleteUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结就是启用方法权限控制，通过设置的权限和用户的权限表做匹配决定是否能调用方法，这里用户的权限表就是通过UserDetailService来获取的。有三种模式，PreAuthorize用的比较广，有专门的表达式来编写，比如<code>hasAnyRole('user')</code>就是用了表达式，这个不是乱写的</p><p>参考<br><a href="https://docs.spring.io/spring-security/site/docs/4.0.1.RELEASE/reference/htmlsingle/#el-common-built-in" target="_blank" rel="noopener">https://docs.spring.io/spring-security/site/docs/4.0.1.RELEASE/reference/htmlsingle/#el-common-built-in</a></p><p><a href="https://www.jianshu.com/p/77b4835b6e8e" target="_blank" rel="noopener">https://www.jianshu.com/p/77b4835b6e8e</a></p><h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@EnableWebSecurity</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SecurityConfig</span> <span class="token keyword">extends</span> <span class="token class-name">WebSecurityConfigurerAdapter</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserDetailsService userDetailsService<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 这是Security的安全认证策略,默认的是所有请求都可以在授权之后访问     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span>HttpSecurity http<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        http                <span class="token punctuation">.</span><span class="token function">formLogin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">authorizeRequests</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">anyRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">authenticated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其它例子</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 不会拦截/user,因为只会匹配"/api/**"，可以写多个http，不要冲突</span>http<span class="token punctuation">.</span><span class="token function">requestMatchers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">antMatchers</span><span class="token punctuation">(</span><span class="token string">"/api/**"</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">authorizeRequests</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">antMatchers</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">,</span><span class="token string">"/api/user"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">authenticated</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">anyRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">authenticated</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">formLogin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">loginPage</span><span class="token punctuation">(</span><span class="token string">"/login"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//需要人证</span>        <span class="token comment" spellcheck="true">// http.authorizeRequests().antMatchers("/user").hasRole("Admin");</span>        <span class="token comment" spellcheck="true">// .and().formLogin().loginPage("/login");</span>        <span class="token comment" spellcheck="true">// api请求都不需要权限认证</span>        <span class="token comment" spellcheck="true">// http.authorizeRequests().antMatchers("/api").permitAll();</span>        <span class="token comment" spellcheck="true">// data/** Get请求不需要权限人证</span>        <span class="token comment" spellcheck="true">// http.authorizeRequests().antMatchers(HttpMethod.GET,"/data/**").permitAll();</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法使用说明，大致就是各种路由设置，鉴权设置</p><p>authorizeRequests() 开始请求权限配置<br>antMatchers() 使用Ant风格的路径匹配<br>permitAll() 用户可任意访问<br>anyRequest() 匹配所有路径<br>authenticated() 用户登录后可访问</p><ul><li><p>URL匹配<br>requestMatchers() 配置一个request Mather数组，参数为RequestMatcher 对象，其match 规则自定义，需要的时候放在最前面，对需要匹配的的规则进行自定义与过滤<br>authorizeRequests() URL权限配置<br>antMatchers() 配置一个request Mather 的 string数组，参数为 ant 路径格式， 直接匹配url<br>anyRequest 匹配任意url，无参 ,最好放在最后面</p></li><li><p>保护URL<br>authenticated() 保护UrL，需要用户登录<br>permitAll() 指定URL无需保护，一般应用与静态资源文件<br>hasRole(String role) 限制单个角色访问，角色将被增加 “ROLE_” .所以”ADMIN” 将和 “ROLE_ADMIN”进行比较. 另一个方法是hasAuthority(String authority)<br>hasAnyRole(String… roles) 允许多个角色访问. 另一个方法是hasAnyAuthority(String… authorities)<br>access(String attribute) 该方法使用 SPEL, 所以可以创建复杂的限制 例如如access(“permitAll”), access(“hasRole(‘ADMIN’) and hasIpAddress(‘123.123.123.123’)”)<br>hasIpAddress(String ipaddressExpression) 限制IP地址或子网</p></li><li><p>登录login<br>formLogin() 基于表单登录<br>loginPage() 登录页<br>defaultSuccessUrl 登录成功后的默认处理页<br>failuerHandler登录失败之后的处理器<br>successHandler登录成功之后的处理器<br>failuerUrl登录失败之后系统转向的url，默认是this.loginPage + “?error”</p></li><li><p>登出logout<br>logoutUrl 登出url ， 默认是/logout， 它可以是一个ant path url<br>logoutSuccessUrl 登出成功后跳转的 url 默认是”/login?logout”<br>logoutSuccessHandler 登出成功处理器，设置后会把logoutSuccessUrl 置为null</p></li></ul><p>特别</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// HttpSecurity 下的</span><span class="token keyword">public</span> HttpSecurity <span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> HttpSecurity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// SecurityConfigurerAdapter 下的</span><span class="token keyword">public</span> B <span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">getBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">protected</span> <span class="token keyword">final</span> B <span class="token function">getBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>securityBuilder <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"securityBuilder cannot be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> securityBuilder<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有2个and方法，有些方法会返回getBuilder，也和and一样，最后指向securityBuilder</p><h2 id="OAuth-2-0"><a href="#OAuth-2-0" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h2><p>项目源码数据库模型地址: <a href="https://github.com/spring-projects/spring-security-oauth/blob/master/spring-security-oauth2/src/test/resources/schema.sql" target="_blank" rel="noopener">https://github.com/spring-projects/spring-security-oauth/blob/master/spring-security-oauth2/src/test/resources/schema.sql</a></p><p>学习一个新技术，最好的方式莫过于直接看源码</p><p>security的使用还是比较简单的，复杂的是Oauth2</p><p>OAuth 的核心就是向第三方应用颁发令牌，OAuth 2.0 规定了四种获得令牌的流程，可以选择一种方式颁发令牌</p><p>授权码（authorization-code）<br>隐藏式（implicit）<br>密码式（password）<br>客户端凭证（client credentials）</p><p>Authorization Code（授权码模式）：正宗的OAuth2的授权模式，客户端先将用户导向认证服务器，登录后获取授权码，然后进行授权，最后根据授权码获取访问令牌；<br>Implicit（简化模式）：和授权码模式相比，取消了获取授权码的过程，直接获取访问令牌；<br>Resource Owner Password Credentials（密码模式）：客户端直接向用户获取用户名和密码，之后向认证服务器获取访问令牌；<br>Client Credentials（客户端模式）：客户端直接通过客户端认证（比如client_id和client_secret）从认证服务器获取访问令牌。</p><p>这里说下自己的理解: </p><p>授权码模式安全级别最高，是因为，认证服务器，授权服务器都是自己信任的，而涉及到客户端获取用户账号密码，是不可信的。</p><p>简单来说，假如我开发了一套大型系统，我提供给各个企业用，企业可以实现自己的访问客户端，但是用户数据在我这里，那么企业自己的客户端就是不可信的</p><p>我们可以通过常见的qq第三方登录来说明。比如通过qq登录，客户端是第三方开发的，它支持qq登录，但是你不会直接把qq密码在客户端上输入，这是不安全的，qq提供认证服务器给客户端，客户端引导用户去qq的认证登录页面，由于这个页面是qq做的，所以它是安全的，你输入账号密码后，得到授权码，之后客户端通过授权码去获取令牌，这样后续qq的接口，比如获取用户详情等，客户端通常需要这些数据来创建自己的用户，之后的qq接口通过授权码访问即可。你会发现，客户端全程拿不到你的密码，所以授权码模式级别高，但是也复杂。只要理解了授权码模式，理解其它模式就简单了</p><p><code>在程序中，需要做相关的配置，使用上面的英文</code></p><p>注意，不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的</p><p><code>在程序中也有这个配置，声名哪些服务能获取令牌</code></p><p>在架构设计中，一般存在三种角色</p><ol><li>客户应用</li><li>资源服务器</li><li>授权服务器  </li></ol><p>authorization 授权 authentication 认证</p><p>authentication证明你是你，authorization证明你有这个权限</p><p>简单来说，身份验证是验证您的身份的过程，而授权是验证您有权访问的过程</p><p>参考 <a href="https://www.lagou.com/lgeduarticle/44562.html" target="_blank" rel="noopener">https://www.lagou.com/lgeduarticle/44562.html</a></p><p>客户应用要从资源服务器获取数据，资源服务器会提供API，但是这样的话不安全，所以客户服务器需要提供一个Access Token，资源服务器会校验这个token，来确认这个客户应用是否有访问权限</p><p>那么问题也来了，客户应用的Access Token是怎么来的？这就需要授权服务器了，客户应用去授权服务器上申请Access Token</p><h3 id="涉及到的术语，概念"><a href="#涉及到的术语，概念" class="headerlink" title="涉及到的术语，概念"></a>涉及到的术语，概念</h3><p>复杂体现到术语和概念比较多，首先要理解这些东西，我们直接从代码去理解</p><h3 id="1-资源服务器配置"><a href="#1-资源服务器配置" class="headerlink" title="1. 资源服务器配置"></a>1. 资源服务器配置</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@EnableResourceServer</span>ResourceServerConfigurerAdapter<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通常我们会做上面的配置，使用注解，继承一个类，通过这两步来完成资源服务器的配置，下面一步一步的分析</p><p>@EnableResourceServer引入 OAuth2AuthenticationProcessingFilter 过滤器，import的类ResourceServerConfiguration</p><p><code>主要覆盖方法</code></p><p>public void configure(ResourceServerSecurityConfigurer resources)</p><p>public void configure(HttpSecurity http)</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ResourceServerConfiguration</span> <span class="token keyword">extends</span> <span class="token class-name">WebSecurityConfigurerAdapter</span> <span class="token keyword">implements</span> <span class="token class-name">Ordered</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-授权服务配置"><a href="#2-授权服务配置" class="headerlink" title="2. 授权服务配置"></a>2. 授权服务配置</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@EnableAuthorizationServer</span>AuthorizationServerConfigurerAdapter<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>主要覆盖方法</code></p><p>public void configure(ClientDetailsServiceConfigurer clients)</p><p>public void configure(AuthorizationServerSecurityConfigurer oauthServer)</p><h3 id="3-Security配置"><a href="#3-Security配置" class="headerlink" title="3. Security配置"></a>3. Security配置</h3><p>@EnableWebSecurity<br>WebSecurityConfigurerAdapter</p><p><code>主要覆盖方法</code></p><p>protected void configure(HttpSecurity http)</p><h3 id="refresh-token"><a href="#refresh-token" class="headerlink" title="refresh_token"></a>refresh_token</h3><p>刷新模式，就是获取令牌的接口如果支持刷新模式，那么直接使用refresh_token就可以获取到令牌，该模式就不需要前面的繁琐流程，直接获取到令牌token，前提是你要有refresh_token，并且它没过期</p><p>refresh_token一般是获取access token的时候返回的</p><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>在一个服务上，可以同时实现 资源服务器配置 授权服务配置 Security配置</p><p>一定要理解资源服务器，授权服务器，和security三个配置的职责</p><p><code>资源服务器</code>: 负责控制资源</p><p><code>授权服务器</code>: 发放令牌的</p><p><code>security</code>: 安全校验，比如登录校验，权限校验</p><p>开始用的时候，总感觉有些是重合的，但是其实是各司其职的</p><p>然后根据不同的模式(4种)去做</p><p>授权码模式相对来说比较繁琐，密码模式比较简单</p><p>直接使用cloud的依赖，比较适合cloud的项目</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--oauth2依赖--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-oauth2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--security依赖--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-security<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis 配置使用总结</title>
      <link href="/2019/07/25/Java/mybatis/"/>
      <url>/2019/07/25/Java/mybatis/</url>
      
        <content type="html"><![CDATA[<p>mybatis 学习笔记和基础概念，在spring boot中的使用配置总结</p><a id="more"></a><h2 id="JDBC-配置参数"><a href="#JDBC-配置参数" class="headerlink" title="JDBC 配置参数"></a>JDBC 配置参数</h2><p>官方地址 <a href="https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-reference-configuration-properties.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-reference-configuration-properties.html</a></p><p>发现很多人都是抄一样的，有很多参数配置了是不对或者无效的，上面是官方参数说明地址，很详细，全文搜索一下你就知道各个参数的作用了</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>总共有两种使用方式：1. 无配置文件注解版，这种模式就不需要XML文件了；2. 使用传统的XML文件</p><p>2 类型的使用流程总结</p><p>流程：</p><ol><li><p>添加依赖</p></li><li><p>配置spring boot</p><p> 整体概述：<br> 配entity，是一个包，包含实体类<br> 配mapper，映射文件<br> mybatis设置，例如map-underscore-to-camel-case-repository 开启驼峰功能，实体类的驼峰字段和数据的下划线风格做映射 （不过一般自己定义resultMap来处理）<br> src：要有一个实体类，一个DAO接口类(mapper类) -&gt; 由XML做映射</p></li></ol><p>Spring Boot 会自动加载 spring.datasource.* 相关配置，数据源就会自动注入到 sqlSessionFactory 中，sqlSessionFactory 会自动注入到 Mapper 中。<br>在启动类中添加对 mapper 包扫描 <code>@MapperScan</code>，指定mapper类</p><p>@MapperScan 和 @Mapper，@Mapper注解表明这个类是一个映射类，要对应到xml中，生成一个实体类，这样每个映射类都要加@Mapper，所以一般用@MapperScan指明扫描路径<br>省去了@Mapper注解</p><p>spring boot配置文件</p><pre class="line-numbers language-s"><code class="language-s">mybatis:  mapper-locations: classpath:/mybatis/mapper/*.xml  config-location:  classpath:/mybatis/config/mybatis-config.xml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>配置包括，mapper映射文件，和mybatis配置文件，配置文件是和数据库相关的。这里都是xml相关，mapper映射文件，映射会有多个，映射是接口类的装配，在映射文件中，必须<code>&lt;mapper namespace="com.yukong.chapter5.repository.UserMapper"&gt;</code>的形式指明接口类是哪一个。</p><p>在mybatis的xml配置文件中</p><pre class="line-numbers language-s"><code class="language-s"><typeAliases>    <package name="com.yukong.chapter4.entity"/></typeAliases><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个指明了实体类的包路径，这样在映射xml中就不用写全名了。mybatis配置文件不是必须的，不显示的指定配置参数，那就使用默认的。</p><p>接下来就是src源文件了，包括entity实体类(或者取名为model)包，和mapper接口类包，实体类描述了表的字段，接口类方法描述了对表的操作CURD，具体的操作实现由xml映射文件来实现。</p><p>至此，整个配置流程就完成了，需要手动创建数据库，然后就可以使用了。</p><p>操作实例：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserMapper userMapper<span class="token punctuation">;</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"zzzz"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"bbbb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user<span class="token punctuation">.</span><span class="token function">setSex</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Assert<span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> userMapper<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过注解自动装配userMapper，然后给实体类实例赋值，调用userMapper的save方法保存数据</p><h2 id="xml传递参数"><a href="#xml传递参数" class="headerlink" title="xml传递参数"></a>xml传递参数</h2><p>接口的实现由xml来编写，接口传递参数可以由xml接收到，xml中用 <code>#{}</code> 的形式引用参数</p><ol><li>单一参数</li></ol><pre><code>接口定义参数 String id在 xml 中where ID = #{id,jdbcType=VARCHAR}接口定义参数是对象 Object User在 xml 中values (#{id,jdbcType=VARCHAR}, #{name,jdbcType=VARCHAR}, #{code,jdbcType=VARCHAR})直接访问对象的属性就行了，对象要是一个Bean</code></pre><p>要指明parameterType，即参数类型，有些资料又说不需要，可能和版本有关</p><h2 id="xml标签"><a href="#xml标签" class="headerlink" title="xml标签"></a>xml标签</h2><ol><li>select</li></ol><p>select – 书写查询sql语句<br>select中的几个属性说明：<br>id属性：当前名称空间下的statement的唯一标识。必须。要求id和mapper接口中的方法的名字一致。<br>resultType：将结果集映射为java的对象类型(记得用完整路径该对象)。必须（和 resultMap 二选一）<br>parameterType：传入参数类型。可以省略</p><ol start="2"><li>resultMap</li></ol><p>MyBatis中在查询进行select映射的时候，返回类型可以用resultType，也可以用resultMap，<br>resultType是直接表示返回类型的，而resultMap则是对外部ResultMap的引用，但是resultType跟resultMap不能同时存在</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UserWithRoleMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.zoctan.api.model.User<span class="token punctuation">"</span></span> <span class="token attr-name">extends</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UserMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>role_id<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>BIGINT<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>roleId<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>role_name<span class="token punctuation">"</span></span> <span class="token attr-name">jdbcType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>VARCHAR<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>roleName<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>resultMap 通过extends继承另一个resultMap</p><h2 id="相关注解"><a href="#相关注解" class="headerlink" title="相关注解"></a>相关注解</h2><p>注解多为使用纯Java代码映射的形式，做法也很简单</p><ol><li>定义实体类</li><li>写接口，接口要有注解，方法也要有注解，这样就ok了<br>参考: <a href="https://blog.csdn.net/qq_33238935/article/details/85336429" target="_blank" rel="noopener">https://blog.csdn.net/qq_33238935/article/details/85336429</a></li></ol><h2 id="mybatis扩展"><a href="#mybatis扩展" class="headerlink" title="mybatis扩展"></a>mybatis扩展</h2><p>mybatis是在国内非常通用的MySQL，有很多延伸扩展</p><h3 id="mybatis-generator"><a href="#mybatis-generator" class="headerlink" title="mybatis-generator"></a>mybatis-generator</h3><p>简称MBG，是mybatis的逆向工程，由数据库表创建相关代码</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode 配置</title>
      <link href="/2019/07/15/blog/vscode-config/"/>
      <url>/2019/07/15/blog/vscode-config/</url>
      
        <content type="html"><![CDATA[<p>vscode 配置</p><a id="more"></a><h2 id="使用新窗口打开文件"><a href="#使用新窗口打开文件" class="headerlink" title="使用新窗口打开文件"></a>使用新窗口打开文件</h2><p>VSCode 有一个默认设定，单击一个右侧侧边栏的文件是预览模式，如果不输入任何任何文本就始终保持预览模式。<br>预览模式是的打开一个新文件，然后再打开一个新文件，第二个就会占用第一个窗口。详细信息可以查看：<a href="https://code.visualstudio.com/docs/getstarted/userinterface#_preview-mode" target="_blank" rel="noopener">https://code.visualstudio.com/docs/getstarted/userinterface#_preview-mode</a><br>文件处于预览模式有个标识，就是标题栏的文件名称是斜体的，<br>如何关闭？</p><p>打开设置面板:<br>Code→首选项(Preferences)→设置(settings)<br>在搜索框中输入“enablePreview”</p><p>把对应的选项取消即可</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Technology技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Technology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rage Your Dream</title>
      <link href="/2019/07/14/blog/rage-your-dream/"/>
      <url>/2019/07/14/blog/rage-your-dream/</url>
      
        <content type="html"><![CDATA[<p>Rage Your Dream 项目开发笔记</p><a id="more"></a><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li>初步实现</li><li>风格确定</li><li>代码审查</li></ol><h2 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h2><ul><li>Vue.prototype</li></ul><p>当你在main.js里声明了Vue.prototype.a = 1后，因为你的每一个vue组件都是一个Vue对象的实例，所以即使你没有在组件内部使用data(){return{……}}声明a，你依然可以在组件中通过this.a来访问。<br>当然，你也可以在组件中添加一个变量a，这时你访问的就是你在组件中添加的a，而不再是之前在原型中添加的a了，当然你对组件的a继续修改即不会影响原型中的a和其他组建中的a，就类似于下面这段代码（Form是一个自定义对象类型，Vue也可以看作一个自定义对象类型，而每个.vue文件就是一个对象的实例）</p><p>kafaka、keeplive、docker、influxdb、zookeerper，hive、kfka、storm、promethues、pinpoint、grafana、elk、hdfs、kibana、nexus、harbor、grafana、ambari、cerebro、otter、Weave Scope</p><ul><li>mock请求</li></ul><p>mock的请求不会在浏览器被记录的，它是一种js代码控制的行为，当然不知道是不是有其它办法，总之用了mock需要调试的话，使用console<br>mock的初始化要先，保证被mock记录的URL都能被拦截到</p><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><ol><li>关于集成通用tk.mybatis</li></ol><p>旧版本是不会在控制台有告警的，但是无法解析驼峰命名字段，使用注解也不行，升级了新版本后，字段解析正常，控制台会有告警<br>依赖的使用也有争议</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--mapper--></span><span class="token comment" spellcheck="true">&lt;!-- https://mvnrepository.com/artifact/tk.mybatis/mapper --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>tk.mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mapper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.1.5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- https://mvnrepository.com/artifact/tk.mybatis/mapper-spring-boot-starter --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>tk.mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mapper-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1.5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有关该问题的描述记录，在readme文件中查找</p><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><p>注释：</p><pre><code>&lt;!-- 用户管理视图@author vanliuzhi@create 2019-08-15--&gt;</code></pre><pre><code>/** * @description 系统管理，用户管理API * @author vanliuzhi * @create 2019-08-15 */</code></pre><p>数据：<br>接口数据走json，格式如下，后端也统一成该风格，数据封装在result中</p><pre><code>code: 0message: ""result: {}timestamp: 1565707913336</code></pre><h2 id="vue-cli3-0"><a href="#vue-cli3-0" class="headerlink" title="vue-cli3.0"></a>vue-cli3.0</h2><p>全新的脚手架</p><h3 id="vue-cli3-0-环境变量与模式"><a href="#vue-cli3-0-环境变量与模式" class="headerlink" title="vue-cli3.0 环境变量与模式"></a>vue-cli3.0 环境变量与模式</h3><p>vue-cli3.0移除了配置文件目录：config和build文件夹(最外层已经没有这两个文件夹了)</p><p>总共提供了四种方式来制定环境变量：</p><ol><li>在根目录添加.env文件，配置所有情况下都会用到的配置（不知道这个存在的意义，所有的都需要的也就不需要配置了吧）。</li><li>在根目录添加.env.local 文件，配置所有情况下都会用到的配置，与.env的区别是只会在本地，该文件不会被git跟踪。</li><li>在根目录添加.env.[mode] 文件，配置对应某个模式下的配置,比如：.env.development来配置开发环境的配置。</li><li>在根目录添加.env.[mode].local文件，配置对应某个模式下的配置,与.env.[mode]的区别也只是会在本地生效，该文件不会被git跟踪。</li></ol><p>修改环境变量后，记得手动重启，让环境变量重新写入系统上下文</p><h2 id="layouts布局组件"><a href="#layouts布局组件" class="headerlink" title="layouts布局组件"></a>layouts布局组件</h2><p>根目录layouts文件下存放了所有布局组件，路由可以配置使用的组件，所以一些页面默认是带了布局的</p><ul><li>UserLayout</li></ul><p>该组件用于<code>'/user'</code>路由下，即登录注册等</p><h2 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h2><p>暂时使用sql文件的方式，对表的改动都基于sql文件</p><h2 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h2><p>程序主入口，一般会导入各种配置文件，前端的路由和后端的接口URL不是一个概念，路由的URL跳转不会去和后端交互</p><h3 id="permission"><a href="#permission" class="headerlink" title="permission"></a>permission</h3><p>权限控制部分，通过路由守卫来完成，根据有无token来决定下一步。目前绝大部分项目的思路都很类似，比较的工程化，最好也参照这个流程来</p><ol><li>有</li></ol><p>如果<code>to.path</code>是登录页面，一般跳转到首页去，否则，获取用户信息等操作</p><ol start="2"><li>无</li></ol><p>白名单直接登录，否则跳转到登录页面，登录页面表单接受用户名和密码，调用<code>store</code>中<code>user</code>的<code>actions</code>中的<code>Login</code>，在Login中去请求真正的登录接口</p><h2 id="table组件"><a href="#table组件" class="headerlink" title="table组件"></a>table组件</h2><p>table组件使用总结</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a-table</span> <span class="token attr-name">:columns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>columns<span class="token punctuation">"</span></span> <span class="token attr-name">:dataSource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>data<span class="token punctuation">"</span></span> <span class="token attr-name">:rowKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>record <span class="token punctuation">=</span><span class="token punctuation">></span> record.id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a-table</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>columns配置列表数据，dataSource为数据源<br>需要配置唯一key，columns和dataSource都需要，columns 配置dataIndex或key，数据源最好包含一个唯一值，在<code>:rowKey="record =&gt; record.id</code>指定</p></li><li><p>columns中的customRender属性，<code>Function(text, record, index)</code> 参数分别为当前行的值，当前行数据，行索引，可以用这个对数据做复杂处理，比如把整形状态值变成文本值<br>JSX语法：可以在customRender中使用JSX语法返回HTML，这样就不需要用scopedSlots在标签中写代码了</p></li><li><p>插槽：并不是很理解(语言本身理解的还不够深入)，不过2.6要废弃这个属性了，说明一下用法（大概的总结就是下面的内容，可以自行测试）<br>slots: { title: ‘customTitle’ } 这个是用法是<code>&lt;span slot="customTitle"&gt;&lt;a-icon type="smile-o" /&gt; Name&lt;/span&gt;</code>，title是表格的属性，指明表头名称的，通过插槽可以自定义这个名称，这里自定义就是加了一个icon (总结就是可以自定义一下表格本身的属性，目前已知可以修改标题，还可以filterIcon，自定义 fiter 图标)<br>scopedSlots: { customRender: ‘name’ } 一般就这么定义，name就是当前的字段，上面的customTitle是自定义的，然后<code>&lt;span slot="name" slot-scope="text, record"&gt;</code>或<code>&lt;span slot="name" slot-scope="name"&gt;</code>，这里的参数对应上面customRender属性，只用一个参数，比如这里的<code>name</code>就是当前字段的值 (总结就是可以获取到当前字段和行，索引的数据，方便自定义字段的渲染)</p></li></ul><p>这里的两个属性都是对象的形式，如果要自定义字段，首先就是要知道插槽到底是指向哪一个字段，slots是可以不用配置的，默认名称就是当前字段名，然后配置scopedSlots: { customRender: ‘name’ }，<code>&lt;span slot="name" slot-scope="text"&gt;{{text}}&lt;/span&gt;</code>，slot-scope才会生效</p><ul><li><p>关于表格的对齐，有标题和内容，测试发现对齐属性配置在columns中，对标题和内容都生效，可以全局定义css来覆盖，需要的地方再使用属性来配置</p></li><li><p>分页，框架默认前端分页，分页可以通过配置来自定义，不过这个配置文档描述相当不友好，这个分页依赖组件，个人认为最好的形式是禁用table的分页，自己使用分页组件<br>总之这一块设计的很不好，应为你用table默认的分页，就要去配置属性，然而配置属性的文档是模糊的，比如onShowSizeChange才是table配置中的每页数目改变的事件回调，而组件中确是showSizeChange，这些不确定的配置导致很多问题，下面是一个配置用例，注意onShowSizeChange，其它属性可参考分页组件(猜错这可能是遗留的BUG)，个人猜测defaultCurrent是组件需要读取的，但是用pageNo也可以，这里新加了两个属性，方便读取数据的时候知道当前页数和条目</p></li></ul><p>总结：存在bug肯定是逃不掉的了，或者说是泛用性很强，但是onShowSizeChange是你看文档看不出来的，ant-vue-pro框架也提供了封装的方法，不过不是所有的数据请求加载都是在页面这一环的，我想更自由一点，只能自己梳理文档</p><pre class="line-numbers language-js"><code class="language-js">pagination<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// defaultCurrent: 1, // 默认的当前页数</span>    <span class="token comment" spellcheck="true">// defaultPageSize: 10, // 默认每页显示数量</span>    pageNo<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    pageSize<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span>    showSizeChanger<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 显示可改变每页数量</span>    showQuickJumper<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 显示页数跳转</span>    pageSizeOptions<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'10'</span><span class="token punctuation">,</span> <span class="token string">'20'</span><span class="token punctuation">,</span> <span class="token string">'30'</span><span class="token punctuation">,</span> <span class="token string">'50'</span><span class="token punctuation">,</span> <span class="token string">'100'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 每页数量选项</span>    showTotal<span class="token punctuation">:</span> total <span class="token operator">=</span><span class="token operator">></span> <span class="token template-string"><span class="token string">`共 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>total<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 条数据`</span></span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 显示总数</span>    onShowSizeChange<span class="token punctuation">:</span> <span class="token punctuation">(</span>current<span class="token punctuation">,</span> pageSize<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// console.log(current) // current 当前页</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pagination<span class="token punctuation">.</span>pageSize <span class="token operator">=</span> pageSize        <span class="token keyword">this</span><span class="token punctuation">.</span>pagination<span class="token punctuation">.</span>pageNo <span class="token operator">=</span> current        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getTableData</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> pageSize<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 改变每页数量时更新显示，并请求接口</span>    onChange<span class="token punctuation">:</span> <span class="token punctuation">(</span>page<span class="token punctuation">,</span> pageSize<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pagination<span class="token punctuation">.</span>pageSize <span class="token operator">=</span> pageSize        <span class="token keyword">this</span><span class="token punctuation">.</span>pagination<span class="token punctuation">.</span>pageNo <span class="token operator">=</span> page        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getTableData</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> pageSize<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 点击页码事件</span>    total<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token comment" spellcheck="true">// 总条数</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>后端返回分页数据格式</p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">{</span>    data<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    pageNo<span class="token punctuation">:</span> <span class="token number">3</span>    pageSize<span class="token punctuation">:</span> <span class="token number">10</span>    totalCount<span class="token punctuation">:</span> <span class="token number">23</span>    totalPage<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="form-表单组件"><a href="#form-表单组件" class="headerlink" title="form 表单组件"></a>form 表单组件</h2><p>表单组件有其独特的用法，不再是单纯的双向绑定，自己提交参数的形式，使用form-create后，可以自动的收集和校验数据，不使用此方式就用传统的双向绑定<br>双向绑定的方式就是常规的用法了，使用新的模式可以使用框架提供的API，建议用此模式</p><p>可能会遇到的错误<code>Warning: You cannot set a form field before rendering a field associated with the value.</code>，出现这种情况一般是dom还没渲染，或者是字段没注册，没被组件接管不能用API</p><ul><li>数据赋值</li></ul><h2 id="后端技术栈"><a href="#后端技术栈" class="headerlink" title="后端技术栈"></a>后端技术栈</h2><p>grafana  可视化监控界面</p><p>OpenResty Nginx配合lua的高性能web服务器</p><p>elasticsearch-head  是用于监控 Elasticsearch 状态的客户端插件，使用node运行</p><p>kafka </p><p>zookeeper</p><p>logstash</p><p>filebeat</p><p>elasticsearch</p><p>Redis-Desktop-Manager</p><p>redis</p><p>ZooInspector zk数据查看工具</p><h2 id="后端框架版本"><a href="#后端框架版本" class="headerlink" title="后端框架版本"></a>后端框架版本</h2><p>spring boot 2.1.12.RELEASE</p><p>spring cloud Greenwich.SR5</p><h2 id="微服务带来的挑战"><a href="#微服务带来的挑战" class="headerlink" title="微服务带来的挑战"></a>微服务带来的挑战</h2><p>服务部署的挑战<br>服务伸缩的挑战<br>服务高可用<br>服务容错<br>依赖关系<br>服务监控</p><h2 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h2><p>DevOps（Development和Operations的组合词）是一组过程、方法与系统的统称，用于促进开发（应用程序/软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合。</p><h2 id="权限设计"><a href="#权限设计" class="headerlink" title="权限设计"></a>权限设计</h2><p>RBAC设计思想</p><p>基于角色的访问控制（Role-Based Access Control）<br>有两种正在实践中使用的RBAC访问控制方式：隐式(模糊)的方式和显示(明确)的方式。</p><p>隐式：假如用于属于管理员，在对账户操作的时候，就去判断用于是否是管理员角色，因为在常规的认知中，管理员一般都是能操作账号的，但是实际是否分配的这样的权限是未知的，这就是隐式的，是一种假设。<br>显示：就是明确的权限判断</p><h3 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h3><ol><li>用户管理<ul><li>新建用户</li><li>分配角色</li><li>删除用户</li><li>获取用户列表</li></ul></li><li>角色管理<ul><li>新建角色</li><li>分配权限</li><li>获取角色列表</li></ul></li><li>权限管理<ul><li>新建权限 （把权限完全最小粒度化，只有权限名，不做更多的关联，通过更为详细的权限命名来扩展）</li><li>获取权限列表</li><li>删除权限</li></ul></li></ol><h3 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h3><ol><li>user 用户表</li><li>role 角色表</li><li>permission 权限表</li><li>user_role 用户和角色关联表</li><li>role_permission 角色和权限关联表</li></ol><h2 id="数据库与ORM"><a href="#数据库与ORM" class="headerlink" title="数据库与ORM"></a>数据库与ORM</h2><p><code>主要分析，数据配置，与orm框架结合，连接池，多数据源配置等如何使用</code></p><h3 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h3><p>数据库ORM使用mybatis，通常情况，引入mybatis的spring boot风格的依赖，还有MySQL connect依赖就会自动装配，相关bean就会注入容器，此时如果不配置MySQL，是会有错误日志的</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--mybatis Spring boot 支持--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis.spring.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数据源配置比较简单，这里使用默认的连接池配置</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">datasource</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//$<span class="token punctuation">{</span>MYSQL_HOST<span class="token punctuation">:</span>localhost<span class="token punctuation">}</span><span class="token punctuation">:</span>$<span class="token punctuation">{</span>MYSQL_PORT<span class="token punctuation">:</span><span class="token number">5506</span><span class="token punctuation">}</span>/$<span class="token punctuation">{</span>DB_AUTH<span class="token punctuation">:</span>rrd_store<span class="token punctuation">}</span><span class="token punctuation">?</span>useUnicode=true<span class="token important">&amp;allowMultiQueries</span>=true<span class="token important">&amp;serverTimezone</span>=Asia/Shanghai<span class="token important">&amp;characterEncoding</span>=UTF<span class="token punctuation">-</span>8<span class="token important">&amp;zeroDateTimeBehavior</span>=convertToNull<span class="token important">&amp;useSSL</span>=false    <span class="token key atrule">username</span><span class="token punctuation">:</span> $<span class="token punctuation">{</span>MYSQL_USERNAME<span class="token punctuation">:</span>root<span class="token punctuation">}</span>    <span class="token key atrule">password</span><span class="token punctuation">:</span> $<span class="token punctuation">{</span>MYSQL_PASSWORD<span class="token punctuation">:</span>root123<span class="token punctuation">}</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> com.zaxxer.hikari.HikariDataSource    <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.mysql.jdbc.Driver<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>当然这样用的太基础了，实际还要加上分页插件，连接池等配置，还有数据库性能监控，或者使用mybatis-plus增强功能</p><p>Springboot默认的连接池Hikari，实际情况，会考虑使用Druid</p><p>依赖</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>druid-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.1.10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有一种依赖是这个，使用这种的话要自己创建配置类，所以还是用spring-boot风格的吧，就是上面一种</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>druid<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.1.3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">datasource</span><span class="token punctuation">:</span>    <span class="token key atrule">druid</span><span class="token punctuation">:</span>      <span class="token key atrule">initial-size</span><span class="token punctuation">:</span> <span class="token number">5</span>      <span class="token key atrule">min-idle</span><span class="token punctuation">:</span> <span class="token number">5</span>      <span class="token key atrule">max-active</span><span class="token punctuation">:</span> <span class="token number">20</span>      <span class="token comment" spellcheck="true"># 省略...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也就是把参数写在druid下面，对于type的配置，可以不写，引入依赖就用Druid，具体需要源码验证，不放心就显示配置</p><p>druid自带了监控页面，以及防止sql注入配置，多数据源配置，具体看文档</p><p>druid监控页面 去广告<a href="https://blog.csdn.net/chouya3495/article/details/100661794" target="_blank" rel="noopener">https://blog.csdn.net/chouya3495/article/details/100661794</a></p><h3 id="mybatis-plus"><a href="#mybatis-plus" class="headerlink" title="mybatis-plus"></a>mybatis-plus</h3><p>把依赖替换，注意mybatis-plus的配置名称和mybatis不同，但是配置的内容大同小异</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.baomidou<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-plus-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.0.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.baomidou<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-plus<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.0.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.baomidou<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-plus-generator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.0.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多数据"><a href="#多数据" class="headerlink" title="多数据"></a>多数据</h3><p>多数据源指的是使用多个数据库</p><p>不知道你有没有注意到一点，假设我的数据源配置是 jdbc:mysql://127.0.0.1:9906/rrd_store<br>我在mybatis中是 from <code>honor-user-center</code>.sys_user，能正常访问到数据库</p><p>rrd_store 和 honor-user-center 都是 9906连接下的两个数据库，也就是说连接上后，是可以去访问不同的数据库的</p><p>但是假如我有多个连接，比较9906，7706，做读写分离，那么上面的小技巧就没用了，这种情况就是多数据源，需要我们去连接不同地址的数据库</p><p>具体做法大致有2种，涉及到很多底层的东西，先知道一个概念，就是数据源对象</p><ol><li><p>配置多个连接对象，每个连接对象都是不同的配置，直接和mybatis映射绑定</p></li><li><p>配置一个连接对象，但是里面有多个数据源对象，通过注解切换数据源对象</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Technology技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Technology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用阿里云容器镜像服务</title>
      <link href="/2019/05/01/Docker/aliyun-store/"/>
      <url>/2019/05/01/Docker/aliyun-store/</url>
      
        <content type="html"><![CDATA[<p>Kubernetes(k8s)搭建的时候，需要翻墙，一般像几十块这种VPN开了小飞机也是没有用的，可以使用阿里云提供的容器镜像服务，速度快，还可以不用翻墙</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>阿里容器镜像服务提供了类似官方镜像管理的功能，想当初我也是死活提交不了镜像到官方仓库，国内用阿里云的会好很多。通过构建文件，定义构建规则，可以实现自动构建</p><ol><li>创建Dockerfile文件仓库，可以使用阿里的代码仓库或GitHub</li><li>创建一个命名空间，最好是公有的，如果是私有的，在拉取镜像的时候需要登录，然后以这个命名空间创建镜像仓库，并和Dockerfile文件仓库绑定</li><li>克隆仓库到本地，编辑Dockerfile文件，就是常规的指定镜像，由于使用阿里的机器，这里写Google的地址也可以，目的也是为了这个</li><li>对本次提交打个标签，根据构建规则会自动构建，这个规则也可以自定义，查看如果构建成功就可以拉取了</li></ol><p>注意事项：</p><ol><li>命名空间最好是公有的，私有的拉取的时候需要登录</li><li>拉取镜像后，重命名成官方镜像名称，这样就相当于本地有了官方镜像，k8s运行相关服务的时候就不会再去官网拉取了</li><li>流程很简单，阿里容器镜像服务都提供了详细说明</li><li>由于k8s需要的镜像比较多，目前我搜集的资料来看，每一个镜像都需要执行上面的步骤，即为每一个需要的镜像去创建对应的阿里云仓库，有把相关Dockerfile整合的Git项目，可以使用这一的项目，然后自定义构建规则，设置Dockerfile文件目录（不要创建多个构建规则，然后执行不同的镜像，当前的阿里仓库只会以最后构建的镜像为准，综上所诉，一个镜像创建一个阿里仓库应该是没跑了）</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 开发环境 shell 配置</title>
      <link href="/2019/04/13/Linux/shell/"/>
      <url>/2019/04/13/Linux/shell/</url>
      
        <content type="html"><![CDATA[<p>shell 配置和使用 zsh</p><a id="more"></a><h2 id="Xshell"><a href="#Xshell" class="headerlink" title="Xshell"></a>Xshell</h2><p>在使用Xshell的时候，出现本地终端排版错误问题，解决方案：文件 - 属性 - 终端 - 高级 - 用CR-LF接受LF(R)</p><h2 id="安装-zsh"><a href="#安装-zsh" class="headerlink" title="安装 zsh"></a>安装 zsh</h2><p>通过命令就可以安装了</p><p>CentOS 安装：sudo yum install -y zsh<br>Ubuntu 安装：sudo apt-get install -y zsh<br>在检查下系统的 shell：cat /etc/shells，你会发现多了一个：/bin/zsh</p><p>安装完成zsh后，再安装oh-my-zsh会自动切换过去，echo $SHELL 可以查看当前shell，如果shell已经切换了，再执行切换命令是不行的</p><h2 id="安装-oh-my-zsh"><a href="#安装-oh-my-zsh" class="headerlink" title="安装 oh-my-zsh"></a>安装 oh-my-zsh</h2><p>oh-my-zsh 是 zsh 扩展的集合，有了扩展集合包，通过配置zsh文件就能很方便的开启功能<br>当然有时候不管用，可能因为扩展包版本的问题，或是相关插件没在扩展包里面，这个时候手动下载插件即可</p><p><code>sh -c "$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)"</code></p><blockquote><p>最好还是使用官方的安装，遇到用别人的，安装后插件无法识别，我也是奇怪了就是用GitHub的脚本，差距有点大</p></blockquote><p>常用插件：</p><p>插件安装，有默认自带的(.oh-my-zsh/plugins)，和通过安装的(.oh-my-zsh/custom/plugins)，两个路径会不一样，在配置文件 .zshrc 中有描述，记得看看</p><p>如果是自带就有的，通过修改plugins=(git docker) 这样的形势就可以增加插件，修改后执行 source .zshrc让插件生效，自带没有的（就是自带目录找不到，可以去下载它，然后放到安装目录，这样方便管理自带和下载的，同样修改plugins，然后执行生效），下面给出了常用的两个通过下载安装的插件</p><ol><li>zsh-syntax-highlighting 语法高亮，能提示错误的语法</li></ol><p>在配置插件了加入 zsh-syntax-highlighting，如果不管用，可能就是扩展包没有这个插件，通过手动下载即可。</p><pre><code>git clone https://github.com/zsh-users/zsh-syntax-highlighting.git echo "source ${(q-)PWD}/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh" &gt;&gt; ${ZDOTDIR:-$HOME}/.zshrc</code></pre><p>or</p><p>git clone git://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting.git</p><p>生效 <code>source ~/.zshrc</code></p><p>就是下载插件，并加入当前用户的环境变量中</p><ol start="2"><li>自动补全插件</li></ol><ul><li><p>zsh-autosuggestions<br><code>git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</code><br>or<br><code>git clone git://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions</code><br><code>plugins=(git zsh-autosuggestions)</code></p></li><li><p>incr</p><pre><code>下载 http://mimosa-pudica.net/src/incr-0.2.zsh复制插件到扩展包插件目录 .oh-my-zsh/plugins/创建incr文件夹放到该文件夹中当前用户环境变量添加 source ~/.oh-my-zsh/plugins/incr/incr*.zsh</code></pre></li></ul><p>上面的命令一气呵成，可能不同的环境，移动文件会不对，提前检查一下</p><h2 id="配置vim"><a href="#配置vim" class="headerlink" title="配置vim"></a>配置vim</h2><p>下载好vim后，通常还需要进行配置，只是想行号显示这种功能我认为是必须的，不然系统报错了告诉你行号你都不知道是哪行。</p><p>另外有些系统带了vim，是vi命令启动的，应该是阉割版本，所以还是再重新装一个。</p><p>vim配置文件分为系统和用户的，系统修改就是全局的了，所以好的习肯定是修改自己用户的，如果你不知道配置文件在什么地方，打开vim，输入<code>:version</code> 即可查看相关信息。</p><pre><code>cd ~ touch .vimrc</code></pre><p>Mac 上的配置文件，比较简单的配置</p><pre><code>" Configuration file for vimset modelines=0        " CVE-2007-2438" Normally we use vim-extensions. If you want true vi-compatibility" remove change the following statementsset nocompatible    " Use Vim defaults instead of 100% vi compatibilityset backspace=2        " more powerful backspacing" Don't write backup file if vim is being called by "crontab -e"au BufWrite /private/tmp/crontab.* set nowritebackup nobackup" Don't write backup file if vim is being called by "chpass"au BufWrite /private/etc/pw.* set nowritebackup nobackuplet skip_defaults_vim=1syntax onset nu!set autoindent</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes 笔记</title>
      <link href="/2019/04/05/Docker/k8s/"/>
      <url>/2019/04/05/Docker/k8s/</url>
      
        <content type="html"><![CDATA[<p>Kubernetes 笔记</p><a id="more"></a><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>各个服务架构一句话总结: Kubernetes是由容器和进程互相配合实现的</p><p>这句话的意思是，部分操作，比如apiserver，scheduler是由容器来完成的，而像Kubelet是一个进程。Kubelet 实现了集群中最重要的关于 Node 和 Pod 的控制功能</p><p>(不负责任的猜想，可能出于架构的设计，Kubelet并不是由容器提供的)</p><p>协议规范:</p><p>CNI( Container Network Interface)<br>CSI（Container Storage Interface）<br>CRI（Container Runtime Interface）</p><p>etcd: 是一个高可用的分布式键值(key-value)数据库。etcd内部采用raft协议作为一致性算法，有点像zk，k8s集群使用etcd作为它的数据后端，etcd是一种无状态的分布式数据存储集群。数据以key-value的形式存储在其中</p><p>swap: 在k8s中最好禁用swap，以免发生集群无法调度问题</p><p>flannel: 用来通信的网络插件。要符号CNI规范</p><h2 id="k8s-用的的镜像示例"><a href="#k8s-用的的镜像示例" class="headerlink" title="k8s 用的的镜像示例"></a>k8s 用的的镜像示例</h2><p>master节点</p><table><thead><tr><th>Command</th><th align="center">Description</th></tr></thead><tbody><tr><td>REPOSITORY</td><td align="center">TAGIMAGEIDCREATEDSIZE</td></tr><tr><td>registry.aliyuncs.com/google_containers/kube-proxy</td><td align="center">v1.14.120a2d703516510monthsago82.1MB</td></tr><tr><td>registry.aliyuncs.com/google_containers/kube-apiserver</td><td align="center">v1.14.1cfaa4ad74c3710monthsago210MB</td></tr><tr><td>registry.aliyuncs.com/google_containers/kube-controller-manager</td><td align="center">v1.14.1efb3887b411d10monthsago158MB</td></tr><tr><td>registry.aliyuncs.com/google_containers/kube-scheduler</td><td align="center">v1.14.18931473d5bdb10monthsago81.6MB</td></tr><tr><td>quay-mirror.qiniu.com/coreos/flannel</td><td align="center">v0.11.0-amd64ff281650a72112monthsago52.6MB</td></tr><tr><td>quay.io/coreos/flannel</td><td align="center">v0.11.0-amd64ff281650a72112monthsago52.6MB</td></tr><tr><td>registry.aliyuncs.com/google_containers/coredns</td><td align="center">1.3.1eb516548c18012monthsago40.3MB</td></tr><tr><td>registry.aliyuncs.com/google_containers/etcd</td><td align="center">3.3.102c4adeb21b4f14monthsago258MB</td></tr><tr><td>registry.aliyuncs.com/google_containers/pause</td><td align="center">3.1da86e6ba6ca12yearsago742kB</td></tr></tbody></table><p>node节点</p><table><thead><tr><th>Command</th><th align="center">Description</th></tr></thead><tbody><tr><td>REPOSITORY</td><td align="center">TAGIMAGEIDCREATEDSIZE</td></tr><tr><td>registry.aliyuncs.com/google_containers/kube-proxy</td><td align="center">v1.14.120a2d703516510monthsago82.1MB</td></tr><tr><td>quay-mirror.qiniu.com/coreos/flannel</td><td align="center">v0.11.0-amd64ff281650a72112monthsago52.6MB</td></tr><tr><td>quay.io/coreos/flannel</td><td align="center">v0.11.0-amd64ff281650a72112monthsago52.6MB</td></tr><tr><td>registry.aliyuncs.com/google_containers/pause</td><td align="center">3.1da86e6ba6ca12yearsago742kB</td></tr></tbody></table><p>除了容器外，还需要kubelet才是完整的</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>kubectl explain node</p><p>kubectl get pods -n kube-system -o wide<br>kubectl get nodes -o wide  </p><p><code>kubectl get node</code> 可以使用 -o 配合 wide json yaml</p><p>配合jq做内容提取</p><p>kubectl get nodes -o json | jq “.items[] | {name: .metadata.name} + .status.nodeInfo”</p><h2 id="与k8s交互"><a href="#与k8s交互" class="headerlink" title="与k8s交互"></a>与k8s交互</h2><p>在 K8S 中进行部署或者说与 K8S 交互的方式主要有三种：</p><p>命令式<br>命令式对象配置<br>声明式对象配置</p><h2 id="镜像拉取策略"><a href="#镜像拉取策略" class="headerlink" title="镜像拉取策略"></a>镜像拉取策略</h2><p>默认值是IfNotPresent(在initContainers中，发现不配置并不会去使用本地的，所以最好显示的配置一下)</p><p>Always<br>总是拉取：<br>首先获取仓库镜像信息，如果仓库中的镜像与本地不同，那么仓库中的镜像会被拉取并覆盖本地。<br>如果仓库中的镜像与本地一致，那么不会拉取镜像。<br>如果仓库不可用，那么pod运行失败。</p><p>IfNotPresent<br>优先使用本地：<br>如果本地存在镜像，则使用本地的，<br>不管仓库是否可用。<br>不管仓库中镜像与本地是否一致。</p><p>Never<br>只使用本地镜像，如果本地不存在，则pod运行失败</p><h2 id="固定node发布"><a href="#固定node发布" class="headerlink" title="固定node发布"></a>固定node发布</h2><p>deploy上用选择器，就可以固定在一个node上</p><h2 id="资源删除"><a href="#资源删除" class="headerlink" title="资源删除"></a>资源删除</h2><p>一般是 delete -f .yaml 删除对应的资源，然后apply再应用，资源生效</p><p>删除pod: 先删除pod，然后再删除deployment。只删除pod，去查看的时候pod还是存在的，再去删除dep，查看pod消失</p><h2 id="service-和-deployment"><a href="#service-和-deployment" class="headerlink" title="service 和 deployment"></a>service 和 deployment</h2><p>deployment 负责创建 pod，只有de存在，pod就会维持住，pod被删除了也会被dev拉起。这样pod的服务是不确定的，它的ip一直在变化</p><p>所以需要service</p><p>Service 是 Kubernetes 中的一种服务发现机制：</p><p>Pod 有自己的 IP 地址<br>Service 被赋予一个唯一的 dns name<br>Service 通过 label selector 选定一组 Pod<br>Service 实现负载均衡，可将请求均衡分发到选定这一组 Pod 中</p><h2 id="标签操作"><a href="#标签操作" class="headerlink" title="标签操作"></a>标签操作</h2><p>kubectl get pods –show-labels　　#查看pod所有标签信息<br>kubectl get pods -l app　　#过滤包含app的标签<br>kubectl get pods -l app    #过滤包含app的标签及显示值<br>kubectl label pods pod-demo release=canary　　#给pod-demo增加标签<br>kubectl label pods pod-demo release=stable –overwrite　　#修改标签</p><p>通过标签来过滤资源</p><p>kubectl get pods -l run=myapp<br>kubectl get pods -l run=myapp –show-labels<br>kubectl get pods -l run!=client –show-labels</p><h2 id="通过标签部署到指定节点"><a href="#通过标签部署到指定节点" class="headerlink" title="通过标签部署到指定节点"></a>通过标签部署到指定节点</h2><p>nodeSelector 写上标签，调度的时候就只会调度到这几个有标签的节点(该特性在官方准备在新版本中去除了)</p><p>nodeName: 指定主机名称，比如 k8s-09</p><p><code>kubernetes.io/hostname=k8s-09</code> 一般节点都会打上这个标签，描述了主机名称信息</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># priorityClassName: system-cluster-critical</span>  <span class="token key atrule">nodeSelector</span><span class="token punctuation">:</span>    <span class="token key atrule">kubernetes.io/hostname</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>worker06<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>资源创建的时候，可以指定命名空间，命名空间内各资源可以互相访问<br>如果pod和service在不同的命名空间，是不能直接访问的，这时候要跨命名空间访问</p><p>使用 服务加命名空间的方式  比如服务 是 oap，那么web-b命名空间想访问web-f命名空间的 oap service，使用<code>oap.web-f</code></p><h2 id="查看pod日志"><a href="#查看pod日志" class="headerlink" title="查看pod日志"></a>查看pod日志</h2><p>使用logs命令，加上pod实例，如果pod里面有多个容器，还要加上容器名称，举例如下：</p><p>kubectl -n kube-system logs alertmanager-54f5b4447b-2jvzz prometheus-alertmanager</p><h2 id="引用pod的信息"><a href="#引用pod的信息" class="headerlink" title="引用pod的信息"></a>引用pod的信息</h2><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">env</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> MY_NODE_NAME      <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>        <span class="token key atrule">fieldRef</span><span class="token punctuation">:</span>          <span class="token key atrule">fieldPath</span><span class="token punctuation">:</span> spec.nodeName    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> MY_POD_NAME      <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>        <span class="token key atrule">fieldRef</span><span class="token punctuation">:</span>          <span class="token key atrule">fieldPath</span><span class="token punctuation">:</span> metadata.name    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> MY_POD_NAMESPACE      <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>        <span class="token key atrule">fieldRef</span><span class="token punctuation">:</span>          <span class="token key atrule">fieldPath</span><span class="token punctuation">:</span> metadata.namespace    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> MY_POD_IP      <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>        <span class="token key atrule">fieldRef</span><span class="token punctuation">:</span>          <span class="token key atrule">fieldPath</span><span class="token punctuation">:</span> status.podIP    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> MY_POD_SERVICE_ACCOUNT      <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>        <span class="token key atrule">fieldRef</span><span class="token punctuation">:</span>          <span class="token key atrule">fieldPath</span><span class="token punctuation">:</span> spec.serviceAccountName<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过环境变量，引用当前pod的container的信息注入到外部</p><p>spec.nodeName ： pod所在节点的IP、宿主主机IP</p><p>status.podIP ：pod IP</p><p>metadata.namespace : pod 所在的namespace</p><p>更多参数：<br><a href="https://kubernetes.io/docs/tasks/inject-data-application/environment-variable-expose-pod-information/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/inject-data-application/environment-variable-expose-pod-information/</a></p><p><a href="https://github.com/kubernetes/kubernetes/issues/24657" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/issues/24657</a></p><h2 id="单个文件的方式挂载-configMap"><a href="#单个文件的方式挂载-configMap" class="headerlink" title="单个文件的方式挂载 configMap"></a>单个文件的方式挂载 configMap</h2><p>主要是用了subPath这个配置，另外记得volumes挂载不要用驼峰命名，可以用横杆加小写</p><p>挂载多个文件</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /skywalking/config/application.yml    <span class="token key atrule">name</span><span class="token punctuation">:</span> config    <span class="token key atrule">subPath</span><span class="token punctuation">:</span> application.yml<span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /skywalking/config/alarm<span class="token punctuation">-</span>settings.yml    <span class="token key atrule">name</span><span class="token punctuation">:</span> alarm<span class="token punctuation">-</span>config    <span class="token key atrule">subPath</span><span class="token punctuation">:</span> alarm<span class="token punctuation">-</span>settings.yml<span class="token key atrule">volumes</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> application<span class="token punctuation">-</span>config  <span class="token key atrule">configMap</span><span class="token punctuation">:</span>    <span class="token key atrule">defaultMode</span><span class="token punctuation">:</span> <span class="token number">420</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> oap<span class="token punctuation">-</span>config    <span class="token key atrule">items</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> application.yml        <span class="token key atrule">path</span><span class="token punctuation">:</span> application.yml<span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> alarm<span class="token punctuation">-</span>config  <span class="token key atrule">configMap</span><span class="token punctuation">:</span>    <span class="token key atrule">defaultMode</span><span class="token punctuation">:</span> <span class="token number">420</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> oap<span class="token punctuation">-</span>config    <span class="token key atrule">items</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> alarm<span class="token punctuation">-</span>settings.yml        <span class="token key atrule">path</span><span class="token punctuation">:</span> alarm<span class="token punctuation">-</span>settings.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="调度策略PriorityClass"><a href="#调度策略PriorityClass" class="headerlink" title="调度策略PriorityClass"></a>调度策略PriorityClass</h2><p>参考：<a href="https://www.ibm.com/support/knowledgecenter/zh/bluemix_stage/containers/cs_pod_priority.html" target="_blank" rel="noopener">https://www.ibm.com/support/knowledgecenter/zh/bluemix_stage/containers/cs_pod_priority.html</a></p><p>除了常用的nodeSelector，k8s还提供了优先级调度，也就是抢占式调度，优先级高的pod会先调度，在资源不足的情况下会牺牲掉低优先级的pod先把高优先级的pod先调度</p><p>具体做法就是在资源定义的时候关联一个PriorityClass对象，这个对象会设置优先级</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> scheduling.k8s.io/v1alpha1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PriorityClass<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> high<span class="token punctuation">-</span>priority<span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token number">1000000</span><span class="token key atrule">globalDefault</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"This priority class should be used for XYZ service pods only."</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>globalDefault    可选：将此字段设置为 true 可将此优先级类设置为全局缺省值，此缺省值将应用于安排的未指定 priorityClassName 值的每个 pod。集群中只能有 1 个优先级类可设置为全局缺省值。如果没有全局缺省值，那么没有指定 priorityClassName 的 pod 的优先级为零 (0)。缺省优先级类不会设置 globalDefault。如果在集群中创建了其他优先级类，那么可以通过运行 kubectl describe priorityclass &lt;name&gt;.</code></pre><p>在containers配置中加上 <code>priorityClassName: high-priority</code></p><p>系统默认的优先级类</p><pre><code>名称    设置方    优先级值    用途system-node-critical    Kubernetes    2000001000    选择在创建集群时部署到 kube-system 名称空间中的 pod 会使用此优先级类来保护工作程序节点的关键功能，例如联网、存储器、日志记录、监视和度量值 pod。system-cluster-critical    Kubernetes    2000000000    选择在创建集群时部署到 kube-system 名称空间中的 pod 会使用此优先级类来保护集群的关键功能，例如联网、存储器、日志记录、监视和度量值 pod。ibm-app-cluster-critical    IBM    900000000    选择在创建集群时部署到 ibm-system 名称空间中的 pod 会使用此优先级类来保护应用程序的关键功能，例如负载均衡器 pod</code></pre><p><code>kubectl get priorityclasses</code><br><code>kubectl get priorityclass &lt;priority_class&gt; -o yaml &gt; Downloads/priorityclass.yaml</code></p><h2 id="Taints与Tolerations-污点和容忍"><a href="#Taints与Tolerations-污点和容忍" class="headerlink" title="Taints与Tolerations 污点和容忍"></a>Taints与Tolerations 污点和容忍</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java IDEA</title>
      <link href="/2019/04/05/Java/IDEA/"/>
      <url>/2019/04/05/Java/IDEA/</url>
      
        <content type="html"><![CDATA[<p>IDEA 使用技巧补充总结</p><a id="more"></a><h2 id="IDEA-工具使用"><a href="#IDEA-工具使用" class="headerlink" title="IDEA 工具使用"></a>IDEA 工具使用</h2><p>ntellig idea 使用@Resource或者@Autowire报错，出现红色波浪线；</p><p>虽然不影响使用，但是看着很不爽，所以还是解决了下：</p><p>报错提示：Could not autowire. No beans of ‘’ type found. less… (Ctrl+F1)  Checks autowiring problems in a bean class.</p><p>解决方法：Settings - Editor - Inspections - Spring - Spring Core - Code - Autowiring for Bean Class 修改成告警级别</p><h2 id="idea-错误提示取消和恢复"><a href="#idea-错误提示取消和恢复" class="headerlink" title="idea 错误提示取消和恢复"></a>idea 错误提示取消和恢复</h2><p>idea提供了很强大的错误提示功能，但是有些不一定是错误的，强迫症患者可能会取消，下图展示 spring yaml配置错误提示 取消和开启的设置的图片</p><p><img src="/images/Java/java-idea-inspections.png" alt="image"></p><h2 id="idea-注释调整"><a href="#idea-注释调整" class="headerlink" title="idea 注释调整"></a>idea 注释调整</h2><p>我们在注释代码的时候，发现注释顶格了，这样的风格特别不好看，可以去editor code style中调整，不用语言用不同配置，找到code generatic，修改comment code配置</p><h2 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h2><p>静态语言不像动态语言，要实现热部署要程序和IDEA配合才行</p><p>引入依赖</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-devtools<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>依赖的作用：</p><p>默认禁用缓存选项。比如模板引擎将缓存编译完的模板，以避免重复解析模板文件。<br>自动重启。只要classpath下的文件有变动，应用就会自动重启。<br>在运行一个完整的、打包过的应用时，开发者工具（devtools）会被自动禁用。<br>如果应用使用 java -jar 或特殊的类加载器启动，都会被认为是一个产品级的应用（production application），从而禁用开发者工具。<br>只要classpath下文件有变动，应用就会重启。一些比如静态assets、视图模板文件等资源 文件的变动，应用不会重启。<br><code>唯一触发重启的方式就是更新classpath</code><br>IDEA本身提供了热部署功能，但是限制性比较大，只能对静态资源的修改、方法内的修改才能进行热更新，<br>对于方法参数或者方法类的修改不能进行热部署，但是像devtools,jrebel 都能够对类的修改进行重新加载。</p><p>总结：</p><p>添加spring-boot-devtools依赖<br>修改classpath下的Java文件，然后更新classpath，这时应用就会自动重启。<br>修改classpath下的页面文件，然后更新classpath，但是访问页面可以看到效果（即重新加载）。<br>IDEA更新classpath的方法：【Build】-&gt;【Build Project】，如果你设置了自动编译，那就可以省略这一步了（可能因为IDEA版本的原因，有需要手动操作）。</p><ol><li>spring-boot-devtools 热部署是对修改的类和配置文件进行重新加载，所以在重新加载的过程中会看到项目启动的过程，其本质上这个时候只是对修改类和配置文件的重新加载，所以速度极快；</li><li>spring-boot-devtools 对于前端使用模板引擎的项目，能够自动禁用缓存，在页面修改后，只需要刷新浏览器器页面即可；</li><li>为什么在 idea 中 spring-boot-devtools 没有热部署？ 因为在Idea 中自动编译默认是停用的，启用路径 build -&gt; compile -&gt; buildProjectAutomatically</li><li>为什么在 idea 中启用自动编译依然没有热部署？ idea监测到项目runninng 或者 debuging 会停用自动编译，所以还需要手动biild [Ctrl + F9] 或者 [ctrl +  b]</li></ol><p>全自动设置方式，打开运行时编译：</p><ol><li>build -&gt; compile -&gt; build Project Automatically 开启自动编制，但是running和debug不能用</li><li>快捷键Ctrl + Shift + Alt + /，选择Registry  让running能自动编译</li><li>勾选 Compiler autoMake allow when app running</li></ol><p>上述情况的热部署，有些时候需要手动点击编译(我在Windows上会自动重启)，推测和idea版本有关系，不过手动控制其实挺好的<br>另外通过上述做的热部署，是会重启(可能依赖比较复杂的情况下会这样，有些时候又不会)，推荐使用插件jrebel，它也是走上面的流程，然后可以只加载需要重新加载的类，效果很好</p><p>spring-boot-devtools依赖 注入的时候，通过idea可以看到服务后面有devtool的标识</p><p>jrebel xrebel 有2个东西，xrebel是分析程序用的，jrebel是热部署</p><p>百度一下安装和激活：两个要分别激活，激活后大都改用离线模式，可以用好几个月</p><p>只为了热部署：百度一下 jrebel 激活，需要一个服务器地址，和一个uuid，这两个组合，加上自己的邮箱就行了</p><h2 id="gradle-编译，只运行所选测试"><a href="#gradle-编译，只运行所选测试" class="headerlink" title="gradle 编译，只运行所选测试"></a>gradle 编译，只运行所选测试</h2><p>Delegate IDE build开启，选择 reun tests using下拉选项</p><h2 id="IDEA-插件"><a href="#IDEA-插件" class="headerlink" title="IDEA 插件"></a>IDEA 插件</h2><p>Lombok plugin<br>GsonFormat<br>FindBugs-IDEA<br>CodeGlance    右侧文档结构图<br>.ignore    git 文件提交过滤<br>Maven Helper maven插件，打开该pom文件的Dependency Analyzer视图</p><h2 id="IDEA-快捷键"><a href="#IDEA-快捷键" class="headerlink" title="IDEA 快捷键"></a>IDEA 快捷键</h2><pre><code>Ctrl+Alt+O 优化导入的类和包 Alt+Insert 生成代码(如get,set方法,构造函数等) 或者右键（Generate） fori/sout/psvm + Tab Ctrl+Alt+T 生成try catch 或者 Alt+enter CTRL+ALT+T 把选中的代码放在 TRY{} IF{} ELSE{} 里 Ctrl + O 重写方法 Ctrl + I 实现方法 Ctr+shift+U 大小写转化 ALT+回车 导入包,自动修正 ALT+/ 代码提示 CTRL+J 自动代码 Ctrl+Shift+J，整合两行为一行 CTRL+空格 代码提示 CTRL+SHIFT+SPACE 自动补全代码 CTRL+ALT+L 格式化代码 CTRL+ALT+I 自动缩进 CTRL+ALT+O 优化导入的类和包 ALT+INSERT 生成代码(如GET,SET方法,构造函数等) CTRL+E 最近更改的代码 CTRL+ALT+SPACE 类名或接口名提示 CTRL+P 方法参数提示 CTRL+Q，可以看到当前方法的声明Shift+F6 重构-重命名 (包、类、方法、变量、甚至注释等) Ctrl+Alt+V 提取变量Ctrl＋Shift＋Backspace可以跳转到上次编辑的地 CTRL+ALT+ left/right 前后导航编辑过的地方 ALT+7 靠左窗口显示当前文件的结构 Ctrl+F12 浮动显示当前文件的结构 ALT+F7 找到你的函数或者变量或者类的所有引用到的地方 CTRL+ALT+F7 找到你的函数或者变量或者类的所有引用到的地方Ctrl+Shift+Alt+N 查找类中的方法或变量 双击SHIFT 在项目的所有目录查找文件 Ctrl+N 查找类 Ctrl+Shift+N 查找文件 CTRL+G 定位行 CTRL+F 在当前窗口查找文本 CTRL+SHIFT+F 在指定窗口查找文本 CTRL+R 在 当前窗口替换文本 CTRL+SHIFT+R 在指定窗口替换文本 ALT+SHIFT+C 查找修改的文件 CTRL+E 最近打开的文件 F3 向下查找关键字出现位置 SHIFT+F3 向上一个关键字出现位置 选中文本，按Alt+F3 ，高亮相同文本，F3逐个往下查找相同文本 F4 查找变量来源CTRL+SHIFT+O 弹出显示查找内容Ctrl+W 选中代码，连续按会有其他效果 F2 或Shift+F2 高亮错误或警告快速定位 Ctrl+Up/Down 光标跳转到第一行或最后一行下Ctrl+B 快速打开光标处的类或方法 CTRL+ALT+B 找所有的子类 CTRL+SHIFT+B 找变量的类Ctrl+Shift+上下键 上下移动代码 Ctrl+Alt+ left/right 返回至上次浏览的位置 Ctrl+X 删除行 Ctrl+D 复制行 Ctrl+/ 或 Ctrl+Shift+/ 注释（// 或者/…/ ）Ctrl+H 显示类结构图 Ctrl+Q 显示注释文档Alt+F1 查找代码所在位置 Alt+1 快速打开或隐藏工程面板Alt+ left/right 切换代码视图 ALT+ ↑/↓ 在方法间快速移动定位 CTRL+ALT+ left/right 前后导航编辑过的地方 Ctrl＋Shift＋Backspace可以跳转到上次编辑的地 Alt+6 查找TODOSHIFT+ENTER 另起一行 CTRL+Z 倒退(撤销) CTRL+SHIFT+Z 向前(取消撤销) CTRL+ALT+F12 资源管理器打开文件夹 ALT+F1 查找文件所在目录位置 SHIFT+ALT+INSERT 竖编辑模式 CTRL+F4 关闭当前窗口 Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义 Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单alt+F8 debug时选中查看值 Alt+Shift+F9，选择 Debug Alt+Shift+F10，选择 Run Ctrl+Shift+F9，编译 Ctrl+Shift+F8，查看断点F7，步入 Shift+F7，智能步入 Alt+Shift+F7，强制步入 F8，步过 Shift+F8，步出 Alt+Shift+F8，强制步过Alt+F9，运行至光标处 Ctrl+Alt+F9，强制运行至光标处 F9，恢复程序 Alt+F10，定位到断点Ctrl+Alt+Shift+T，弹出重构菜单 Shift+F6，重命名 F6，移动 F5，复制 Alt+Delete，安全删除 Ctrl+Alt+N，内联</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ</title>
      <link href="/2019/04/05/Java/RocketMQ/"/>
      <url>/2019/04/05/Java/RocketMQ/</url>
      
        <content type="html"><![CDATA[<p>title: RocketMQ</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>这个安装还是特别容易的，下载对应程序，配置参数，启动，和Tomcat差不多</p><p>遇到的问题:</p><ul><li>网卡绑定错误</li></ul><p>虚拟机测试很容易遇到这个问题，手动设置ip解决</p><p>RocketMQ中broker配置brokcerIP1和brokerIP2的作用<br>brokerIP1 当前broker监听的IP<br>brokerIP2 存在broker主从时，在broker主节点上配置了brokerIP2的话,broker从节点会连接主节点配置的brokerIP2来同步。</p><p>默认不配置brokerIP1和brokerIP2时，都会根据当前网卡选择一个IP使用，当你的机器有多块网卡时，很有可能会有问题</p><pre class="line-numbers language-s"><code class="language-s">brokerIP1=10.10.10.3brokerIP2=10.10.10.3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>Java环境问题</li></ul><p>在runserve.sh文件中，会去判断当前是否有Java环境，然后系统会去设置，由于默认的设置执行的不一定是你自己机器的环境变量，所以需要手动修改</p><ul><li>JVM内存</li></ul><p>默认的内存配置是特别大的，测试可以改小一点</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>1、rocketmq的启动<br>进入rocketMQ解压目录下的bin文件夹<br>启动namesrv服务：nohup sh bin/mqnamesrv &amp;<br>日志目录：{rocketMQ解压目录}/logs/rocketmqlogs/namesrv.log</p><p>启动broker服务：nohup sh bin/mqbroker &amp;<br>日志目录：{rocketMQ解压目录}/logs/rocketmqlogs/broker.log</p><p>以上的启动日志可以在启动目录下的nohub.out中看到</p><p>2、rocketmq服务关闭</p><p>关闭namesrv服务：sh bin/mqshutdown namesrv<br>关闭broker服务 ：sh bin/mqshutdown broker</p><h2 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h2><pre class="line-numbers language-s"><code class="language-s"># 主节点brokerClusterName=rocketmq-clusterbrokerName=broker-abrokerId=0namesrvAddr=rocketmq1:9876defaultTopicQueueNums=4autoCreateTopicEnable=trueautoCreateSubscriptionGroup=truelistenPort=10911deleteWhen=04fileReservedTime=120mapedFileSizeCommitLog=1073741824mapedFileSizeConsumeQueue=300000destroyMapedFileIntervalForcibly=120000redeleteHangedFileInterval=120000diskMaxUsedSpaceRatio=88storePathRootDir=/app/svr/rocketmq/data/storestorePathCommitLog=/app/svr/rocketmq/data/store/commitlogmaxMessageSize=65536flushCommitLogLeastPages=4flushConsumeQueueLeastPages=2flushCommitLogThoroughInterval=10000flushConsumeQueueThoroughInterval=60000checkTransactionMessageEnable=falsesendMessageThreadPoolNums=128pullMessageThreadPoolNums=128brokerRole=SYNC_MASTERflushDiskType=ASYNC_FLUSH# 从节点brokerClusterName=rocketmq-clusterbrokerName=broker-abrokerId=1 namesrvAddr=rocketmq1:9876defaultTopicQueueNums=4autoCreateTopicEnable=trueautoCreateSubscriptionGroup=truelistenPort=10922deleteWhen=04fileReservedTime=120mapedFileSizeCommitLog=1073741824mapedFileSizeConsumeQueue=300000destroyMapedFileIntervalForcibly=120000redeleteHangedFileInterval=120000diskMaxUsedSpaceRatio=88storePathRootDir=/app/svr/rocketmq/data/store2storePathCommitLog=/app/svr/rocketmq/data/store2/commitlogmaxMessageSize=65536flushCommitLogLeastPages=4flushConsumeQueueLeastPages=2flushCommitLogThoroughInterval=10000flushConsumeQueueThoroughInterval=60000checkTransactionMessageEnable=falsesendMessageThreadPoolNums=128pullMessageThreadPoolNums=128brokerRole=SLAVEflushDiskType=ASYNC_FLUSHsudo mkdir /app/svr/rocketmq/datasudo mkdir -p /app/svr/rocketmq/data/store2/commitlogsudo mkdir /app/svr/rocketmq/data/store2/consumequeuesudo mkdir /app/svr/rocketmq/data/store2/indexmkdir -p /app/svr/rocketmq/logscd /app/svr/rocketmq/confsed -i 's#${user.home}#/app/svr/rocketmq#g' *.xmlsh mqbroker -c /app/svr/rocketmq/conf/2m-2s-sync/broker-a.properties > /dev/null 2>&1 &nohup sh mqbroker -c /app/svr/rocketmq/conf/2m-2s-sync/broker-a.properties &sh mqadmin clusterlist -n 192.168.90.101:9876brokerIP1=192.168.90.101brokerIP2=192.168.90.101<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes(k8s) 安装过程</title>
      <link href="/2019/04/05/Docker/k8s-install/"/>
      <url>/2019/04/05/Docker/k8s-install/</url>
      
        <content type="html"><![CDATA[<p>Kubernetes(k8s) 安装过程</p><a id="more"></a><h2 id="K8S-DashBoard服务"><a href="#K8S-DashBoard服务" class="headerlink" title="K8S DashBoard服务"></a>K8S DashBoard服务</h2><p>创建服务后通过代理访问</p><ol><li><p>创建服务<br>kubectl apply -f <a href="https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml" target="_blank" rel="noopener">https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml</a><br>kubectl create -f kubernetes-dashboard.yaml</p></li><li><p>开启代理<br>kubectl proxy 或 kubectl proxy &amp;</p></li></ol><p>访问:<br><a href="http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/" target="_blank" rel="noopener">http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/</a></p><ol start="3"><li>登录</li></ol><p>配置文件</p><pre><code>Mac: $HOME/.kube/configWin: %UserProfile%\.kube\config</code></pre><p>创建令牌</p><pre><code>kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk '{print $1}')</code></pre><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装总结：</p><ol><li>关闭各种服务，保证安装和集群建立的成功</li><li>安装docker和k8s组件，并保证开启启动</li><li>每台机器上都是一样的，当然master如果不参与负载，可以不装部分组件</li><li>使用kubeadm部署Kubernetes，完成集群初始化</li></ol><h3 id="关于SeLinux"><a href="#关于SeLinux" class="headerlink" title="关于SeLinux"></a>关于SeLinux</h3><pre class="line-numbers language-s"><code class="language-s">关闭SeLinux，由于太复杂，关了SELinux(Security-Enhanced Linux) 是美国国家安全局（NSA）对于强制访问控制的实现，是 Linux历史上最杰出的新安全子系统。NSA是在Linux社区的帮助下开发了一种访问控制体系，在这种访问控制体系的限制下，进程只能访问那些在他的任务中所需要文件。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>sed -i 's/SELINUX=*/SELINUX=disabled/' /etc/selinux/config</code>或修改配置 <code>/etc/selinux/config</code> SELINUX=disabled</p><h3 id="配置cgroup-drive"><a href="#配置cgroup-drive" class="headerlink" title="配置cgroup drive"></a>配置cgroup drive</h3><p>Cgroups是control groups的缩写，是Linux内核提供的一种可以限制、记录、隔离进程组（process groups）所使用的物理资源（如：cpu,memory,IO等等）的机制。最初由google的工程师提出，后来被整合进Linux内核。Cgroups也是LXC为实现虚拟化所使用的资源管理手段，可以说没有cgroups就没有LXC。<br>保证docker 和 kubelet的 cgroup 一致，Cgroup Driver:Cgroupfs 与 Systemd。查看（dockerk可以看到cgroup，kublete就不一定有了，这种情况就统一成一样的吧）<br><code>cat /usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf</code> 可能会在 <code>/etc/systemd/system/kubelet.service.d</code><br><code>docker info</code><br>修改docker的deamon.json </p><pre class="line-numbers language-s"><code class="language-s">{  "exec-opts": ["native.cgroupdriver=systemd"]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>或者修改kublete，去配置文件里面，环境变量设置加上<br><code>Environment="KUBELET_CGROUP_ARGS=--cgroup-driver=systemd"</code></p><h3 id="安装-kubelet-amp-kubeadm-amp-kubectl"><a href="#安装-kubelet-amp-kubeadm-amp-kubectl" class="headerlink" title="安装 kubelet &amp; kubeadm &amp; kubectl"></a>安装 kubelet &amp; kubeadm &amp; kubectl</h3><p>使用yum命令安装</p><p>kubelet:运行在cluster所有节点上，负责启动POD和容器<br>kubeadm:用于初始化cluster，通过它完成k8s的初始化<br>kubectl:kubectl是kubenetes命令行工具，通过kubectl可以部署和管理应用，查看各种资源，创建，删除和更新组件</p><h2 id="kubespray-安装方法"><a href="#kubespray-安装方法" class="headerlink" title="kubespray 安装方法"></a>kubespray 安装方法</h2><p>并不是很推荐的一种方式，应为换源的原因，kubespray的版本往往和镜像不一致，而且你找到的别人的安装总结都是用自己或别人的，总的来说这是一个不错的工具，但是在天朝局域网下特别难用，最好就是锁定kubespray版本，然后使用阿里云制作自己的镜像，然后kubespray里面把谷歌的镜像换成自己制作的。</p><h3 id="批量换源"><a href="#批量换源" class="headerlink" title="批量换源"></a>批量换源</h3><p>grc_image_files=(<br>kuberspray/extra_playbooks/roles/dnsmasq/templates/dnsmasq-autoscaler.yml<br>kuberspray/extra_playbooks/roles/download/defaults/main.yml<br>kuberspray/extra_playbooks/roles/kubernetes-apps/ansible/defaults/main.yml<br>kuberspray/roles/download/defaults/main.yml<br>kuberspray/roles/dnsmasq/templates/dnsmasq-autoscaler.yml<br>kuberspray/roles/kubernetes-apps/ansible/defaults/main.yml<br>)</p><p>grc_image_files=(<br>kubespray/roles/download/defaults/main.yml<br>kubespray/roles/kubernetes-apps/ansible/defaults/main.yml<br>)</p><p>grc_image_files=(<br>kubespray/roles/download/defaults/main.yml<br>)</p><p>for file in ${grc_image_files[@]} ; do<br>    sed -i ‘s/gcr.io/google_containers/registry.cn-hangzhou.aliyuncs.com/szss_k8s/g’ $file<br>done</p><p>for file in ${grc_image_files[@]} ; do<br>    sed -i ‘s/gcr.io/google_containers/registry.cn-hangzhou.aliyuncs.com/szss_k8s/g’ $file<br>done</p><p>quay_image_files=(<br>./kubespray/extra_playbooks/roles/download/defaults/main.yml<br>./kubespray/roles/download/defaults/main.yml<br>)</p><p>quay_image_files=(<br>kubespray/roles/download/defaults/main.yml<br>)</p><p>for file in ${quay_image_files[@]} ; do<br>    sed -i ‘s/quay.io/coreos//registry.cn-hangzhou.aliyuncs.com/szss_quay_io/coreos-/g’ $file<br>    sed -i ‘s/quay.io/calico//registry.cn-hangzhou.aliyuncs.com/szss_quay_io/calico-/g’ $file<br>    sed -i ‘s/quay.io/l23network//registry.cn-hangzhou.aliyuncs.com/szss_quay_io/l23network-/g’ $file<br>done</p><p>安装失败清理 或者用清理命令</p><p>sudo rm -rf /etc/kubernetes/<br>sudo rm -rf /var/lib/kubelet<br>sudo rm -rf /var/lib/etcd<br>sudo rm -rf /usr/local/bin/kubectl<br>sudo rm -rf /etc/systemd/system/calico-node.service<br>sudo rm -rf /etc/systemd/system/kubelet.service<br>sudo systemctl stop etcd.service<br>sudo systemctl disable etcd.service<br>sudo systemctl stop calico-node.service<br>sudo systemctl disable calico-node.service<br>sudo docker stop $(docker ps -q)<br>sudo docker rm $(docker ps -a -q)<br>sudo service docker restart</p><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p>CONFIG_FILE=./kubespray/inventory/inventory.cfg python36 ./kubespray/contrib/inventory_builder/inventory.py ${IP[*]}<br>ansible-playbook -i hosts.ini /etc/kubespray/reset.yml</p><ol><li>流程总结</li></ol><p>虚拟机: vagrant virtual box，虚拟的操作都使用vagrant，最好是使用一个Vagrantfile文件来启动和管理集群，这样比较方便</p><p>网络配置: 使用私有网络，所有虚拟机处在相同的子网当中，相互之间能通信，也能和外网通信</p><p>系统配置：检查虚拟机网络是否联通，完成相关配置（最好不要用临时配置的方式）</p><p>开始安装：下载kubespray，开始安装</p><p>参考：<a href="https://www.one-tab.com/page/HIr4mKK3SBKJJBDk5bNz_A" target="_blank" rel="noopener">https://www.one-tab.com/page/HIr4mKK3SBKJJBDk5bNz_A</a></p><ol start="2"><li>虚拟机</li></ol><p>使用vagrant来管理虚拟机，下面是一个配置文件，vagrant使用ruby来编写配置文件</p><pre class="line-numbers language-ruby"><code class="language-ruby"><span class="token constant">Vagrant</span><span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">do</span> <span class="token operator">|</span>config<span class="token operator">|</span>  <span class="token comment" spellcheck="true"># 如果需要三台就(1..3)的形式</span>  <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>i<span class="token operator">|</span>    config<span class="token punctuation">.</span>vm<span class="token punctuation">.</span>define <span class="token string">"cluster<span class="token interpolation"><span class="token delimiter tag">#{</span>i<span class="token delimiter tag">}</span></span>"</span> <span class="token keyword">do</span> <span class="token operator">|</span>node<span class="token operator">|</span>      node<span class="token punctuation">.</span>vm<span class="token punctuation">.</span>box <span class="token operator">=</span> <span class="token string">"centos_k8s"</span>      node<span class="token punctuation">.</span>vm<span class="token punctuation">.</span>hostname <span class="token operator">=</span> <span class="token string">"cluster<span class="token interpolation"><span class="token delimiter tag">#{</span>i<span class="token delimiter tag">}</span></span>"</span>      node<span class="token punctuation">.</span>vm<span class="token punctuation">.</span>network <span class="token string">"private_network"</span><span class="token punctuation">,</span> ip<span class="token punctuation">:</span> <span class="token string">"192.168.59.<span class="token interpolation"><span class="token delimiter tag">#{</span>i<span class="token delimiter tag">}</span></span>"</span>      <span class="token comment" spellcheck="true"># 映射目录 根据自己实际情况配置</span>      <span class="token comment" spellcheck="true"># node.vm.synced_folder "../var/www/cluster", "/var/www/cluster"</span>      node<span class="token punctuation">.</span>vm<span class="token punctuation">.</span>provider <span class="token string">"virtualbox"</span> <span class="token keyword">do</span> <span class="token operator">|</span>v<span class="token operator">|</span>        v<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"cluster<span class="token interpolation"><span class="token delimiter tag">#{</span>i<span class="token delimiter tag">}</span></span>"</span>        v<span class="token punctuation">.</span>memory <span class="token operator">=</span> <span class="token number">512</span>        v<span class="token punctuation">.</span>cpus <span class="token operator">=</span> <span class="token number">1</span>      <span class="token keyword">end</span>    <span class="token keyword">end</span>  <span class="token keyword">end</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>find /etc/kubespray -name ‘<em>.yml’ | xargs -n1 -I{} sed -i “s/gcr.io/google_containers/gcr.mirrors.ustc.edu.cn/google-containers/g” {}<br>find /etc/kubespray -name ‘</em>.yml’ | xargs -n1 -I{} sed -i “s/gcr.io/google-containers/gcr.mirrors.ustc.edu.cn/google-containers/g” {}<br>find /etc/kubespray -name ‘*.yml’ | xargs -n1 -I{} sed -i ‘s/quay.io/quay-mirror.qiniu.com/‘ {}</p><p>find /etc/kubespray -name ‘<em>.yml’ | xargs -n1 -I{} sed -i “s/mirrorgooglecontainers/google-containers/registry.cn-hangzhou.aliyuncs.com/google_containers/g” {}<br>find /etc/kubespray -name ‘</em>.yml’ | xargs -n1 -I{} sed -i “s/mirrorgooglecontainers/google-containers/registry.cn-hangzhou.aliyuncs.com/google_containers/g” {}<br>find /etc/kubespray -name ‘*.yml’ | xargs -n1 -I{} sed -i ‘s/quay.io/quay-mirror.qiniu.com/‘ {}</p><h2 id="kubeadm-安装-精简版"><a href="#kubeadm-安装-精简版" class="headerlink" title="kubeadm 安装(精简版)"></a>kubeadm 安装(精简版)</h2><p>官方安装工具，推荐使用的一种安装方式，最大的问题可能仍然是镜像，通过换源使用阿里的仓库，阿里的仓库已经有了同名的所需的镜像，而且是不用科学上网的</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>所有机器都要执行，这里使用的用户是普通用户，所以命名涉及权限的都要加sudo</p><ol><li>设置主机名hostname，管理节点设置主机名为 master，其它设置为node</li></ol><pre class="line-numbers language-s"><code class="language-s">sudo hostnamectl set-hostname master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>然后配置/etc/hosts</li></ol><pre class="line-numbers language-s"><code class="language-s">192.168.59.101 cluster1192.168.59.102 cluster2192.168.59.103 cluster3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>关闭防火墙、selinux和swap</li></ol><pre class="line-numbers language-s"><code class="language-s">sudo systemctl stop firewalldsudo systemctl disable firewalldsudo setenforce 0sudo sed -i "s/^SELINUX=enforcing/SELINUX=disabled/g" /etc/selinux/configsudo swapoff -asudo sed -i 's/.*swap.*/#&/' /etc/fstab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>配置内核参数，将桥接的IPv4流量传递到iptables</li></ol><pre class="line-numbers language-s"><code class="language-s">sudo touch /etc/sysctl.d/k8s.conf && sudo vim /etc/sysctl.d/k8s.confnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1net.ipv4.ip_forward = 1执行：sudo modprobe br_netfiltersysctl -p /etc/sysctl.d/k8s.conf sudo sysctl --system 不推荐使内核参数生效(sysctl --system，这个会加载所有的sysctl配置，sysctl -p默认无参数只加载/etc/sysctl.conf)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>配置国内yum源</li></ol><pre class="line-numbers language-s"><code class="language-s">sudo yum install -y wgetsudo mkdir /etc/yum.repos.d/bak && sudo mv /etc/yum.repos.d/*.repo /etc/yum.repos.d/baksudo wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.cloud.tencent.com/repo/centos7_base.reposudo wget -O /etc/yum.repos.d/epel.repo http://mirrors.cloud.tencent.com/repo/epel-7.reposudo yum clean all && sudo yum makecache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li>配置国内Kubernetes源</li></ol><pre class="line-numbers language-s"><code class="language-s">sudo touch /etc/yum.repos.d/kubernetes.repo && sudo vim /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="7"><li>配置 docker 源</li></ol><pre class="line-numbers language-s"><code class="language-s">sudo wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>至此，环境准备工作完成，除了主机名称设置不一样，其它操作每台机器执行都是一样的</p><h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><p>所有机器都执行</p><ol><li>安装docker</li></ol><p>这里指定了版本号(docker-ce就默认安装最新的)</p><pre class="line-numbers language-s"><code class="language-s">sudo yum install -y docker-ce-18.06.1.ce-3.el7sudo systemctl enable docker && sudo systemctl start docker查看安装：sudo docker –versionDocker version 18.06.1-ce, build e68fc7a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>安装kubeadm、kubelet、kubectl</li></ol><p>没有指定版本，默认安装最新的，这里很重要，应为k8s的版本和这里所安装的版本有关，如果你不指定版本，k8s安装也是默认用最新的</p><pre class="line-numbers language-s"><code class="language-s">sudo yum install -y kubelet kubeadm kubectlsudo systemctl enable kubelet<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>修改配置</p><pre class="line-numbers language-s"><code class="language-s">修改cgroups，在末尾加上"--cgroup-driver=cgroupfs"sudo vim /usr/lib/systemd/system/kubelet.service.d/10-kubeadm.confEnvironment="KUBELET_KUBECONFIG_ARGS=--bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf --cgroup-driver=cgroupfs"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>写法是多样的，新版本官方推荐使用systemd而不是cgroupfs</p><pre class="line-numbers language-s"><code class="language-s">Environment="KUBELET_CGROUP_ARGS=--cgroup-driver=systemd"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="部署master节点"><a href="#部署master节点" class="headerlink" title="部署master节点"></a>部署master节点</h3><ol><li>拉取镜像，创建集群(只在master节点执行)</li></ol><pre class="line-numbers language-s"><code class="language-s">sudo kubeadm init --kubernetes-version=1.15.2 --apiserver-advertise-address=192.168.59.101 --image-repository registry.aliyuncs.com/google_containers --service-cidr=10.1.0.0/16 --pod-network-cidr=10.244.0.0/16<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指定了网段，镜像仓库，k8s版本，这里的版本要和上面安装的软件对应上，命令执行失败按照提示修改即可，可能会出现的情况，机器配置不足，docker cgroup-driver 警告等</p><ol start="2"><li>执行流程</li></ol><pre class="line-numbers language-s"><code class="language-s">init] Using Kubernetes version: v1.15.2[preflight] Running pre-flight checks    [WARNING IsDockerSystemdCheck]: detected "cgroupfs" as the Docker cgroup driver. The recommended driver is "systemd". Please follow the guide at https://kubernetes.io/docs/setup/cri/[preflight] Pulling images required for setting up a Kubernetes cluster[preflight] This might take a minute or two, depending on the speed of your internet connection[preflight] You can also perform this action in beforehand using 'kubeadm config images pull'[kubelet-start] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env"[kubelet-start] Writing kubelet configuration to file "/var/lib/kubelet/config.yaml"[kubelet-start] Activating the kubelet service[certs] Using certificateDir folder "/etc/kubernetes/pki"[certs] Generating "ca" certificate and key[certs] Generating "apiserver-kubelet-client" certificate and key[certs] Generating "apiserver" certificate and key[certs] apiserver serving cert is signed for DNS names [cluster1 kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.1.0.1 192.168.59.101][certs] Generating "etcd/ca" certificate and key[certs] Generating "etcd/peer" certificate and key[certs] etcd/peer serving cert is signed for DNS names [cluster1 localhost] and IPs [192.168.59.101 127.0.0.1 ::1][certs] Generating "apiserver-etcd-client" certificate and key[certs] Generating "etcd/server" certificate and key[certs] etcd/server serving cert is signed for DNS names [cluster1 localhost] and IPs [192.168.59.101 127.0.0.1 ::1][certs] Generating "etcd/healthcheck-client" certificate and key[certs] Generating "front-proxy-ca" certificate and key[certs] Generating "front-proxy-client" certificate and key[certs] Generating "sa" key and public key[kubeconfig] Using kubeconfig folder "/etc/kubernetes"[kubeconfig] Writing "admin.conf" kubeconfig file[kubeconfig] Writing "kubelet.conf" kubeconfig file[kubeconfig] Writing "controller-manager.conf" kubeconfig file[kubeconfig] Writing "scheduler.conf" kubeconfig file[control-plane] Using manifest folder "/etc/kubernetes/manifests"[control-plane] Creating static Pod manifest for "kube-apiserver"[control-plane] Creating static Pod manifest for "kube-controller-manager"[control-plane] Creating static Pod manifest for "kube-scheduler"[etcd] Creating static Pod manifest for local etcd in "/etc/kubernetes/manifests"[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory "/etc/kubernetes/manifests". This can take up to 4m0s[apiclient] All control plane components are healthy after 23.503947 seconds[upload-config] Storing the configuration used in ConfigMap "kubeadm-config" in the "kube-system" Namespace[kubelet] Creating a ConfigMap "kubelet-config-1.15" in namespace kube-system with the configuration for the kubelets in the cluster[upload-certs] Skipping phase. Please see --upload-certs[mark-control-plane] Marking the node cluster1 as control-plane by adding the label "node-role.kubernetes.io/master=''"[mark-control-plane] Marking the node cluster1 as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule][bootstrap-token] Using token: sqvswo.903bhdss7w01bsac[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token[bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster[bootstrap-token] Creating the "cluster-info" ConfigMap in the "kube-public" namespace[addons] Applied essential addon: CoreDNS[addons] Applied essential addon: kube-proxy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建成功后，会返回这样的信息，这个信息很重要，节点加入集群需要用到，忘记了可以重新找到(百度)</p><pre class="line-numbers language-s"><code class="language-s">Your Kubernetes control-plane has initialized successfully!To start using your cluster, you need to run the following as a regular user:  mkdir -p $HOME/.kube  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config  sudo chown $(id -u):$(id -g) $HOME/.kube/configYou should now deploy a pod network to the cluster.Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at:  https://kubernetes.io/docs/concepts/cluster-administration/addons/Then you can join any number of worker nodes by running the following on each as root:kubeadm join 192.168.59.101:6443 --token sqvswo.903bhdss7w01bsac \    --discovery-token-ca-cert-hash sha256:1cbc26f1d257f042d382273250dbfe52275f90be6784c743200738e4142f9e30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>配置kubectl工具</li></ol><p>大致就是需要配置环境变量才能正确使用kubectl</p><pre><code>方法1:[root@k8s-master ~]# export KUBECONFIG=/etc/kubernetes/admin.conf#此处如果没有声明环境变量，是没有加载管理k8s集群的权限的，此时去查看集群，会提示拒绝了该请求。如下：The connection to the server localhost:8080 was refused - did you specify the right host or port?方法2(推荐):[root@k8s-master ~]# mkdir -p /root/.kube[root@k8s-master ~]# cp -i /etc/kubernetes/admin.conf /root/.kube/config 测试命令，返回Healthy说明master功能正常[root@k8s-master ~]# kubectl get csNAME                 STATUS    MESSAGE             ERRORscheduler            Healthy   ok                  controller-manager   Healthy   ok                  etcd-0               Healthy   {"health":"true"}   [root@k8s-master ~]# kubectl get nodeNAME         STATUS     ROLES    AGE     VERSIONk8s-master   NotReady   master   2m10s   v1.15.2</code></pre><ol start="4"><li>部署网络</li></ol><p>这一步很重要，k8s通过安装插件的形式来和其它node节点通信，插件可以自选，这里使用flannel由于上面的步骤已经通过换源，更改镜像仓库的形式保证了网络正常，而flannel同样也是需要翻墙的。</p><p>流程就是sudo kubectl apply -f kube-flannel.yml即可部署flannel网络</p><p>所以我们需要先去下载一个kube-flannel.yml文件，执行就要拉取镜像了，由于网络问题，一般就两种解决方案:</p><ul><li>修改文件，把镜像换成可以访问的</li><li>通过其它地址拉取镜像，重新打标签</li></ul><p>第二种操作难度要低的很多，这里用别人做好的，如果不能拉取自己通过阿里镜像仓库做一个，拉取了再打标签</p><pre class="line-numbers language-s"><code class="language-s">mkdir k8s && cd k8scurl -O https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.ymlsudo docker pull quay-mirror.qiniu.com/coreos/flannel:v0.11.0-amd64sudo docker tag quay-mirror.qiniu.com/coreos/flannel:v0.11.0-amd64 quay.io/coreos/flannel:v0.11.0-amd64sudo kubectl apply -f kube-flannel.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行命令 sudo kubectl get pods -n kube-system pod都处于Running状态，集群状态即为正常运行</p><h3 id="node节点加入集群"><a href="#node节点加入集群" class="headerlink" title="node节点加入集群"></a>node节点加入集群</h3><p>node节点也需要部署flannel、pause、kube-proxy的pod，所以需要预先进行下载镜像，版本如下，由于k8s使用的是1.15.2，flannel在安装的时候是v0.11.0-amd64 </p><pre class="line-numbers language-s"><code class="language-s">k8s.gcr.io/kube-proxy-amd64:v1.15.2 quay.io/coreos/flannel:v0.11.0-amd64 k8s.gcr.io/pause:3.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>镜像在需要的时候就回去拉取，由于我们已经换源了，所以到这步，各个node节点可以看到</p><pre class="line-numbers language-s"><code class="language-s">registry.aliyuncs.com/google_containers/kube-proxy   v1.15.2registry.aliyuncs.com/google_containers/pause        3.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也就是只差着flannel镜像了，通过拉取可以拉取的重新打标签的方式，如此镜像就准备好了</p><p>执行上面集群初始化返回的命令</p><pre class="line-numbers language-s"><code class="language-s">kubeadm join 192.168.59.101:6443 --token 5r21h1.gv4kimitgx4x07ct --discovery-token-ca-cert-hash sha256:0e1b2352024abad3cf0a0d301e66e0a5eef4147a34745a3843aa52ec01578871<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一般都是返回成功的，其实还没有完成，拉取镜像的步骤在之后进行，可以在master上sudo kubectl get pods -n kube-system pod查看是否都是running，如果flannel无法拉取，就会卡在那里，所以最好先准备好镜像</p><p>kubectl get nodes 检查集群状态</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>准备环境</li><li>安装软件</li><li>部署master和node</li></ol><p>准备环境都是那几步骤，除非你的内核太低了。安装软件不指定版本，默认最新，上面就是1.15.2的，那么后续的都是这个版本为主。部署网络也是，你下载的文件可能使用的镜像不是v0.11.0-amd64，也要注意处理</p><p>如果在集群安装过程中有遇到其他问题，可以使用以下命令进行重置：</p><pre class="line-numbers language-s"><code class="language-s">初始化(所有机器都执行)$ kubeadm reset大概是移除网络，不一定需要，如果网络已有了可以执行清理，通过ifconfig查看$ sudo ifconfig cni0 down && sudo ip link delete cni0$ sudo ifconfig flannel.1 down && sudo ip link delete flannel.1删除cni文件$ sudo rm -rf /var/lib/cni/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="关于网卡问题导致网络通信失败"><a href="#关于网卡问题导致网络通信失败" class="headerlink" title="关于网卡问题导致网络通信失败"></a>关于网卡问题导致网络通信失败</h3><p>这是使用vagrant导致的，vagrant使用第一网卡来做ssh，导致flannel通信失败，需要我们创建集群的时候手动指定网卡，这是本地环境搭建，而且使用vagrant的时候会遇到的一个问题</p><p>这里列出了v0.11.0-amd64版本的yml</p><pre class="line-numbers language-yml"><code class="language-yml">---apiVersion: policy/v1beta1kind: PodSecurityPolicymetadata:  name: psp.flannel.unprivileged  annotations:    seccomp.security.alpha.kubernetes.io/allowedProfileNames: docker/default    seccomp.security.alpha.kubernetes.io/defaultProfileName: docker/default    apparmor.security.beta.kubernetes.io/allowedProfileNames: runtime/default    apparmor.security.beta.kubernetes.io/defaultProfileName: runtime/defaultspec:  privileged: false  volumes:    - configMap    - secret    - emptyDir    - hostPath  allowedHostPaths:    - pathPrefix: "/etc/cni/net.d"    - pathPrefix: "/etc/kube-flannel"    - pathPrefix: "/run/flannel"  readOnlyRootFilesystem: false  # Users and groups  runAsUser:    rule: RunAsAny  supplementalGroups:    rule: RunAsAny  fsGroup:    rule: RunAsAny  # Privilege Escalation  allowPrivilegeEscalation: false  defaultAllowPrivilegeEscalation: false  # Capabilities  allowedCapabilities: ['NET_ADMIN']  defaultAddCapabilities: []  requiredDropCapabilities: []  # Host namespaces  hostPID: false  hostIPC: false  hostNetwork: true  hostPorts:  - min: 0    max: 65535  # SELinux  seLinux:    # SELinux is unsed in CaaSP    rule: 'RunAsAny'---kind: ClusterRoleapiVersion: rbac.authorization.k8s.io/v1beta1metadata:  name: flannelrules:  - apiGroups: ['extensions']    resources: ['podsecuritypolicies']    verbs: ['use']    resourceNames: ['psp.flannel.unprivileged']  - apiGroups:      - ""    resources:      - pods    verbs:      - get  - apiGroups:      - ""    resources:      - nodes    verbs:      - list      - watch  - apiGroups:      - ""    resources:      - nodes/status    verbs:      - patch---kind: ClusterRoleBindingapiVersion: rbac.authorization.k8s.io/v1beta1metadata:  name: flannelroleRef:  apiGroup: rbac.authorization.k8s.io  kind: ClusterRole  name: flannelsubjects:- kind: ServiceAccount  name: flannel  namespace: kube-system---apiVersion: v1kind: ServiceAccountmetadata:  name: flannel  namespace: kube-system---kind: ConfigMapapiVersion: v1metadata:  name: kube-flannel-cfg  namespace: kube-system  labels:    tier: node    app: flanneldata:  cni-conf.json: |    {      "name": "cbr0",      "plugins": [        {          "type": "flannel",          "delegate": {            "hairpinMode": true,            "isDefaultGateway": true          }        },        {          "type": "portmap",          "capabilities": {            "portMappings": true          }        }      ]    }  net-conf.json: |    {      "Network": "10.244.0.0/16",      "Backend": {        "Type": "vxlan"      }    }---apiVersion: apps/v1kind: DaemonSetmetadata:  name: kube-flannel-ds-amd64  namespace: kube-system  labels:    tier: node    app: flannelspec:  selector:    matchLabels:      app: flannel  template:    metadata:      labels:        tier: node        app: flannel    spec:      hostNetwork: true      nodeSelector:        beta.kubernetes.io/arch: amd64      tolerations:      - operator: Exists        effect: NoSchedule      serviceAccountName: flannel      initContainers:      - name: install-cni        image: quay.io/coreos/flannel:v0.11.0-amd64        command:        - cp        args:        - -f        - /etc/kube-flannel/cni-conf.json        - /etc/cni/net.d/10-flannel.conflist        volumeMounts:        - name: cni          mountPath: /etc/cni/net.d        - name: flannel-cfg          mountPath: /etc/kube-flannel/      containers:      - name: kube-flannel        image: quay.io/coreos/flannel:v0.11.0-amd64        command:        - /opt/bin/flanneld        args:        - --ip-masq        - --kube-subnet-mgr        - --iface=eth1        resources:          requests:            cpu: "100m"            memory: "50Mi"          limits:            cpu: "100m"            memory: "50Mi"        securityContext:          privileged: false          capabilities:             add: ["NET_ADMIN"]        env:        - name: POD_NAME          valueFrom:            fieldRef:              fieldPath: metadata.name        - name: POD_NAMESPACE          valueFrom:            fieldRef:              fieldPath: metadata.namespace        volumeMounts:        - name: run          mountPath: /run/flannel        - name: flannel-cfg          mountPath: /etc/kube-flannel/      volumes:        - name: run          hostPath:            path: /run/flannel        - name: cni          hostPath:            path: /etc/cni/net.d        - name: flannel-cfg          configMap:            name: kube-flannel-cfg---apiVersion: apps/v1kind: DaemonSetmetadata:  name: kube-flannel-ds-arm64  namespace: kube-system  labels:    tier: node    app: flannelspec:  selector:    matchLabels:      app: flannel  template:    metadata:      labels:        tier: node        app: flannel    spec:      hostNetwork: true      nodeSelector:        beta.kubernetes.io/arch: arm64      tolerations:      - operator: Exists        effect: NoSchedule      serviceAccountName: flannel      initContainers:      - name: install-cni        image: quay.io/coreos/flannel:v0.11.0-arm64        command:        - cp        args:        - -f        - /etc/kube-flannel/cni-conf.json        - /etc/cni/net.d/10-flannel.conflist        volumeMounts:        - name: cni          mountPath: /etc/cni/net.d        - name: flannel-cfg          mountPath: /etc/kube-flannel/      containers:      - name: kube-flannel        image: quay.io/coreos/flannel:v0.11.0-arm64        command:        - /opt/bin/flanneld        args:        - --ip-masq        - --kube-subnet-mgr        resources:          requests:            cpu: "100m"            memory: "50Mi"          limits:            cpu: "100m"            memory: "50Mi"        securityContext:          privileged: false          capabilities:             add: ["NET_ADMIN"]        env:        - name: POD_NAME          valueFrom:            fieldRef:              fieldPath: metadata.name        - name: POD_NAMESPACE          valueFrom:            fieldRef:              fieldPath: metadata.namespace        volumeMounts:        - name: run          mountPath: /run/flannel        - name: flannel-cfg          mountPath: /etc/kube-flannel/      volumes:        - name: run          hostPath:            path: /run/flannel        - name: cni          hostPath:            path: /etc/cni/net.d        - name: flannel-cfg          configMap:            name: kube-flannel-cfg---apiVersion: apps/v1kind: DaemonSetmetadata:  name: kube-flannel-ds-arm  namespace: kube-system  labels:    tier: node    app: flannelspec:  selector:    matchLabels:      app: flannel  template:    metadata:      labels:        tier: node        app: flannel    spec:      hostNetwork: true      nodeSelector:        beta.kubernetes.io/arch: arm      tolerations:      - operator: Exists        effect: NoSchedule      serviceAccountName: flannel      initContainers:      - name: install-cni        image: quay.io/coreos/flannel:v0.11.0-arm        command:        - cp        args:        - -f        - /etc/kube-flannel/cni-conf.json        - /etc/cni/net.d/10-flannel.conflist        volumeMounts:        - name: cni          mountPath: /etc/cni/net.d        - name: flannel-cfg          mountPath: /etc/kube-flannel/      containers:      - name: kube-flannel        image: quay.io/coreos/flannel:v0.11.0-arm        command:        - /opt/bin/flanneld        args:        - --ip-masq        - --kube-subnet-mgr        resources:          requests:            cpu: "100m"            memory: "50Mi"          limits:            cpu: "100m"            memory: "50Mi"        securityContext:          privileged: false          capabilities:             add: ["NET_ADMIN"]        env:        - name: POD_NAME          valueFrom:            fieldRef:              fieldPath: metadata.name        - name: POD_NAMESPACE          valueFrom:            fieldRef:              fieldPath: metadata.namespace        volumeMounts:        - name: run          mountPath: /run/flannel        - name: flannel-cfg          mountPath: /etc/kube-flannel/      volumes:        - name: run          hostPath:            path: /run/flannel        - name: cni          hostPath:            path: /etc/cni/net.d        - name: flannel-cfg          configMap:            name: kube-flannel-cfg---apiVersion: apps/v1kind: DaemonSetmetadata:  name: kube-flannel-ds-ppc64le  namespace: kube-system  labels:    tier: node    app: flannelspec:  selector:    matchLabels:      app: flannel  template:    metadata:      labels:        tier: node        app: flannel    spec:      hostNetwork: true      nodeSelector:        beta.kubernetes.io/arch: ppc64le      tolerations:      - operator: Exists        effect: NoSchedule      serviceAccountName: flannel      initContainers:      - name: install-cni        image: quay.io/coreos/flannel:v0.11.0-ppc64le        command:        - cp        args:        - -f        - /etc/kube-flannel/cni-conf.json        - /etc/cni/net.d/10-flannel.conflist        volumeMounts:        - name: cni          mountPath: /etc/cni/net.d        - name: flannel-cfg          mountPath: /etc/kube-flannel/      containers:      - name: kube-flannel        image: quay.io/coreos/flannel:v0.11.0-ppc64le        command:        - /opt/bin/flanneld        args:        - --ip-masq        - --kube-subnet-mgr        resources:          requests:            cpu: "100m"            memory: "50Mi"          limits:            cpu: "100m"            memory: "50Mi"        securityContext:          privileged: false          capabilities:             add: ["NET_ADMIN"]        env:        - name: POD_NAME          valueFrom:            fieldRef:              fieldPath: metadata.name        - name: POD_NAMESPACE          valueFrom:            fieldRef:              fieldPath: metadata.namespace        volumeMounts:        - name: run          mountPath: /run/flannel        - name: flannel-cfg          mountPath: /etc/kube-flannel/      volumes:        - name: run          hostPath:            path: /run/flannel        - name: cni          hostPath:            path: /etc/cni/net.d        - name: flannel-cfg          configMap:            name: kube-flannel-cfg---apiVersion: apps/v1kind: DaemonSetmetadata:  name: kube-flannel-ds-s390x  namespace: kube-system  labels:    tier: node    app: flannelspec:  selector:    matchLabels:      app: flannel  template:    metadata:      labels:        tier: node        app: flannel    spec:      hostNetwork: true      nodeSelector:        beta.kubernetes.io/arch: s390x      tolerations:      - operator: Exists        effect: NoSchedule      serviceAccountName: flannel      initContainers:      - name: install-cni        image: quay.io/coreos/flannel:v0.11.0-s390x        command:        - cp        args:        - -f        - /etc/kube-flannel/cni-conf.json        - /etc/cni/net.d/10-flannel.conflist        volumeMounts:        - name: cni          mountPath: /etc/cni/net.d        - name: flannel-cfg          mountPath: /etc/kube-flannel/      containers:      - name: kube-flannel        image: quay.io/coreos/flannel:v0.11.0-s390x        command:        - /opt/bin/flanneld        args:        - --ip-masq        - --kube-subnet-mgr        resources:          requests:            cpu: "100m"            memory: "50Mi"          limits:            cpu: "100m"            memory: "50Mi"        securityContext:          privileged: false          capabilities:             add: ["NET_ADMIN"]        env:        - name: POD_NAME          valueFrom:            fieldRef:              fieldPath: metadata.name        - name: POD_NAMESPACE          valueFrom:            fieldRef:              fieldPath: metadata.namespace        volumeMounts:        - name: run          mountPath: /run/flannel        - name: flannel-cfg          mountPath: /etc/kube-flannel/      volumes:        - name: run          hostPath:            path: /run/flannel        - name: cni          hostPath:            path: /etc/cni/net.d        - name: flannel-cfg          configMap:            name: kube-flannel-cfg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 总结</title>
      <link href="/2019/04/05/Java/maven/"/>
      <url>/2019/04/05/Java/maven/</url>
      
        <content type="html"><![CDATA[<p>Maven的使用与学习总结</p><a id="more"></a><h2 id="base"><a href="#base" class="headerlink" title="base"></a>base</h2><p>POM 项目对象模型</p><p>构建生命周期：包含三个标准生命周期，clean default site，每个生命周期都包含若干个阶段，执行某个阶段的时候，该阶段之前的其它阶段都会被执行</p><p>仓库：在 Maven 中，任何一个依赖、插件或者项目构建的输出，都可以称之为构件。<br>仓库安装本地，中央，远程的顺序来查找，中央是官方仓库，远程是用户自定义远程仓库</p><p>插件：生命周期的执行都是由对应插件来完成的，可以配置相关插件的具体操作</p><p>项目模板，项目文档</p><p>快照：通过快照可以固化某个pom配置</p><p>自动化构建：构建流程控制，比如依赖的项目构建完成，才开始构建本项目</p><p>依赖管理</p><p>自动构建，通过对应的插件Release实现自动构建</p><p>什么是 maven的uber-jar</p><p>在maven的一些文档中我们会发现 “uber-jar”这个术语，许多人看到后感到困惑。其实在很多编程语言中会把super叫做uber （因为suber可能是关键字）， 这是上世纪80年代开始流行的，比如管superman叫uberman。所以uber-jar从字面上理解就是super-jar，这样的jar不但包含自己代码中的class ，也会包含一些第三方依赖的jar，也就是把自身的代码和其依赖的jar全打包在一个jar里面了，所以就很形象的称其为super-jar ，呵呵，uber-jar来历就是这样的</p><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>通过IDEA就可以打包了，前提是要配置好pom文件，项目是maven工程</p><p>打包会扫描测试部分的代码，测试不通过也不行(可以配置跳过)。打包后得到jar包，用<code>java -jar api-1.0.jar</code>命名就可以运行，<code>api-1.0.jar.original</code>后缀的文件是给其它项目依赖用的(暂时不管，这个不能用来部署)</p><h2 id="导入包到当前仓库"><a href="#导入包到当前仓库" class="headerlink" title="导入包到当前仓库"></a>导入包到当前仓库</h2><p>system 除了可以用于引入系统classpath 中包，也可以用于引入系统非maven  收录的第三方Jar，做法是将第三方Jar放置在 项目的 lib 目录下，然后配置 相对路径，但因system 不会打包进去所以需要配合 maven-dependency-plugin 插件配合使用。当然推荐大家还是通过将第三方Jar手动install 到仓库(这一点非常重要，因为各个企业不可能没有一点定制，除非jar包在私服仓库，否则最好就是要走这个安装流程，下面是一个安装示意)</p><p><code>mvn install:install-file -DgroupId=com.ctg.itrdc.cache -DartifactId=ctg-cache-nclient -Dversion=2.4.0 -Dpackaging=jar -Dfile=/Users/liuzhi/Downloads/ctg-cache-nclient-2.4.0.jar</code></p><p>根据实际情况，修改对应的参数</p><h2 id="maven快速构建项目"><a href="#maven快速构建项目" class="headerlink" title="maven快速构建项目"></a>maven快速构建项目</h2><p>mvn使用插件快速构建项目</p><p>mvn archetype:generate<br>    -DgroupId=com.liuzhidream.app<br>    -DartifactId=spring-learn<br>    -DarchetypeArtifactId=maven-archetype-quickstart<br>    -DinteractiveMode=false</p><p>执行mvn操作，要进行pom文件所在目录</p><h2 id="Maven仓库"><a href="#Maven仓库" class="headerlink" title="Maven仓库"></a>Maven仓库</h2><p>默认远程仓库： <a href="http://repo1.maven.org/maven2" target="_blank" rel="noopener">http://repo1.maven.org/maven2</a></p><p>本地仓库： 默认在 ~/.m2/respository </p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>localRepository</span><span class="token punctuation">></span></span>D:/maven/repository<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>localRepository</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="使用阿里仓库"><a href="#使用阿里仓库" class="headerlink" title="使用阿里仓库"></a>使用阿里仓库</h2><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>repositories</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>repository</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>central<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>aliyun maven<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url</span><span class="token punctuation">></span></span>http://maven.aliyun.com/nexus/content/groups/public/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>layout</span><span class="token punctuation">></span></span>default<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>layout</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 是否开启发布版构件下载 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>releases</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>enabled</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>enabled</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>releases</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 是否开启快照版构件下载 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>snapshots</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>enabled</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>enabled</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>snapshots</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>repository</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>repositories</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里还可以延伸很多知识点，首先maven是先从本地仓库找，找不到，再找远程仓库</p><p>远程仓库分为: 中央仓库，私服，其它远程仓库</p><ul><li>默认是去中央仓库找</li><li>私服是一种特殊的远程仓库，架设于局域网内。当maven需要下载构件时，先从私服寻找，私服中没有再从外部仓库下载</li><li>任何一个仓库的id是唯一的，maven自带的中央仓库使用的id为central，如果其他仓库的id也为central，那么它将覆盖自带的中央仓库</li></ul><p>实践总结: 有时候我们去maven官网找到的jar包并不是默认的中央仓库的(注意看，一般都会有个note告诉你)，这个时候就需要配置repositories，并且id不能用central。还有一种情况就是用阿里云的仓库代替maven的默认中央仓库</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><code>settings.xml</code>文件一般存在于两个位置</p><p>全局配置:  ${MAVEN_HOME}/conf/settings.xml<br>用户配置:  user.home/.m2/settings.xml</p><p>需要注意的是：<strong>局部配置优先于全局配置</strong>。<br>配置优先级从高到低：<code>pom.xml&gt; user settings &gt; global settings</code><br>如果这些文件同时存在，在应用配置时，会合并它们的内容，如果有重复的配置，优先级高的配置会覆盖优先级的</p><p>/Applications/IntelliJ\ IDEA.app/Contents/plugins/maven/lib/maven3/conf  idea 路径，记得转义空格cp到目录下</p><p>我本地情况: 默认源码，idea配置文件都是空的配置，m2下没有配置文件（Mac环境）</p><h2 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h2><p>项目依赖是指maven 通过依赖传播、依赖优先原则、可选依赖、排除依赖、依赖范围等特性来管理项目ClassPath</p><h2 id="dependency-scope"><a href="#dependency-scope" class="headerlink" title="dependency scope"></a>dependency scope</h2><p>依赖中有一个属性是描述依赖作用域的</p><ol><li><p>compile<br>默认的scope，表示 dependency 都可以在生命周期中使用。而且，这些dependencies 会传递到依赖的项目中</p></li><li><p>provided<br>跟compile相似，但是表明了dependency 由JDK或者容器提供，如：servlet-api，因为servlet-api，tomcat等web服务器已经存在了，如果再打包会冲突。这个scope 只能作用在编译和测试时，同时没有传递性</p></li></ol><p>使用这个时，不会将包打入本项目中，只是依赖过来，使用默认或其他时，会将依赖的项目打成jar包，放入本项目的Lib里</p><ol start="3"><li><p>runtime<br>表示dependency不作用在编译时，但会作用在运行和测试时</p></li><li><p>test<br>表示dependency作用在测试时，不作用在运行时</p></li><li><p>system<br>跟provided 相似，但是在系统中要以外部JAR包的形式提供，maven不会在repository查找它</p></li></ol><pre><code>&lt;scope&gt;system&lt;/scope&gt;&lt;systemPath&gt;${java.home}/lib/rt.jar&lt;/systemPath&gt;</code></pre><ol start="6"><li>import<br>只能用在dependencyManagement里面</li></ol><p>我用实际例子说明这个作用，在<code>A项目</code>下<code>dependencyManagement</code>定义的<code>依赖B</code>使用<code>import</code>配置，可以把这个<code>依赖B</code>自己的<code>dependencies</code>下的依赖加到<code>A项目</code>下的<code>dependencyManagement</code>中</p><p>A项目</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencyManagement</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>${spring-cloud.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencyManagement</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就相当于Spring-cloud的依赖被加入进来了，记住dependencyManagement的特性，加入进来要使用才在项目中被依赖</p><p>然后其他项目</p><pre class="line-numbers language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-config-server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这个项目的父pom是Spring-boot，却可以使用Spring-cloud的，不用声名版本号，就是因为import的特性</p><h2 id="项目聚合与继承"><a href="#项目聚合与继承" class="headerlink" title="项目聚合与继承"></a>项目聚合与继承</h2><p>聚合：是指将多个模块整合在一起，统一构建，避免一个一个的构建。聚合需要个父工程，然后使用 <code>&lt;modules&gt;</code> 进行配置其中对应的是子工程的相对路径</p><p>继承：是指子工程直接继承父工程 当中的属性、依赖、插件等配置，避免重复配置</p><ol><li>属性继承</li><li>依赖继承</li><li>插件继承</li></ol><p>上面的三个配置子工程都可以进行重写，重写之后以子工程的为准</p><p>依赖管理：通过继承的特性，子工程是可以间接依赖父工程的依赖，但多个子工程依赖有时并不一至，这时就可以在父工程中加入 <code>&lt;dependencyManagement&gt;</code> 声明工程需要的JAR包，然后在子工程中引入</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>！--</span> <span class="token attr-name">父工程中声明</span> <span class="token attr-name">junit</span> <span class="token attr-name">4.12</span> <span class="token attr-name">--</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencyManagement</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencyManagement</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 子工程中引入 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>dependencyManagement 只是声明依赖的版本号，该依赖不会引入，因此子项目需要显示声明所需要引入的依赖，若不声明则不引入</li><li>子项目声明了依赖且未声明版本号和scope，则会继承父项目的版本号和scope，否则覆盖</li></ol><p>上述的2点描述了dependencyManagement的作用，本来父pom文件定义的依赖，子pom继承，但是两个子pom可能版本号不一样，这就导致了同一个jar包有两个版本，而dependencyManagement就是解决这个问题的</p><h2 id="maven-optional"><a href="#maven-optional" class="headerlink" title="maven optional"></a>maven optional</h2><p>俗称依赖传递，当pom A 依赖了 依赖 B之后，如果pom C 继承 pom A，那么依赖 B 也会传到 pom C中，如果我们不想要这个依赖，一个办法就是在<br>pom C 中排除依赖 <code>exclusions</code>，还有一种办法就是用 optional，在依赖 B中设置 optional，这个依赖就只在当前pom生效，不会传递到 pom C</p><p>如果使用了 optional 后，想在 pom C 中去使用这个依赖，按照常规方式声名就行了</p><h2 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h2><pre class="line-numbers language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 配置proName属性 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>proName</span><span class="token punctuation">></span></span>fox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>proName</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 引用方式 --></span>${proName}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认属性</p><pre><code>${basedir} 项目根目录;    ${version} 表示项目版本;  ${project.basedir}同${basedir};  ${project.version}表示项目版本,与${version}相同;  ${project.build.directory} 构建目录，缺省为target  ${project.build.sourceEncoding}表示主源码的编码格式;  ${project.build.sourceDirectory}表示主源码路径;  ${project.build.finalName}表示输出文件名称;  ${project.build.outputDirectory} 构建过程输出目录，缺省为target/classes </code></pre><h2 id="项目构建配置"><a href="#项目构建配置" class="headerlink" title="项目构建配置"></a>项目构建配置</h2><p>就是如何构建，包括资源文件的各种包含，过滤等配置，不过如果是spring-boot项目，直接依赖一个插件就完事了，如果是其它项目需要自定义配置就是在这里配置</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>pluginManagement 的作用，就是声名，和依赖类似，一般是父pom来定义，子pom就可以直接用这个定义了</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pluginManagement</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-source-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>attach</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>attach</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executions</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>phase</span><span class="token punctuation">></span></span>compile<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>phase</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">></span></span>jar<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pluginManagement</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 子pom中 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-source-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="关于测试"><a href="#关于测试" class="headerlink" title="关于测试"></a>关于测试</h2><p>maven测试为 default 生命周期中的test阶段<br>test阶段与 maven-surefire-plugin 的test目标相绑定了， 这是一个内置的绑定<br>Maven通过插件来执行 JUnit 和 TestNG 的测试用例</p><p>maven-surefire-plugin 的test目标会自动执行测试源码路径下符合命名模式的测试类<br>默认测试源代码路径：src/test/java/<br>测试类命名模式：</p><pre class="line-numbers language-s"><code class="language-s">**/Test*.java**/*Test.java**/*TestCase.java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>按上述模式命名的类， 使用 mvn test 命令就能自动运行他们</p><h2 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h2><p>mvn install -DskipTests，不过会一直跳过测试</p><p>配置式：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-surefire-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.19.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>skipTests</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>skipTests</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--             skip 对应命令行参数为 maven.test.skip              --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>skip</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>skip</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果想不仅跳过测试运行，还跳过测试代码的编译，使用下面命令：</p><p><code>mvn package -Dmaven.test.skip=true</code><br>maven.test.skip 控制了 maven-compiler-plugin 和 maven-surefire-plugin 两个插件的行为</p><p>或借助idea，比较方便</p><h2 id="指定测试"><a href="#指定测试" class="headerlink" title="指定测试"></a>指定测试</h2><p>maven-surefire-plugin 使用 test 参数指定测试用例, 为测试用例的类名<br><code>mvn test -Dtest=RandomTest</code><br>只执行 RandomTest 这个测试类.<br><code>mvn test -Dtest=RandomTest#myTest</code><br>上面命令，只运行 RandomTest 类的 myTest 方法</p><p>可以指定多个类，逗号分隔<br><code>mvn test -Dtest=RandomTest,Random2Test</code><br>也可以用 * 匹配多个<br><code>mvn test -Dtest=Random*Test</code><br>*和 逗号可以结合使用。</p><p>如果不指定或者找不到测试类则构建失败<br><code>mvn test -Dtest</code><br>failIfNoTests 参数控制没有测试用例不报错<br><code>mvn test -Dtest -DfailIfNoTests=false</code></p><h2 id="包含测试用例"><a href="#包含测试用例" class="headerlink" title="包含测试用例"></a>包含测试用例</h2><p>将不符合命名模式测试类自动运行测试</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-surefire-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.19.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>includes</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*Tests.java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>includes</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两个星号 ** 表示匹配任意路径。<br>上面表示匹配已 Tests.java 结尾的Java类</p><h2 id="排除测试用例"><a href="#排除测试用例" class="headerlink" title="排除测试用例"></a>排除测试用例</h2><p>排除测试用例不实用test自动运行<br>使用 excludes 节点</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-surefire-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.19.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>excludes</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclude</span><span class="token punctuation">></span></span>**/*ServiceTest.java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclude</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>excludes</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="测试代码重用"><a href="#测试代码重用" class="headerlink" title="测试代码重用"></a>测试代码重用</h2><p>mvn package 会打包项目主代码和资源文件代码，没有包含测试代码。<br>如果想一起打包测试用例，供依赖方使用， 使用 maven-jar-plugin 插件</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-jar-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">></span></span>test-jar<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executions</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>maven-jar-plugin 有两个目标 jar ，test-jar,<br>jar 内置绑定在 default 生命周期的 package 阶段。<br>test-jar没有内置绑定。</p><p>依赖方引入时 dependency</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.A<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>A<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>test-jar<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要设置 type 和 scope</p><p>参考原文：<a href="https://blog.csdn.net/yonggang7/article/details/79780487" target="_blank" rel="noopener">https://blog.csdn.net/yonggang7/article/details/79780487</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2019/04/05/Java/spring/"/>
      <url>/2019/04/05/Java/spring/</url>
      
        <content type="html"><![CDATA[<p>Spring 基础概念学习总结</p><a id="more"></a><h2 id="应用服务器"><a href="#应用服务器" class="headerlink" title="应用服务器"></a>应用服务器</h2><p>SpringBoot已经内置了Servlet容器，包括tomcat，jetty，Undertow</p><h2 id="Spring基础"><a href="#Spring基础" class="headerlink" title="Spring基础"></a>Spring基础</h2><p>IoC 控制反转(Inversion of Control，缩写为IoC)：Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。<br>IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。<br><code>Spring的IoC容器就是实现控制反转和依赖注入</code></p><ul><li><p>JavaBean<br>JavaBean 是一种JAVA语言写成的可重用组件。为写成JavaBean，类必须是具体的和公共的，并且具有无参数的构造器。JavaBean 通过提供符合一致性设计模式的公共方法将内部域暴露成员属性，set和get方法获取。众所周知，属性名称符合这种模式，其他Java 类可以通过自省机制(反射机制)发现和操作这些JavaBean 的属性。</p></li><li><p>POJO<br>POJO（Plain Ordinary Java Object）简单的Java对象，实际就是普通JavaBeans，是为了避免和EJB混淆所创造的简称。<br>使用POJO名称是为了避免和EJB混淆起来, 而且简称比较直接. 其中有一些属性及其getter setter方法的类,没有业务逻辑，有时可以作为VO(value -object)或dto(Data Transform Object)来使用.当然,如果你有一个简单的运算属性也是可以的,但不允许有业务方法,也不能携带有connection之类的方法</p></li><li><p>RMI<br>RMI(Remote Method Invocation，远程方法调用)是用Java在JDK1.2中实现的，它大大增强了Java开发分布式应用的能力。Java作为一种风靡一时的网络开发语言，其巨大的威力就体现在它强大的开发分布式网络应用的能力上，而RMI就是开发百分之百纯Java的网络分布式应用系统的核心解决方案之一。其实它可以被看作是RPC的Java版本。但是传统RPC并不能很好地应用于分布式对象系统。而Java RMI 则支持存储于不同地址空间的程序级对象之间彼此进行通信，实现远程对象之间的无缝远程调用。</p></li><li><p>impl<br>全称implement是用来实现接口的</p></li></ul><h2 id="Starters"><a href="#Starters" class="headerlink" title="Starters"></a>Starters</h2><p>Starters是一系列极其方便的依赖描述，通过在你的项目中包含这些starter，你可以一站式获得你所需要的服务，而无需像以往那样copy各种示例配置及代码，然后调试，真正做到开箱即用；比如你想使用Spring JPA进行数据操作，只需要在你的项目依赖中引入spring-boot-starter-data-jpa即可</p><h2 id="Spring-properties-配置文件"><a href="#Spring-properties-配置文件" class="headerlink" title="Spring properties 配置文件"></a>Spring properties 配置文件</h2><p>通过配置文件，可以修改框架配置，或为框架提供数据，比如生成一个随机数，和框架配合后可以很方便的获取一个随机数，而不需要写更多的代码</p><p>在配置中这么写:<br>shiyanlou.springboot=Hello_shiyanlou</p><p>在控制器对象中通过注解定义shiyanlou，变量shiyanlou的值就是配置中的值Hello_shiyanlou</p><pre><code>@Value("${shiyanlou.springboot}")private String shiyanlou;</code></pre><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><p>freemarker<br>Thymeleaf<br>velocity</p><h2 id="关于controller层"><a href="#关于controller层" class="headerlink" title="关于controller层"></a>关于controller层</h2><p>有两种风格的代码，主要是注解的运用，具体看源码注释</p><ol><li>风格一</li></ol><ul><li>对主类使用@RequestMapping(“/movies”) @RestController</li><li>对方法使用@GetMapping(“/users/{id}”)</li></ul><ol start="2"><li>风格二</li></ol><ul><li>对主类使用@RequestMapping(“/brand”) @Controller</li><li>对方法使用@RequestMapping(value = “/delete/{id}”, method = RequestMethod.GET) @ResponseBody</li></ul><p>使用了RestController，就包含了Controller，ResponseBody<br>使用了GetMapping，包含了RequestMapping</p><h2 id="AOP-在-spring中的运用"><a href="#AOP-在-spring中的运用" class="headerlink" title="AOP 在 spring中的运用"></a>AOP 在 spring中的运用</h2><p>OOP面向对象，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。<br>AOP，一般称为面向切面，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。</p><p>可用于权限认证、日志、事务处理。</p><p>AOP实现的关键在于 代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。</p><p>（1）AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。<br>（2）Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p><p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：</p><ol><li><p>JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例, 生成目标类的代理对象。</p></li><li><p>如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</p></li></ol><p>（3）静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。<br>InvocationHandler 的 invoke(Objectproxy,Methodmethod,Object[] args)：proxy是最终生成的代理实例;method 是被代理目标实例的某个具体方法;args 是被代理目标实例某个方法的具体入参, 在方法反射调用时使用。</p><p>面向切面编程</p><p>在Spring中的AOP是依靠动态代理来实现切面编程的.<br>而这两者又是有区别的.</p><p>JDK是基于反射机制,生成一个实现代理接口的匿名类,然后重写方法,实现方法的增强.<br>它生成类的速度很快,但是运行时因为是基于反射,调用后续的类操作会很慢.<br>而且他是只能针对接口编程的.</p><p>CGLIB是基于继承机制,继承被代理类,所以方法不要声明为final,然后重写父类方法达到增强了类的作用.<br>它底层是基于asm第三方框架，是对代理对象类的class文件加载进来,通过修改其字节码生成子类来处理.<br>生成类的速度慢,但是后续执行类的操作时候很快.<br>可以针对类和接口。</p><p>因为jdk是基于反射,CGLIB是基于字节码.所以性能上会有差异.<br>在老版本CGLIB的速度是JDK速度的10倍左右,但是CGLIB启动类比JDK慢8倍左右,但是实际上JDK的速度在版本升级的时候每次都提高很多性能,而CGLIB仍止步不前.</p><p>在对JDK动态代理与CGlib动态代理的代码实验中看，1W次执行下，JDK7及8的动态代理性能比CGlib要好20%左右。</p><p>具体应用:<br>如果目标对象实现了接口,默认情况下是采用JDK动态实现AOP<br>如果目标对象没有实现接口,必须采用CGLIB库.</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解说明</p><h3 id="Resource和-Autowired"><a href="#Resource和-Autowired" class="headerlink" title="@Resource和@Autowired"></a>@Resource和@Autowired</h3><p>共同点</p><p>@Resource和@Autowired都可以作为注入属性的修饰，在接口仅有单一实现类时，两个注解的修饰效果相同，可以互相替换，不影响使用。</p><p>不同点，在有多个实现的时候使用要注意</p><p>@Resource是Java自己的注解，@Resource有两个属性是比较重要的，分是name和type；Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。<br>@Autowired是spring的注解，是spring2.5版本引入的，Autowired只根据type进行注入，不会去匹配name。如果涉及到type无法辨别注入对象时，那需要依赖@Qualifier或@Primary注解一起来修饰。</p><p>参考原文：<a href="https://blog.csdn.net/magi1201/article/details/82590106" target="_blank" rel="noopener">https://blog.csdn.net/magi1201/article/details/82590106</a> </p><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>@SpringBootApplication注解相当于同时使用@EnableAutoConfiguration、@ComponentScan、@Configurations三个注解  </p><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>@EnableAutoConfiguration用于打开SpringBoot自动配置，而其余注解为Spring注解，这里不再赘述</p><h3 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h3><p>@RestController相当于同时使用@Controller和@ResponseBody注解</p><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h3><p>@Configuration表示该类为配置类，该注解可以被@ComponentScan扫描到</p><h3 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h3><p>// 通过@ImportResource加载xml配置文件 配置文件放在资源目录下，注解作用于主函数入口<br>@ImportResource(value = “classpath:config.xml”)</p><h3 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a>@Transactional</h3><p>@Transactional 用于事务的注解</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>如何使用Spring Boot/Spring Cloud 实现微服务应用<br>spring Cloud是一个基于Spring Boot实现的云应用开发工具，它为基于JVM的云应用开发中的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。</p><p>Spring Cloud与Dubbo对比<br>提到Dubbo，我想顺便提下ESB，目前央视新华社也在用ESB来做任务编排，这里先比较下Dubbo和ESB：</p><p>ESB（企业数据总线），一般采用集中式转发请求，适合大量异构系统集成，侧重任务的编排，性能问题可通过异构的方式来进行规避，无法支持特别大的并发。<br>Dubbo（服务注册管理），采用的是分布式调用，注册中心只记录地址信息，然后直连调用，适合并发及压力比较大的情况；其侧重服务的治理，将各个服务颗粒化，各个子业务系统在程序逻辑上完成业务的编排。</p><p>回归主题，Spring Cloud和Dubbo又有什么不同那，首先，我们看下有什么相同之处，它们两都具备分布式服务治理相关的功能，都能够提供服务注册、发现、路由、负载均衡等。说到这，Dubbo的功能好像也就这么多了，但是Spring Cloud是提供了一整套企业级分布式云应用的完美解决方案，能够结合Spring Boot，Docker实现快速开发的目的，所以说Dubbo只有Spring Cloud的一部分RPC功能，而且也谈不上谁好谁坏。不过，Dubbo项目现已停止了更新，淘宝内部由hsf替代dubbo，我想这会有更多人倾向Spring Cloud了。</p><p>从开发角度上说，Dubbo常与Spring、zookeeper结合，而且实现只是通过xml来配置服务地址、名称、端口，代码的侵入性是很小的，相对Spring Cloud，它的实现需要类注解等，多少具有一定侵入性。</p><p>ESB（Enterprise Service Bus）全名：企业服务总线，是SOA架构思想的一种实现思路</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>G2</title>
      <link href="/2019/04/05/JavaScript/G2/"/>
      <url>/2019/04/05/JavaScript/G2/</url>
      
        <content type="html"><![CDATA[<p>G2，一种全新的画图工具，有自己的一套设计语言</p><a id="more"></a><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Chart-对象和-View-对象"><a href="#Chart-对象和-View-对象" class="headerlink" title="Chart 对象和 View 对象"></a>Chart 对象和 View 对象</h3><p>G2 的图表可以由多个视图 View 构成，同时各个视图可以拥有各自的数据源，即支持异构数据。在结构上，视图和 chart 相同，拥有自己独立的数据源、坐标系和图层。<br>Chart 是一种特殊的View，两者之间也有一定的差异：<br>View 的功能 Chart 都具有<br>Tooltip（提示信息）和 Legend（图例）仅在 Chart 上支持<br>Chart 上可以创建 View ，但是 View 不再支持创建子 View</p><p>视图，由 Chart 生成和管理，拥有自己独立的数据源、坐标系和图层，用于异构数据的可视化以及图表组合，一个 Chart 由一个或者多个视图 View 组成。因此 view 上的 api 同 chart 基本相同。</p><h3 id="关注数据Data和Scale度量两个重要概念"><a href="#关注数据Data和Scale度量两个重要概念" class="headerlink" title="关注数据Data和Scale度量两个重要概念"></a>关注数据Data和Scale度量两个重要概念</h3><p>列定义：操作度量Scale称为列定义</p><p>Geom几何标记：决定最后画出来的是什么图形，与之相关的是图形属性Attr</p><p>Attr图形属性</p><ol><li>position：位置，二维坐标系内映射至 x 轴、y 轴；</li><li>color：颜色，包含了色调、饱和度和亮度；</li><li>size：大小，不同的几何标记对大小的定义有差异；</li><li>shape：形状，几何标记的形状决定了某个具体图表类型的表现形式，例如点图，可以使用圆点、三角形、图片表示；线图可以有折线、曲线、点线等表现形式；</li><li>opacity：透明度，图形的透明度，这个属性从某种意义上来说可以使用颜色代替，需要使用 ‘rgba’ 的形式，所以在 G2 中我们独立出来。</li></ol><p>其中shape是重要的关注点</p><p>Legend图列：图表辅助元素，使用颜色、大小、形状区分不同的数据类型，用于图表中数据的筛选</p><p>Guide辅助元素：在图表上添加额外的注解，比如加辅助线，文本</p><h2 id="DataSet"><a href="#DataSet" class="headerlink" title="DataSet"></a>DataSet</h2><p>Transform 数据变换函数，数据视图做数据处理时使用，包括图布局、数据补全、数据过滤等等</p><p>通过type决定如何处理数据，fold用于数据字段展开，filter用于数据过滤等</p><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p>图表自适应</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> chart <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">G2<span class="token punctuation">.</span>Chart</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  container<span class="token punctuation">:</span> <span class="token string">'c1'</span><span class="token punctuation">,</span>  forceFit<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  height <span class="token punctuation">:</span> <span class="token number">400</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>坐标轴格式化</p><pre class="line-numbers language-js"><code class="language-js">chart<span class="token punctuation">.</span><span class="token function">axis</span><span class="token punctuation">(</span><span class="token string">'field'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  label<span class="token punctuation">:</span> <span class="token punctuation">{</span>    formatter<span class="token punctuation">:</span> val <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> val <span class="token operator">+</span> <span class="token string">'k'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vagrant 运用</title>
      <link href="/2019/04/05/Linux/vagrant/"/>
      <url>/2019/04/05/Linux/vagrant/</url>
      
        <content type="html"><![CDATA[<p>虚拟机是学习分布式道路上逃不过的一环，即使你用Mac来开发，掌握虚拟机，把服务跑在虚拟机里面仍然是很有必要的，有些公司就以虚拟机为工作环境，保证线上和线下的一直性。vagrant是虚拟机API工具，可以很方便的管理和使用虚拟机。通过不断的销毁和创建虚拟机，总结了一些经验。总之，还是涉及到的知识太多，以及对Linux和网络相关的知识不熟悉，利用虚拟机API，可以帮助你更快的进行实践，不过硬盘表示很遭罪</p><a id="more"></a><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>vagrant init 加 box name 通过box name 在当前目录创建VagrantFile，如果本地没有box就使用服务器上的<br>box 下载后的目录 <code>~/.vagrant.d/boxes</code>，这个box就是基础镜像，只要有这个box，就可以创建多个虚拟机，虚拟机保存在<code>VirtualBox VMs</code>目录下(Mac系统)</p><p>vagrant package 对当前环境进行打包<br><code>vagrant box add hahaha ~/box/package.box  # 添加 package.box 镜像并命名为 hahaha</code></p><p>这里添加的box可以在 <code>~/.vagrant.d/boxes</code> 找到</p><p>vagrant up 使用已有的文件创建虚拟机，后面加上文件夹路径</p><p>vagrant box 加其它命令，管理box，例如 vagrant box list</p><pre class="line-numbers language-s"><code class="language-s">$ vagrant init      # 初始化$ vagrant up        # 启动虚拟机$ vagrant halt      # 关闭虚拟机$ vagrant reload    # 重启虚拟机$ vagrant ssh       # SSH 至虚拟机$ vagrant suspend   # 挂起虚拟机$ vagrant resume    # 唤醒虚拟机$ vagrant status    # 查看虚拟机运行状态$ vagrant destroy   # 销毁当前虚拟机#box管理命令$ vagrant box list    # 查看本地box列表$ vagrant box add     # 添加box到列表$ vagrant box remove  # 从box列表移除<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="解决无法共享目录的问题"><a href="#解决无法共享目录的问题" class="headerlink" title="解决无法共享目录的问题"></a>解决无法共享目录的问题</h2><p>一般在官方下载别人做好的box，发现有些box无法共享目录，有些可以。在Windows上竟然没有报错，Mac上会有错误提示。升级内核后，也会导致无法共享目录，应该也是增强软件因为升级的关系没了。</p><p>可能和系统有关，ubuntu解决方案</p><pre><code>sudo apt-get updatesudo apt-get install virtualbox-guest-utils</code></pre><p>解决过程很简单，貌似我下了Ubuntu box没有无法共享目录的情况</p><p>centos 先进入虚拟机，安装软件，可能是为了编译用吧</p><pre><code>sudo yum updatesudo yum install gccsudo yum install kernel-devel</code></pre><p>然后加载镜像，并挂载它，执行（box文件是vagrant官方下载比较多的一个版本，就发现了这个无法共享目录的问题）</p><pre><code>sudo find / -name VBoxGuestAdditions.iso 在mac中，找到镜像，复制到容易发现的目录，比如下载目录mount VBoxGuestAdditions.iso的目录(虚拟机里面要有这个文件)，这一步是挂载命令，挂载由于本身目录就不共享了，所以也可以用virtualBox来加载镜像（加载在mac中找到的镜像，镜像位于软件安装包中，可以用find命令查找具体路径），记得先关闭虚拟机通过命令或virtualBox，完成镜像挂载后，重新进入虚拟机通过命令查看挂载情况lsscsi (适用于centos7)  yum install lsscsi 没有就安装一下lsblk  (适用于ubuntu)结果[0:0:0:0]    disk    ATA      VBOX HARDDISK    1.0   /dev/sda[0:0:1:0]    cd/dvd  VBOX     CD-ROM           1.0   /dev/sr0可以看到，镜像已被挂载到/dev/sr0这个设备了sudo mount /dev/sr0 /media/cdrom/dev/sr0 是通过命令看到的，把sr0挂载到自己创建的目录/media/cdromcd 到该目录sudo ./VBoxLinuxAdditions.run退出虚拟机，重启即可(启动虚拟，没有报错，文件也能共享就是成功了)</code></pre><p>最好把软件安装了再加载镜像，可能有些box已经有了软件不需要安装。</p><h2 id="解决网络问题，无法解析主机"><a href="#解决网络问题，无法解析主机" class="headerlink" title="解决网络问题，无法解析主机"></a>解决网络问题，无法解析主机</h2><p>通过vagrant下载的centos Box，默认设置，在mac上可以访问网络，在windows上就不行，不知道是不是公司网络的原因</p><p>通过设置dns解决了，在/etc/resolv.conf添加一个nameserver 8.8.8.8，执行sudo yum clean all &amp;&amp; sudo yum makecache</p><p>加了8.8.8.8还不行，nameserver 114.114.114.114 加上</p><p>确实是网络问题导致dns无法解析，上面的配置也不一定每次都好使</p><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><p>默认情况下，采用Provider的NAT网络模式，在虚拟机中可以访问宿主机，也可以使用宿主机的外网路由上网。<br>virtual Box 可以设置很多的网络模式，不过这里要从vagrant来看，分为三种</p><ol><li><p>Forwarded port(端口映射)<br>config.vm.network “forwarded_port”, guest: 80, host: 8080<br>采用端口映射从主机特定端口访问虚拟机</p></li><li><p>Private network(私有网络)<br>config.vm.network “private_network”, ip: “192.168.1.4” # 固定IP<br>config.vm.network “private_network”, type: “dhcp” # 由路由器分配</p></li></ol><p>只有主机可以访问虚拟机，如果多个虚拟机设置定在同一个网段也可以相互访问，虚拟机也是可以访问外部网络</p><ol start="3"><li>Public network(公有网络)</li></ol><p>config.vm.network “public_network”, ip: “192.168.1.4”<br>config.vm.network “public_network”, type: “dhcp”</p><p>相当于把虚拟机加入当前子网络</p><p>测试：修改配置文件，使用私有网络，然后利用python启动文件服务器 <code>python -m SimpleHTTPServer</code> or <code>python -m http.server 8080(py3)</code> 在外部通过设置的ip加默认文件服务的端口8000访问，成功代表网络设置正确</p><p>虚拟机通过 ip address 可以看到，拥有三个网络了</p><h2 id="使用root用户"><a href="#使用root用户" class="headerlink" title="使用root用户"></a>使用root用户</h2><p>sudo passwd root</p><p>输入密码，不要太短，两次后确认（vagrant默认的root用户密码是vagrant，如果不更改密码，可以不执行这一步）</p><p>su root </p><p>切换到root用户</p><p>测试使用配置文件修改用户为root等设置后，无法启动系统，不知道是不是vagrant BUG，如果要用root用户，连接后切换，如果是非windows系统，配置好root用户后，通过ssh来连接放弃vagrant ssh的方式</p><h2 id="关于ssh相关问题"><a href="#关于ssh相关问题" class="headerlink" title="关于ssh相关问题"></a>关于ssh相关问题</h2><p>既然是为了学习分布式，很多工具都需要通过ssh控制目标机，保证ssh的连接正确性是关键的第一步。</p><p>ssh登录处在相同子网的其它服务器，直接复制公钥到目标机就行了，然而这一招在root用户下不管用了（之所以直接复制，也是一开对机制不熟悉，如果有上百台机器，肯定只能用命令），这里猜测还是流程上不标准吧，正确的处理应该是修改需要连接的目标机的sshd，即ssh服务端配置，允许使用公钥的方式，配置文件不满足要求的，就去修改它</p><p>有一个很重要的概念：<br>当主机中开启openssh服务，那么就对外开放了远程连接的接口，ssh为openssh服务的客户端，sshd为openssh服务的服务端<br>ssh和sshd的差别，一定要牢记，不要混淆，别人连接你，你要修改的是服务端的配置<br>注意sshd只有root用户组的才有读写权限，其它都没有</p><p>相关命令</p><pre class="line-numbers language-s"><code class="language-s">systemctl restart sshd.servicesystemctl status sshd.service #查看ssh服务的状态systemctl start sshd.service  #开启ssh服务sytemctl enable sshd.service #ssh服务随开机启动，还有个disabledsystemctl stop sshd.ervice #停止正常情况下应该是Active：active（running）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>权限配置</p><pre class="line-numbers language-s"><code class="language-s">chmod 700 /home/Hadoop/.sshchmod 644 /home/Hadoop/.ssh/authorized_keys如果权限不对，会导致文件无法读取导致失败，还有这些配置是跟着各个用户走的，它们的用户组也必须正确<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>关于配置文件，一般关注的是服务端的配置文件，以及几个常用的参数</p><p>PermitRootLogin no<br>“PermitRootLogin”设置是否允许root通过ssh登录。这个选项从安全角度来讲应设成”no”。</p><p>RSAAuthentication yes<br>“RSAAuthentication”设置是否允许只有RSA安全验证。</p><p>PasswordAuthentication yes<br>“PasswordAuthentication”设置是否允许口令验证。</p><p>PermitEmptyPasswords no<br>“PermitEmptyPasswords”设置是否允许用口令为空的帐号登录。</p><p>AllowUsers admin   #限定登录的用户名<br>“AllowUsers”的后面可以跟任意的数量的用户名的匹配串，这些字符串用空格隔开。主机名可以是域名或IP地址。</p><p>以上是关于ssh相关的知识，正常来说，ssh连接目标机器，然后输入密码就行了，这是正常情况，如果不行，那么可能是配置文件被修改了，或是权限的问题，如果这些处理了，肯定是一些吊毛情况，建议卸载了重新安装，另外通过手动复制公钥到目标机的做法不一定每次都行，我就遇到过通过命令无法实现，然后手动复制可以了，但是对于root用户就不行。</p><p>重装方法</p><p>yum -y remove openssh-server<br>yum -y install openssh-server</p><p>执行 /usr/sbin/sshd 启动服务（使用此方法重装后，systemctl和服务相关的命令有问题，通过测试发现，如果要修改配置，修改后执行/usr/sbin/sshd就会生效，整个服务默认是开机启动的，测试的不是很全面，可以查找相关资料了解一下）</p><p>ssh-keygen<br>ssh-copy-id <a href="mailto:root@192.168.59.102" target="_blank" rel="noopener">root@192.168.59.102</a></p><p>不同身份的用户都需要执行这两步，上面只是让root用户可以连接，vagrant也需要执行一次，就是说不同的用户要用自己的公钥</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java review</title>
      <link href="/2019/04/05/Other/rrdtool/"/>
      <url>/2019/04/05/Other/rrdtool/</url>
      
        <content type="html"><![CDATA[<p>review</p><a id="more"></a><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>liuzhidream<span class="token punctuation">.</span>rrdtool<span class="token punctuation">.</span>service<span class="token punctuation">.</span>rrdtool<span class="token punctuation">;</span><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>SneakyThrows<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>rrd4j<span class="token punctuation">.</span>ConsolFun<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>rrd4j<span class="token punctuation">.</span>DsType<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>rrd4j<span class="token punctuation">.</span>core<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Description * @Author VanLiuZhi * @Date 2020-02-14 17:06 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RrdToolUtil</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1000</span><span class="token punctuation">;</span>        RrdDef rrdDef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RrdDef</span><span class="token punctuation">(</span><span class="token string">"./test2.rrd"</span><span class="token punctuation">,</span> start<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        rrdDef<span class="token punctuation">.</span><span class="token function">addDatasource</span><span class="token punctuation">(</span><span class="token string">"users"</span><span class="token punctuation">,</span> DsType<span class="token punctuation">.</span>GAUGE<span class="token punctuation">,</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> Double<span class="token punctuation">.</span>NaN<span class="token punctuation">)</span><span class="token punctuation">;</span>        rrdDef<span class="token punctuation">.</span><span class="token function">addDatasource</span><span class="token punctuation">(</span><span class="token string">"devices"</span><span class="token punctuation">,</span> DsType<span class="token punctuation">.</span>GAUGE<span class="token punctuation">,</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> Double<span class="token punctuation">.</span>NaN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/** 每分钟一个存档, 两年共计 2*365*24*60 */</span>        rrdDef<span class="token punctuation">.</span><span class="token function">addArchive</span><span class="token punctuation">(</span>ConsolFun<span class="token punctuation">.</span>AVERAGE<span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">365</span> <span class="token operator">*</span> <span class="token number">24</span> <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/** 每小时一个存档, 两年共计2*365*24 */</span>        rrdDef<span class="token punctuation">.</span><span class="token function">addArchive</span><span class="token punctuation">(</span>ConsolFun<span class="token punctuation">.</span>AVERAGE<span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">365</span> <span class="token operator">*</span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/** 每天一个存档, 两年共计2*365 */</span>        rrdDef<span class="token punctuation">.</span><span class="token function">addArchive</span><span class="token punctuation">(</span>ConsolFun<span class="token punctuation">.</span>AVERAGE<span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">24</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">365</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        RrdDb rrdDb <span class="token operator">=</span> RrdDb<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>rrdDef<span class="token punctuation">)</span><span class="token punctuation">;</span>        rrdDb<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token keyword">final</span> RrdDb rrdDb <span class="token operator">=</span> RrdDb<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"./test2.rrd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> Random random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Timer timer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        timer<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TimerTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@SneakyThrows</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Sample sample <span class="token operator">=</span> rrdDb<span class="token punctuation">.</span><span class="token function">createSample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">long</span> time <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1000</span><span class="token punctuation">;</span>                sample<span class="token punctuation">.</span><span class="token function">setTime</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span>                sample<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span><span class="token string">"users"</span><span class="token punctuation">,</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                sample<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span><span class="token string">"devices"</span><span class="token punctuation">,</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                sample<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sample<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token keyword">final</span> RrdDb rrdDb <span class="token operator">=</span> RrdDb<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"./test2.rrd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        FetchRequest request <span class="token operator">=</span> rrdDb<span class="token punctuation">.</span><span class="token function">createFetchRequest</span><span class="token punctuation">(</span>                ConsolFun<span class="token punctuation">.</span>AVERAGE<span class="token punctuation">,</span>                Util<span class="token punctuation">.</span><span class="token function">getTimestamp</span><span class="token punctuation">(</span><span class="token number">2020</span><span class="token punctuation">,</span> Calendar<span class="token punctuation">.</span>FEBRUARY<span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                Util<span class="token punctuation">.</span><span class="token function">getTimestamp</span><span class="token punctuation">(</span><span class="token number">2020</span><span class="token punctuation">,</span> Calendar<span class="token punctuation">.</span>FEBRUARY<span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        FetchData fetchData <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values <span class="token operator">=</span> fetchData<span class="token punctuation">.</span><span class="token function">getValues</span><span class="token punctuation">(</span><span class="token string">"users"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>values<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        RrdToolUtil rrdToolUtil <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RrdToolUtil</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        rrdToolUtil<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        rrdToolUtil.fetch();</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java review Spring</title>
      <link href="/2019/04/05/Review/problem/"/>
      <url>/2019/04/05/Review/problem/</url>
      
        <content type="html"><![CDATA[<p>review</p><a id="more"></a><h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><p>先了解一个概念，取模和取余，如果除数都是正整数，那么取余和取模都是一样的，求余数<br>当 x 和 y 的正负号一样的时候，两个函数结果是等同的；当 x 和 y 的符号不同时，rem函数结果的符号和 x 的一样，而 mod 和 y 一样</p><p>在分布式中，或者用分库分表来说明，user表存在在3台机器上，用<code>用户id的hashcode % 3</code>来决定该用户的数据存储在哪台机器上。当机器增加到4台的时候，此时的模3就不对了，造成数据混乱。而一致性哈希算法就是解决这个问题的，一致性哈希保证当分布式环境的节点增加的时候，原来请求分配到的节点还是原来的节点</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 有5个用户</span>    Integer a <span class="token operator">=</span> <span class="token number">123456</span><span class="token punctuation">;</span>    Integer b <span class="token operator">=</span> <span class="token number">123457</span><span class="token punctuation">;</span>    Integer c <span class="token operator">=</span> <span class="token number">123458</span><span class="token punctuation">;</span>    Integer d <span class="token operator">=</span> <span class="token number">123459</span><span class="token punctuation">;</span>    Integer e <span class="token operator">=</span> <span class="token number">123460</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 平均分配到3台机器</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"--------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 平均分配到4台机器</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//        结果</span>    <span class="token comment" spellcheck="true">//        0</span>    <span class="token comment" spellcheck="true">//        1</span>    <span class="token comment" spellcheck="true">//        2</span>    <span class="token comment" spellcheck="true">//        0</span>    <span class="token comment" spellcheck="true">//        1</span>    <span class="token comment" spellcheck="true">//                --------------</span>    <span class="token comment" spellcheck="true">//        0</span>    <span class="token comment" spellcheck="true">//        1</span>    <span class="token comment" spellcheck="true">//        2</span>    <span class="token comment" spellcheck="true">//        3</span>    <span class="token comment" spellcheck="true">//        0</span>    <span class="token comment" spellcheck="true">// 对于d,e来说，增加机器的时候就错乱了</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="http无状态"><a href="#http无状态" class="headerlink" title="http无状态"></a>http无状态</h2><p>这句话体现在每个请求都是独立的，第二次的请求和第一次不会有关联</p><h2 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h2><p>1、加密和解密过程不同</p><p>对称加密过程和解密过程使用的同一个密钥，加密过程相当于用原文+密钥可以传输出密文，同时解密过程用密文-密钥可以推导出原文。但非对称加密采用了两个密钥，一般使用公钥进行加密，使用私钥进行解密。</p><p>2、加密解密速度不同</p><p>对称加密解密的速度比较快，适合数据比较长时的使用。非对称加密和解密花费的时间长、速度相对较慢，只适合对少量数据的使用。</p><p>3、传输的安全性不同</p><p>对称加密的过程中无法确保密钥被安全传递，密文在传输过程中是可能被第三方截获的，如果密码本也被第三方截获，则传输的密码信息将被第三方破获，安全性相对较低。<br>非对称加密算法中私钥是基于不同的算法生成不同的随机数，私钥通过一定的加密算法推导出公钥，但私钥到公钥的推导过程是单向的，也就是说公钥无法反推导出私钥。所以安全性较高。</p><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>tcc lcn mq atomik seata</p><h2 id="分布式session"><a href="#分布式session" class="headerlink" title="分布式session"></a>分布式session</h2><p>Spring-boot-statrte-data-redis</p><h2 id="静态化"><a href="#静态化" class="headerlink" title="静态化"></a>静态化</h2><p>velocity freemarker 模板引擎</p><h2 id="基本服务容器配置"><a href="#基本服务容器配置" class="headerlink" title="基本服务容器配置"></a>基本服务容器配置</h2><h3 id="nnginx"><a href="#nnginx" class="headerlink" title="nnginx"></a>nnginx</h3><p>docker run -p 80:80 –name nginx <br>-v /Users/liuzhi/mydata/nginx/html:/usr/share/nginx/html <br>-v /Users/liuzhi/mydata/nginx/logs:/var/log/nginx  <br>-d nginx:1.10</p><p>docker run -p 8091:80 –name nginx <br>-v /Users/liuzhi/mydata/nginx/html:/usr/share/nginx/html <br>-v /Users/liuzhi/mydata/nginx/logs:/var/log/nginx  <br>-v /Users/liuzhi/mydata/nginx/conf:/etc/nginx <br>-d nginx:1.10</p><h3 id="rabbitmq"><a href="#rabbitmq" class="headerlink" title="rabbitmq"></a>rabbitmq</h3><p>docker run -d –name rabbitmq <br>–publish 5671:5671 –publish 5672:5672 –publish 4369:4369 <br>–publish 25672:25672 –publish 15671:15671 –publish 15672:15672 <br>rabbitmq:3.7.15</p><h3 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h3><p>docker run -p 9200:9200 -p 9300:9300 –name elasticsearch <br>-e “discovery.type=single-node” <br>-e “cluster.name=elasticsearch” <br>-d elasticsearch:6.4.0</p><p>docker run -p 9201:9200 –name elasticsearch2 <br>-d elasticsearch:5.2.2</p><p>docker run -p 9200:9200 -p 9300:9300 –name elasticsearch-5 <br>-e “discovery.type=single-node” <br>-e “cluster.name=elasticsearch” <br>-d elasticsearch:5.2.2</p><h3 id="mongo"><a href="#mongo" class="headerlink" title="mongo"></a>mongo</h3><p>docker run -p 27017:27017 –name mongo-4-2-3 <br>-v /Users/liuzhi/mydata/mongo-4-2-3/db:/data/db <br>-d mongo:4.2.3</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>docker run –name redis-5.7 –requirepass “$123qwe” -p 6377:6379 redis:5.0.7-buster</p><p>appendonly yes 开启持久化，数据存储在data目录，所以这个目录要映射出来，不然重启数据丢失，持久化就没有意义</p><p>docker run -p 6377:6379 –name redis-5.7 <br>-v /Users/liuzhi/mydata/redis/data:/data <br>-d redis:5.0.7-buster redis-server –appendonly yes –requirepass “qweEX123”</p><p>docker run –name redis -d redis:5.0.7-buster -p 6379:6379 –requirepass “qweEX123”</p><p>docker run –name redis-3.2 -p 6479:6379 -d redis:3.2 </p><h3 id="mysql-启动容器时区配置"><a href="#mysql-启动容器时区配置" class="headerlink" title="mysql 启动容器时区配置"></a>mysql 启动容器时区配置</h3><p>docker run –name mysql2 -p 3506:3306 \<br>-e MYSQL_ROOT_PASSWORD=test123456 \<br>-e TZ=Asia/Shanghai -d mysql:5.7 \<br>–default-time_zone=’+8:00’</p><p>docker run -p 5506:3306 –name mysql-5.7-docker <br>-v /data/mysql-docker/log:/var/log/mysql <br>-v /data/mysql-docker/data:/var/lib/mysql <br>-v /data/mysql-docker/conf:/etc/mysql <br>-e MYSQL_ROOT_PASSWORD=root123456  <br>-d hub.eos.h3c.com/base/mysql:5.7.24 <br>–default-time_zone=’+8:00’</p><p>可以用TZ改时区，默认是UTC TZ=Asia/Shanghai 改成CST<br>记得一定加default-time_zone</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p><code>public boolean equalsIgnoreCase(String anotherString)</code> 字符串对象调用，和一个字符串比较，不区分大小写</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java review 散问题</title>
      <link href="/2019/04/05/Review/Overview/"/>
      <url>/2019/04/05/Review/Overview/</url>
      
        <content type="html"><![CDATA[<p>review</p><a id="more"></a><h2 id="待处理"><a href="#待处理" class="headerlink" title="待处理"></a>待处理</h2><p>接口幂等性：</p><ol><li>全局唯一ID</li><li>去重表</li><li>状态机</li></ol><p>创建多线程有几种方式？</p><p>UDP是基于报文发送的，从UDP的帧结构可以看出，在UDP首部采用了16bit来指示UDP数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。</p><p>redission实现的分布式锁，同学们可以看一下，解决了传统分布式锁续约的问题。</p><p>redis做分布式锁，如果是集群，主节点在同步到从节点前挂掉，如何保证锁的互斥性？这个面试的时候经常问，面试官想考察的点是redlock(红锁)</p><p>1.用zookeeper创建一个临时节点代表锁，比如在/exlusive_lock下创建临时顺序子节点/exlusive_lock/lock。<br>2.所有客户端争相创建此节点，但只有一个客户端创建成功。<br>3.创建成功代表获取锁成功，此客户端执行业务逻辑<br>4.未创建成功的客户端，监听/exlusive_lock变更<br>5.获取锁的客户端执行完成后，删除/exlusive_lock/lock，表示锁被释放<br>6.锁被释放后，其他监听/exlusive_lock变更的客户端得到通知，再次争相创建临时子节点/exlusive_lock/lock。此时相当于回到了第2步。</p><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>ServiceMesh(服务网格)</p><p>RMI（Remote Method Invocation）远程方法调用。能够让在客户端Java虚拟机上的对象像调用本地对象一样调用服务端java 虚拟机中的对象上的方法。使用代表：EJB</p><p>RPC（Remote Procedure Call Protocol）远程过程调用协议，通过网络从远程计算机上请求调用某种服务。它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。 使用代表：Dubbo</p><p>CAP原则<br>一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）</p><p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写</p><p>ACID<br>原子性（atomicity)<br>一致性（consistency)<br>隔离性（isolation）<br>持久性（durability）</p><ol><li>传统集中式代理:基于反向代理的中心化架构</li><li>客户端嵌入式代理:嵌入应用内部的去中心化架构</li><li>主机独立进程代理 :基于独立代理进程的Service Mesh架构</li></ol><p>Nginx7层，硬件4层</p><h2 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h2><p>//一般讨论集合类无非就是。这里的两种数组类型更是如此<br>// 1底层数据结构<br>// 2增删改查方式<br>// 3初始容量，扩容方式，扩容时机。<br>// 4线程安全与否<br>// 5是否允许空，是否允许重复，是否有序 </p><p>普通的集合类，迭代的时候，其它线程修改了容器，会直接触发fail-fast<br>线程安全的集合类才能在迭代的时候修改容器</p><h2 id="常用包"><a href="#常用包" class="headerlink" title="常用包"></a>常用包</h2><dependency>    <groupid>commons-codec</groupid>    <artifactid>commons-codec</artifactid></dependency><dependency>    <groupid>org.apache.commons</groupid>    <artifactid>commons-lang3</artifactid>    <version>3.7</version></dependency><dependency>    <groupid>com.google.guava</groupid>    <artifactid>guava</artifactid>    <version>23.0</version></dependency><dependency>    <groupid>org.projectlombok</groupid>    <artifactid>lombok</artifactid>    <version>1.16.18</version>    <optional>true</optional></dependency><!--A set of annotations used for code inspection support and code documentation.--><dependency>    <groupid>org.jetbrains</groupid>    <artifactid>annotations</artifactid>    <version>18.0.0</version>    <scope>compile</scope></dependency><!--security--><dependency>    <groupid>org.springframework.boot</groupid>    <artifactid>spring-boot-starter-security</artifactid></dependency><!--配置文件转换支持，主要是旧体系框架向Spring boot转换--><dependency>    <groupid>org.springframework.boot</groupid>    <artifactid>spring-boot-configuration-processor</artifactid>    <optional>true</optional></dependency><h1 id="problem-遇到的问题大汇总"><a href="#problem-遇到的问题大汇总" class="headerlink" title="problem 遇到的问题大汇总"></a>problem 遇到的问题大汇总</h1><ol><li><p>泊松分布<br>泊松分布的参数λ是单位时间(或单位面积)内随机事件的平均发生次数。 泊松分布适合于描述单位时间内随机事件发生的次数。</p></li><li><p>concurrentHashMap锁分段的思想是怎么做的？</p></li><li><p>CAS算法是什么？<br>参考 <a href="https://zhuanlan.zhihu.com/p/93418208" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/93418208</a></p></li><li><p>下面的main中，调用方法A创建了线程，然后执行方法B，谁先执行？</p></li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// run 中执行方法A</span>        instance<span class="token punctuation">.</span><span class="token function">BMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正常情况下，方法B先执行。主线程启动起来，因为创建线程等的资源消耗，所以主线程会先执行，然后才到子线程，也不排斥代码复杂的情况下，子线程准备就绪，先main线程执行</p><ol start="4"><li><p>操作系统中，CPU竞争有很多种策略。Unix系统使用的是时间片算法，而Windows则属于抢占式的</p></li><li><p>Thread.Sleep() Thread.Sleep(0)</p></li></ol><p>sleep是当前线程告诉操作系统放弃cpu资源竞争多长时间，参数0的话，触发操作系统立刻重新进行一次CPU竞争，让其它线程有机会获取到CPU资源</p><ol start="6"><li><p>如何用jstack分析程序？<br><a href="https://www.jianshu.com/p/dee9d02f11b3" target="_blank" rel="noopener">https://www.jianshu.com/p/dee9d02f11b3</a></p></li><li><p>如何用Java Dump分析堆内存？</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka 学习笔记</title>
      <link href="/2019/03/19/Web/Kafka/"/>
      <url>/2019/03/19/Web/Kafka/</url>
      
        <content type="html"><![CDATA[<p>消息队列Kafka</p><a id="more"></a><h2 id="基础概念和术语"><a href="#基础概念和术语" class="headerlink" title="基础概念和术语"></a>基础概念和术语</h2><p><strong>Partition</strong> 分区，Partition是物理上的概念，每个Topic包含一个或多个Partition</p><p><strong>Consumer</strong> 消费者 向Kafka broker读取消息的客户端<br>Consumer Group<br>每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）</p><p><strong>Topic</strong> 每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</p><p><strong>Broker</strong> Kafka集群包含一个或多个服务器，这种服务器被称为broker</p><p><strong>Producer</strong> 负责发布消息到Kafka broker</p><p>无法保证消息在一个主题内的顺序，但是可以保证消息在一个分区内的顺序，每个Partition在物理上对应一个文件夹，该文件夹下存储这个Partition的所有消息和索引文件</p><p><code>数据结构</code>: 每个日志文件都是一个log entry序列，每个log entry包含一个4字节整型数值（值为N+5），1个字节的”magic value”，4个字节的CRC校验码，其后跟N个字节的消息体。每条消息都有一个当前Partition下唯一的64字节的offset，它指明了这条消息的起始位置。磁盘上存储的消息格式如下：<br>message length ： 4 bytes (value: 1+4+n)<br>“magic” value ： 1 byte<br>crc ： 4 bytes<br>payload ： n bytes</p><p>存储文件展示(一个topic下的文件)</p><p><img src="/images/Web/kafka/kafka-3.png" alt="image"></p><p><code>偏移量</code>：每条消息都有一个当前Partition下唯一的64字节的offset，它指明了这条消息的起始位置。从这个偏移量就可以知道消息在硬盘中的位置</p><p>因为每条消息都被append到该Partition中，属于顺序写磁盘，因此效率非常高（经验证，顺序写磁盘效率比随机写内存还要高，这是Kafka高吞吐率的一个很重要的保证）</p><p><code>高性能</code>: 因为Kafka读取特定消息的时间复杂度为O(1)，即与文件大小无关，所以删除过期文件与提高Kafka性能无关。选择怎样的删除策略只与磁盘以及具体的需求有关。另外，Kafka会为每一个Consumer Group保留一些metadata信息—-当前消费的消息的position，也即offset。这个offset由Consumer控制。正常情况下Consumer会在消费完一条消息后递增该offset。当然，Consumer也可将offset设成一个较小的值，重新消费一些消息。因为offet由Consumer控制，所以Kafka broker是无状态的，它不需要标记哪些消息被哪些消费过，也不需要通过broker去保证同一个Consumer Group只有一个Consumer能消费某一条消息，因此也就不需要锁机制，这也为Kafka的高吞吐率提供了有力保障</p><p>Producer发送消息到broker时，会根据Paritition机制选择将其存储到哪一个Partition。如果Partition机制设置合理，所有消息可以均匀分布到不同的Partition里，这样就实现了<code>负载均衡</code>。如果一个Topic对应一个文件，那这个文件所在的机器I/O将会成为这个Topic的性能瓶颈，而有了Partition后，不同的消息可以并行写入不同broker的不同Partition里，极大的提高了吞吐率</p><p><code>消费组</code>：如果需要实现多播，只要每个Consumer有一个独立的Group就可以了。要实现单播，只要所有的Consumer在同一个Group里。一个Group中的多个consumer不能同时消费一个分区，严格来说kafka不支持广播，rocketMQ可以广播</p><p>为了保证高可用，<code>副本数会被分配到其它broker上</code>。就是当只有一个broker的时候，你不能创建分区的2个副本，kafk会把一个副本放到另一个分区上保证高可用。分区数量不受broker影响，主要是副本数</p><p><code>副本与分区</code>: 关于这个副本与分区还要再强调一点，当我们设置一个分区的时候，不配置副本，此时副本数就是1，其实也就是分区数。 在broker中，会有一个partition，如果我们副本配置2，那么总共会看到2个partition，即partition_0，partition_1，其中一个是leader，一个是follower。所以副本设置1，或者不设置，分区就是一个，设置2，才会有2个分区。<code>broker中最多只能保存一个副本</code>。<br><strong>重点来了</strong>: 当有2个broker，不能创建3个分区，系统报错；但是当我们有3个broker的时候，创建3个分区，然后停止一个broker，系统不会报错，被停止的broker上的分区进入到不可用状态</p><p>如下图通过命令可以看到副本和分区在broker中的分布情况</p><p><img src="/images/Web/kafka/kafka-1.png" alt="image"></p><p><code>Isr</code> isr(In-Sync Replicas)是分区的子集，表示副本的存活数，3个broker，我们踢出一个broker后，原来三个分区分布在3个broker上，现在只存活着2个</p><p>如图</p><p><img src="/images/Web/kafka/kafka-2.png" alt="image"></p><p><code>线程安全</code>: producer是线程安全的，consumer不是，consumer不能多线程操作，但是可以多线程用一个消费组，这是没有影响的</p><h2 id="关于官网"><a href="#关于官网" class="headerlink" title="关于官网"></a>关于官网</h2><p><a href="http://kafka.apachecn.org/" target="_blank" rel="noopener">http://kafka.apachecn.org/</a> 中文</p><p><a href="http://kafka.apache.org/" target="_blank" rel="noopener">http://kafka.apache.org/</a>   英文</p><h2 id="版本的改进"><a href="#版本的改进" class="headerlink" title="版本的改进"></a>版本的改进</h2><p>Kafka 0.8 之后引入了副本机制， Kafka 成为了一个分布式高可靠消息队列解决方案。<br>0.8.2.0 版本社区引入了新版本 Producer API ， 需要指定 Broker 地址，但是bug比较多<br>0.9.0.0 版本增加了基础的安全认证 / 权限功能，同时使用 Java 重写了新版本 Consumer API ，还 引入了 Kafka Connect 组件用于实现高性能的数据抽取，同样也是bug多<br>0.10.0.0 是里程碑式的大版本，因为该版本引入了 Kafka Streams。从这个版本起，Kafka 正式升 级成分布式流处理平台<br>0.11.0.0 版本，引入了两个重量级的功能变更:一个是提供幂等性 Producer API 以及事务 (Transaction) API ; 另一个是对 Kafka 消息格式做了重构。<br>1.0和2.0 主要是对Kafka Streams 的各种改进，在消息引擎方面并未引入太多的重大功能特性</p><p>最初的kafka是消息中间件，后面加入了流处理功能。1.1之后消息相关的代码就基本没动过了</p><h2 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h2><p>Kafka官方没有提供镜像，这里只能使用第三方的了，有些制作的还算不错的。</p><p>镜像分析，截取别人的经验：</p><ol><li><p>wurstmeister/kafka  特点：star数最多，版本更新到 Kafka 1.0 ，zookeeper与kafka分开于不同镜像。</p></li><li><p>spotify/kafka  特点：star数较多，有很多文章或教程推荐，zookeeper与kafka置于同一镜像中；但kafka版本较老（还停留在0.10.1.0）。</p></li><li><p>confluent/kafka 背景：Confluent是书中提到的那位开发Kafka的Jay Kreps 从LinkedIn离职后创立的新公司，Confluent Platform 是一个流数据平台，围绕着Kafka打造了一系列产品。特点：大咖操刀，文档详尽，但是也和Confluent Platform进行了捆绑。</p></li></ol><p>上述三个项目中，最简单的是spotify/kafka，但是版本较老。confluent/kafka 资料最为详尽，但是因为与Confluent Platform做了捆绑，所以略显麻烦。最终选定使用wurstmeister/kafka，star最多，版本一直保持更新，用起来应该比较放心。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>kafka 最新版本到 2.1.X 了</p><p>$KAFKA_HOME/bin/kafka-topics.sh –zookeeper zoo1:2181 –list // 查看所有主题<br>$KAFKA_HOME/bin/kafka-console-producer.sh –broker-list zoo1:9092 –topic test // 创建主题</p><p>$KAFKA_HOME/bin/kafka-console-producer.sh –broker-list localhost:9092 –topic test // 打开消息发送控制台<br>$KAFKA_HOME/bin/kafka-console-consumer.sh –bootstrap-server localhost:9092 -topic test –from-beginning // 打开消息消费控制台</p><h2 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h2><p>Kafka 提供了消费者客户端参数partition.assignment.strategy来设置消费者与订阅主题之间的分区分 配策略。默认情况下，采用 Range Assignor 分配策略。 Kafka 还提供了另外两种分配策略: RoundRobinAssignor 和 StickyAssignor</p><p><code>RangeAssignor</code> : RangeAssignor 分配策略的原理是按照消费者总数和分区总数进行整除运算来获得一个跨度，然后将分区按照跨度进行平均分配，以保证分区尽可能均匀地分配给所有的消费者</p><p>假设n=分区数/消费者数量，m=分区数%消费者数量，那么前m个消费者每个分配n+1个分区，后面的（消费者数量-m）个消费者每个分配n个分区。</p><p>为了更加通俗的讲解RangeAssignor策略，我们不妨再举一些示例。假设消费组内有2个消费者C0和C1，都订阅了主题t0和t1，并且每个主题都有4个分区，那么所订阅的所有分区可以标识为：t0p0、t0p1、t0p2、t0p3、t1p0、t1p1、t1p2、t1p3。最终的分配结果为：</p><pre><code>消费者C0：t0p0、t0p1、t1p0、t1p1消费者C1：t0p2、t0p3、t1p2、t1p3</code></pre><p>这样分配的很均匀，那么此种分配策略能够一直保持这种良好的特性呢？我们再来看下另外一种情况。假设上面例子中2个主题都只有3个分区，那么所订阅的所有分区可以标识为：t0p0、t0p1、t0p2、t1p0、t1p1、t1p2。最终的分配结果为：</p><pre><code>消费者C0：t0p0、t0p1、t1p0、t1p1消费者C1：t0p2、t1p2</code></pre><p>可以明显的看到这样的分配并不均匀，如果将类似的情形扩大，有可能会出现部分消费者过载的情况</p><p>其实这个例子举的也不是太好，可以理解为<code>从中间平均分开</code>，一刀划开，不够平分的情况，第一个消费组分到多余的</p><p><code>RoundRobinAssignor</code> :RoundRobinAssignor 分配策略的原理是将消费组内所有消费者及消费者订阅的所有主题的分区按照字典序排序，然后通过轮询方式逐个将分区依次分配给每个消费者</p><p>如图所示</p><pre><code>t1: 2   t1p0   t1p2t2: 4   t2p0   t2p1    t2p2     t2p3c0:     t1p0   t2p1c1:     t1p2   t2p2c2:     t2p0   t2p3</code></pre><p>把所有分区排序后，一个一个的分配给消费者</p><p>其中一个consumer挂了，就把原来的分区也是排序后再分配给消费者</p><pre><code>t1: 2   t1p0   t1p2t2: 4   t2p0   t2p1    t2p2     t2p3c0:     t1p0   t2p1c1:     t1p2   t2p2     宕机c2:     t2p0   t2p3c0:     t1p0   t2p0    t2p2c2:     t1p1   t2p1    t2p3</code></pre><p><code>StickyAssignor</code>: Kafka从 0.11.x 版本开始引入这种分配策略，它主要有两个目的: 分区的分配要尽可能均匀。分区的分配尽可能与上次分配的保持相同</p><p>采用RoundRobinAssignor会导致原来由自己消费的分区被分配给了其它消费者，而StickyAssignor就是解决这个问题，<code>分区的分配尽可能与上次分配的保持相同</code></p><p>如图所示</p><pre><code>t1: 2   t1p0   t1p2t2: 4   t2p0   t2p1    t2p2     t2p3c0:     t1p0   t2p1c1:     t1p2   t2p2     宕机c2:     t2p0   t2p3c0:     t1p0   t2p1     t1p2c2:     t2p0   t2p3     t2p2</code></pre><p><code>重复消费</code>: 分区策略，主要是要考虑重平衡的问题，假如其中一个消费组宕机，需要重新分配分区，这个消费组的分区还未提交偏移量，它的分区被分配给其它消费者来处理了，新的消费者从上个位点消费，这时候就重复消费了。重复消费的消息就是上个偏移量位点到原消费着未提交之前的消息</p><p>还有一种重复消费就是自动提交的情况下，消费者被关闭了，自动提交的时间间隔还没到，就还没来得及提交位移，下次启动消费者也会重复消费</p><p>重复消费可以通过监听器接口的实现来解决一些问题</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ConsumerRebalanceListener</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 在rebalance开始之前和消费者停止读取消息之后被调用。可以通过这个回调方法 //来处理消费位移的提交， 以此来避免一些不必要的重复消费现象的发生。</span>    <span class="token comment" spellcheck="true">//参数 partitions表示rebalance前所分配到的分区。</span>    <span class="token keyword">void</span> <span class="token function">onPartitionsRevoked</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span>TopicPartition<span class="token operator">></span> partitions<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 在重新分配分区之后和消费者开始读取消费之前被调用。</span>    <span class="token comment" spellcheck="true">// 参数partitions表示再均衡后所分配到的分区。</span>    <span class="token keyword">void</span> <span class="token function">onPartitionsAssigned</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span>TopicPartition<span class="token operator">></span> partitions<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="位移提交"><a href="#位移提交" class="headerlink" title="位移提交"></a>位移提交</h2><p>这里聊的是消费者的，假如消息是1到10，现在消费到了5，提交，偏移量记消息6的偏移量，下次就从6的偏移量开始消费。这个6对应的偏移量，就是commit offset(上次提交的消费位移)</p><p><code>消费者的位移也是保存在kafka的主题里面的</code></p><p>每个consumer会定期将自己消费分区的offsets提交给kafka内部topic:consumer_offsets，提交过去 的时候，key是consumerGroupId+topic+分区号，value就是当前offset的值，kafka会定期清理topic里的消息，最后就保留最新的那条数据。因为consumer_offsets可能会接收高并发的请求，kafka默认给其分配50个分区(可以通过offsets.topic.num.partitions设置)，这样可以通过加机器的方式抗大并发</p><h2 id="关于不信任包的问题"><a href="#关于不信任包的问题" class="headerlink" title="关于不信任包的问题"></a>关于不信任包的问题</h2><p>这个问题出现的原因是Java序列化安全考虑，下面按照出现情况和解决方法来总结一下</p><p>官方参考地址: <a href="https://docs.spring.io/spring-boot/docs/2.0.4.RELEASE/reference/htmlsingle/#boot-features-kafka-extra-props" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.0.4.RELEASE/reference/htmlsingle/#boot-features-kafka-extra-props</a></p><ol><li>上面也说了是Java序列化安全的考虑，在producer发送数据的时候，如果是对象，默认是要发送对象的头信息。所以如果你关闭这个配置，消费者就不会做安全校验了</li></ol><p>配置这个属性关闭 <code>spring.json.add.type.headers=false</code></p><ol start="2"><li>消费者做不做安全校验，都需要指定对象类型，否则无法序列化</li></ol><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">properties</span><span class="token punctuation">:</span>        <span class="token key atrule">spring</span><span class="token punctuation">:</span>          <span class="token key atrule">json</span><span class="token punctuation">:</span>            <span class="token key atrule">value</span><span class="token punctuation">:</span>              <span class="token key atrule">default</span><span class="token punctuation">:</span>                <span class="token key atrule">type</span><span class="token punctuation">:</span> com.xc.mysql.information.entity.Processlist<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是我们一般在工厂中指定。默认是没有配置的，可以修改这个配置</p><p>场景举例：</p><p>生产者关闭headers，消费者可以不用配置只指明默认对象类型就可以反序列化到数据(跨包也可以)</p><p>如果你关闭了headers=false，那么你消费者一定要配置默认类型，否则会报错没有默认类型(你在工厂中配和yaml中配置都是可以的，本质是一样的)</p><p>在关闭了headers后，不需要配置安全包了，只要能正确解析对象类型就行</p><ol start="3"><li>在分析了上面2种情况后，再来说说发生不信任包的情况</li></ol><p>会发生不信任包，原因是包路径没加入到一个信任列表。如果是消费者和生产者都在一个包内，不会发生这种情况(也不是绝对的，主要是看你包结构，取决于代码判断)</p><p>消费者和生产者跨包，就是我们要处理的问题</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>    <span class="token key atrule">json</span><span class="token punctuation">:</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span>        <span class="token key atrule">mapping</span><span class="token punctuation">:</span> com.liuzhidream.kafka.demo.model.ProcesslistModel<span class="token punctuation">:</span>com.xc.mysql.information.model.ProcesslistModel    <span class="token key atrule">trusted</span><span class="token punctuation">:</span>        <span class="token key atrule">packages</span><span class="token punctuation">:</span> com.liuzhidream.kafka.demo.model<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置如上</p><p>包信任默认是当前包，可以去看源码</p><p>mapping的配置: 就是跨包要解决的，需要配置，把消费者的对象映射到生产者这边。<br>举例: 消费者和生产者是两个不同包下的，我们可以通过映射，把外部的包映射为当前的包，这样就是安全的了(因为当前包是安全的，trusted可以不用配置了)</p><p>trusted就是信任包: 有些时候可能是不需要mapping的，看你包结构(比如都是一个path路径下)，这个时候我们需要配置信任包</p><p>基本这两个配置能包括了所有的情况了，是不是跨包，如果不是跨包，是不是没加入到信任包</p><ol start="4"><li><p>还有一点，就是Spring配置是读取yaml设置然后给到kafak，普通kafka也是这么配置的，具体可以看看官网</p></li><li><p>源码和总结，主要就是网上看了很多都没说到点上，然后我跟了源码其实很容易就解决问题了</p></li></ol><p>先大致给下源码流程，mapping的没给出，如果出现了这个问题，根据调用栈可以去跟下</p><p>在序列化中的deserialize方法，this.typeMapper.toJavaType(headers)该语句</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> T <span class="token function">deserialize</span><span class="token punctuation">(</span>String topic<span class="token punctuation">,</span> Headers headers<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ObjectReader deserReader <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>typeMapper<span class="token punctuation">.</span><span class="token function">getTypePrecedence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>TypePrecedence<span class="token punctuation">.</span>TYPE_ID<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            JavaType javaType <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>typeMapper<span class="token punctuation">.</span><span class="token function">toJavaType</span><span class="token punctuation">(</span>headers<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>javaType <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                deserReader <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>objectMapper<span class="token punctuation">.</span><span class="token function">readerFor</span><span class="token punctuation">(</span>javaType<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>toJavaType是接口的方法，实现<code>org.springframework.kafka.support.converter.DefaultJackson2JavaTypeMapper#getClassIdType</code>，主要是这个方法中</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isTrustedPackage</span><span class="token punctuation">(</span>classId<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"The class '"</span> <span class="token operator">+</span> classId                            <span class="token operator">+</span> <span class="token string">"' is not in the trusted packages: "</span>                            <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>trustedPackages <span class="token operator">+</span> <span class="token string">". "</span>                            <span class="token operator">+</span> <span class="token string">"If you believe this class is safe to deserialize, please provide its name. "</span>                            <span class="token operator">+</span> <span class="token string">"If the serialization is only done by a trusted source, you can also enable "</span>                            <span class="token operator">+</span> <span class="token string">"trust all (*)."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个地方判断信任包</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Middleware </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECMAScript 高级</title>
      <link href="/2019/03/11/JavaScript/advanced/"/>
      <url>/2019/03/11/JavaScript/advanced/</url>
      
        <content type="html"><![CDATA[<p>ECMAScript 高级话题</p><a id="more"></a><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>原始值和引用值</p><p>null 和 undefined</p><p>isNaN toString parseInt parseFloat</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>constructor   Prototype</p><p>constructor<br>对创建对象的函数的引用（指针）。对于 Object 对象，该指针指向原始的 Object() 函数。<br>Prototype<br>对该对象的对象原型的引用。对于所有的对象，它默认返回 Object 对象的一个实例。</p><p>hasOwnProperty(property)<br>判断对象是否有某个特定的属性。必须用字符串指定该属性。（例如，o.hasOwnProperty(“name”)）<br>IsPrototypeOf(object)<br>判断该对象是否为另一个对象的原型。<br>PropertyIsEnumerable<br>判断给定的属性是否可以用 for…in 语句进行枚举。<br>ToString()<br>返回对象的原始字符串表示。对于 Object 对象，ECMA-262 没有定义这个值，所以不同的 ECMAScript 实现具有不同的值。<br>ValueOf()<br>返回最适合该对象的原始值。对于许多对象，该方法返回的值都与 ToString() 的返回值相同。</p><p>极晚绑定: 就是在创建了实例后，再把属性绑定到对象的原型上，一般都是在创建实例之前操作。不建议使用这种方式</p><p>继承：call apply 作用将函数绑定到另一个对象上执行，第一个参数都是要绑定的对象，后面的参数call可以是多个，二apply是一个对象</p><p>在面向对象中，对象的构建没有官方的用法，继承也有多种，不过有原型链来规范继承。</p><p>arguments，函数参数个数是不会进行验证的，Function 对象也有与所有对象共享的 valueOf() 方法和 toString() 方法。这两个方法返回的都是函数的源代码</p><p>ECMAScript </p><h2 id="let-const-命令"><a href="#let-const-命令" class="headerlink" title="let const 命令"></a>let const 命令</h2><p>let 不存在变量提升，体现的是块级作用域，for循环中最后使用let，避免泄漏变成全局变量<br>ES6 允许了在块级作用域中声明函数，ES6之前是非法的，不过各种浏览器没有管这个事情</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 函数声明语句</span><span class="token punctuation">{</span>  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token string">'secret'</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> a<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 函数表达式</span><span class="token punctuation">{</span>  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token string">'secret'</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> a<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了统一规范，使用函数表达式来进行块级作用域的函数声明</p><p>在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ</p><p>const 声明不赋值会报错，除了不可变，其它的性质大体和let相似，是块级作用域，变量不提升，有暂时性死区</p><p>声明常量，只是变量指向的数据指针不能改，对了可变对象，要修改对象内容不是const来控制的</p><p>const foo = Object.freeze({}); 可以创建冻结对象，对象的属性一开始就要声明好，因为冻结对象是不可变的</p><p>顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。</p><h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p>基本用法，可以嵌套</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ... some code</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token comment" spellcheck="true">/* 异步操作成功 */</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>error<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL Sql sentence</title>
      <link href="/2019/03/07/MySql/sql-source/"/>
      <url>/2019/03/07/MySql/sql-source/</url>
      
        <content type="html"><![CDATA[<p>原生语句的使用与学习</p><a id="more"></a><h2 id="常见join"><a href="#常见join" class="headerlink" title="常见join"></a>常见join</h2><pre><code>select * from table_a a left join table_b b on a.key = b.keyselect * from table_a a inner join table_b b on a.key = b.keyselect * from table_a a right join table_b b on a.key = b.keyselect * from table_a a left join table_b b on a.key = b.key where b.key is NULLselect * from table_a a right join table_b b on a.key = b.key where a.key is NULLselect * from table_a a full outer join table_b b on a.key = b.keyselect * from table_a a full outer join table_b b on a.key = b.key where a.key is NULL or b.key is NULL</code></pre><p>查询的效果就是取两张表的join结果，有不同的join方法，字段会被组合在一行中，也就是笛卡尔积。</p><p>在某些数据库中，FULL JOIN 称为 FULL OUTER JOIN。</p><p>左连接以左边表为准，由于结果是两张表的字段，没匹配上的为null。 右连接类推，FULL JOIN 是 左右连接合并</p><p>inner join 取笛卡尔积</p><p>mysql: left join, left out join是一个东西，加上 inner join，只有3种，full不支持<br>用union 可以连接两张表，就是把B表拼接到A表后面，但是A,B必须字段数量相同<br>select table_a.id, table_a.table_b_id from table_a union select table_b.id, table_b.b_name from table_b;<br>这个例子用，虽然a表用的是table_b_id，b表是b_name，但是都是2个字段，这样就能拼接，但是b_name的数据被算到table_b_id这一列下</p><h3 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h3><p>select a.id from app_info a right join agents_profit_setting b on a.id = b.id;<br>注意使用了别名a为表app_info取别名，所以在其它需要用到表app_info都使用别名访问</p><p>select a.id, b.id as b_id from app_info a right join agents_profit_setting b on a.id = b.id;<br>返回a，b的id，并对b的id取别名b_id</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>系统提供了一些通用函数，可以在语句中使用</p><h3 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h3><pre><code>mysql&gt; select now(), curdate(), sysdate(), curtime();+---------------------+------------+---------------------+-----------+| now()               | curdate()  | sysdate()           | curtime() |+---------------------+------------+---------------------+-----------+| 2019-03-07 17:17:44 | 2019-03-07 | 2019-03-07 17:17:44 | 17:17:44  |+---------------------+------------+---------------------+-----------+</code></pre><h3 id="concat-和-contcat-ws"><a href="#concat-和-contcat-ws" class="headerlink" title="concat 和 contcat_ws"></a>concat 和 contcat_ws</h3><p>concat用来连接字符串，contcat_ws用来以分隔符参数来连接字符串<br><code>contcat_ws(',', 'a', 'b')  输出为：a,b</code></p><h3 id="case-排序把特定字段放在结果前面"><a href="#case-排序把特定字段放在结果前面" class="headerlink" title="case 排序把特定字段放在结果前面"></a>case 排序把特定字段放在结果前面</h3><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>equipment<span class="token punctuation">`</span> <span class="token keyword">order</span> <span class="token keyword">by</span> <span class="token keyword">case</span> <span class="token keyword">when</span> <span class="token punctuation">(</span>id<span class="token operator">=</span><span class="token string">'ZJXCA007804'</span> <span class="token operator">or</span> id<span class="token operator">=</span><span class="token string">'ZJXCA000695'</span><span class="token punctuation">)</span> <span class="token keyword">then</span> <span class="token number">0</span> <span class="token keyword">else</span> <span class="token number">1</span> <span class="token keyword">end</span> <span class="token punctuation">,</span>ismonitor <span class="token keyword">desc</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-py"><code class="language-py">equipments.order_by(Case(When(id__in=[item.get('eqid', 0) for item in equipment_ids], then=0), default=1), '-ismonitor', 'id')<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>limit y 分句表示: 读取 y 条数据<br>limit x, y 分句表示: 跳过 x 条数据，读取 y 条数据<br>limit y offset x 分句表示: 跳过 x 条数据，读取 y 条数据</p><p>第1页： 从第0个开始，获取20条数据</p><pre class="line-numbers language-sql"><code class="language-sql">selete <span class="token operator">*</span> <span class="token keyword">from</span> testtable <span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">;</span> selete <span class="token operator">*</span> <span class="token keyword">from</span> testtable <span class="token keyword">limit</span> <span class="token number">20</span> <span class="token keyword">offset</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第2页： 从第20个开始，获取30条数据</p><pre class="line-numbers language-sql"><code class="language-sql">selete <span class="token operator">*</span> <span class="token keyword">from</span> testtable <span class="token keyword">limit</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">;</span> selete <span class="token operator">*</span> <span class="token keyword">from</span> testtable <span class="token keyword">limit</span> <span class="token number">30</span> <span class="token keyword">offset</span> <span class="token number">20</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="datetime-时间范围内查询"><a href="#datetime-时间范围内查询" class="headerlink" title="datetime 时间范围内查询"></a>datetime 时间范围内查询</h2><p>datetime可以直接传递字符串，它本质就是存储字符串</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token number">a</span><span class="token punctuation">.</span>ID<span class="token punctuation">)</span> <span class="token keyword">from</span> mondata<span class="token punctuation">.</span>processlist <span class="token keyword">as</span> <span class="token number">a</span> <span class="token keyword">where</span> COLLECT_TIME <span class="token operator">BETWEEN</span> STR_TO_DATE<span class="token punctuation">(</span>        <span class="token string">'2020-04-08 00:00:00'</span><span class="token punctuation">,</span>        <span class="token string">'%Y-%m-%d %H'</span>    <span class="token punctuation">)</span><span class="token operator">AND</span> STR_TO_DATE<span class="token punctuation">(</span>    <span class="token string">'2020-04-09 00:00:00'</span><span class="token punctuation">,</span>    <span class="token string">'%Y-%m-%d %H'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分组取最大值"><a href="#分组取最大值" class="headerlink" title="分组取最大值"></a>分组取最大值</h2><ol><li>推荐标准用法</li></ol><p>SELECT * from learn A inner join<br>( SELECT course_id as course_id_child，MAX(learn_time) as learn_time_child FROM learn where user_id = ‘14201109’ GROUP BY course_id) B<br>ON A.course_id=B.course_id_child and A.learn_time=B.learn_time_child</p><p>learn表按course_id分组，取learn_time最大的，可以用上面的sql来实现，如果learn_time最大的有多个一样的，这些值都会留下来</p><p>实际示例:</p><p>“SELECT itemid, value, getclock FROM {table} a join ( SELECT itemid as itemid_child, MAX(getclock) as clock_child FROM {table} “ <br>“WHERE( {items_where} ) AND value !=’0’ AND getclock &gt; {time_stamp} GROUP BY itemid) b “ <br>“ON a.itemid = b.itemid_child and a.getclock = b.clock_child “.format(table=table_name, items_where=items_where, time_stamp=time_stamp)</p><ol start="2"><li>不赞成的用法</li></ol><p>这个用法会只取到最大的，如果不关心更多的字段，可以这么用，但是其实是有脏数据的(但是我只关心我想要的数据)</p><p>SELECT *<br>from learn<br>where learn.learn_time in (<br>            SELECT MAX(l.learn_time)<br>            FROM learn l<br>            where l.user_id = ‘14201109’<br>            GROUP BY l.course_id)</p><ol start="3"><li>其它用法，大同小异</li></ol><p>select * from test as a<br>where typeindex = (select max(b.typeindex)<br>from test as b<br>where a.type = b.type )</p><p>select<br>a.* from test a,<br>(select type,max(typeindex) typeindex from test group by type) b<br>where a.type = b.type and a.typeindex = b.typeindex order by a.type</p><p>select * from<br>(<br>select *,ROW_NUMBER() OVER(PARTITION BY type ORDER BY typeindex DESC) as num<br>from test<br>) t<br>where t.num = 1</p><p>SELECT * FROM Test t1 WHERE not EXISTS(select 1 from Test t2 WHERE t2.value&gt;t1.value and t1.name = t2.name);</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> DataBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django的默认服务器</title>
      <link href="/2019/02/26/blog/django-default-server/"/>
      <url>/2019/02/26/blog/django-default-server/</url>
      
        <content type="html"><![CDATA[<p>很多web框架都会自带服务器，今天就来看看Django的默认服务器是怎么运行的，本次使用的Django版本为2.1.7</p><a id="more"></a><h2 id="WSGI"><a href="#WSGI" class="headerlink" title="WSGI"></a>WSGI</h2><p>WSGI协议是Python为web服务器制定的标准，只要遵循WSGI协议，应用服务器就可以和Python程序实现通信，把http请求发送给Python程序，并返回响应。在Django中的 <code>wsgi.py</code> 就是一个 WSGI协议的实现，并返回了application。详情看<a href="https://www.python.org/dev/peps/pep-0333/" target="_blank" rel="noopener">PEP333</a>。</p><p>Django 通过 manage.py 来执行命令，原理就是收集命令行参数，去执行对应模块的方法，runserver就是启动默认服务器的命令，最终执行的代码如下</p><pre class="line-numbers language-py"><code class="language-py">def run(addr, port, wsgi_handler, ipv6=False, threading=False, server_cls=WSGIServer):    server_address = (addr, port)    if threading:        httpd_cls = type('WSGIServer', (socketserver.ThreadingMixIn, server_cls), {})    else:        httpd_cls = server_cls    httpd = httpd_cls(server_address, WSGIRequestHandler, ipv6=ipv6)    if threading:        # ThreadingMixIn.daemon_threads indicates how threads will behave on an        # abrupt shutdown; like quitting the server by the user or restarting        # by the auto-reloader. True means the server will not wait for thread        # termination before it quits. This will make auto-reloader faster        # and will prevent the need to kill the server manually if a thread        # isn't terminating correctly.        httpd.daemon_threads = True    httpd.set_app(wsgi_handler)    httpd.serve_forever()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文件路径：<code>python3.7/site-packages/django/core/servers/basehttp.py</code></p><p>调用的是 <code>from wsgiref.simple_server import WSGIServer</code> WSGIServer 的 serve_forever 方法，这个wsgiref是标准库提供的。</p><p>所以要看Django默认服务是怎么运行了，分析server_forever就行了。</p><pre class="line-numbers language-pysu"><code class="language-pysu">def serve_forever(self, poll_interval=0.5):    """Handle one request at a time until shutdown.    Polls for shutdown every poll_interval seconds. Ignores    self.timeout. If you need to do periodic tasks, do them in    another thread.    """    self.__is_shut_down.clear()    try:        # XXX: Consider using another file descriptor or connecting to the        # socket to wake this up instead of polling. Polling reduces our        # responsiveness to a shutdown request and wastes cpu at all other        # times.        with _ServerSelector() as selector:            selector.register(self, selectors.EVENT_READ)            while not self.__shutdown_request:                ready = selector.select(poll_interval)                if ready:                    self._handle_request_noblock()                self.service_actions()    finally:        self.__shutdown_request = False        self.__is_shut_down.set()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文件路径：<code>python3.7/socketserver.py</code></p><p>注释描述了方法的作用，服务启动后一直运行下去，每次只处理一个请求，使用IO多路复用的形式。也提示如果要进行长时间任务，最好在另一个线程中进行。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Technology技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> Python </tag>
            
            <tag> Technology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 2/3 str unicode bytes 区别详解</title>
      <link href="/2019/02/24/blog/python-encode/"/>
      <url>/2019/02/24/blog/python-encode/</url>
      
        <content type="html"><![CDATA[<p>str unicode bytes 在 2/3 版本中概念是不同的，需要详细理解它</p><a id="more"></a><h2 id="在2-3中的输出表现"><a href="#在2-3中的输出表现" class="headerlink" title="在2/3中的输出表现"></a>在2/3中的输出表现</h2><p>在Python2中</p><pre class="line-numbers language-py"><code class="language-py">s = 'abc' # stru = u'abc' # unicodeb = b'abc' # bytesprint s, u, bprint type(s), type(u), type(b)# s u b 输出# abc abc abc# <type 'str'> <type 'unicode'> <type 'str'><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出看着是一样的，可以通过type判断</p><p>在Python3中</p><pre class="line-numbers language-py"><code class="language-py">s = 'abc' # stru = u'abc' # unicodeb = b'abc' # bytesprint(s, u, b)# s u b 输出# abc abc b'anc'# str和Unicode是一样的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出可以看到有<code>b</code>前缀</p><p>Python2中，普通字符串的类型就是str，这个字符是Python3中的bytes，也就是字节</p><p>Python3中的str是Python2中的Unicode</p><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>Python3中做出的改变是有意义的，编码和解码都发生了变化。中文字符长度判断更加清晰，方法调用更加合理(编码解码的错误信息更加清晰)</p><p>比如在要求返回bytes的地方，使用Python2可以直接运行，而Python3需要把str encode(‘utf-8’) 成bytes</p><p>str 和 Unicode 是两种字符串类型，在2中，str存储用的是字节序列，计算机在读取的时候使用ascii解码规则，从二进制得到对应ascii码，在不对系统编码设置的情况下，默认是使用ascii编码。</p><p>编码和解码：</p><p>Python2中，字符串是字节序列，可以解码成Unicode</p><p>Python3中，统一了字符和Unicode，字符串是以字符为单位进行处理的，bytes类型是以字节为单位处理的，bytes因为是二进制，所以需要使用对应的编码才能解析，而str已经在存储的时候使用了Unicode</p><blockquote><p>2中str和bytes是一样的，Unicode是3中的str<br>3中的str和Unicode是一样的，bytes是2中的str</p></blockquote><blockquote><p>python3 中 str和uncode 调用 encode(‘utf-8’) 可以编码成 bytes<br>bytes 调用 decode(‘utf-8’) 可以解码成 str</p><p>python2 中 str调用 decode(‘utf-8’) 可以解码成 Unicode<br>Unicode 调用 encode(‘utf-8’) 可以编码成 str 也就是 bytes</p></blockquote><blockquote><p>在Python3中，对bytes类型调用str函数，会把b前缀也加上，<code>"b'12aa'"</code> 这显然不是你想要的，需要注意</p></blockquote><p>字节的shell输出看起来是这样的 <code>\xae\x9e\xe6\x88\x98\</code> 使用十六进制表示，通过<code>\</code>分割，这里表示了5个字节，Unicode的源码表示差不多也是这样 <code>u'\u6492\u5a07'</code>，记得utf-8是变长编码，使用1到4个字节表示汉字或其它语言的字符。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>下面的例子模拟了一个web服务，使用socket编程来处理浏览器发送的请求，并返回，在Python2中是可以正常运行的</p><pre class="line-numbers language-py"><code class="language-py"># coding:utf-8import socketEOL1 = '\n\n'EOL2 = '\n\r\n'body = '''Hello, world! <h1> from the5fire 《Django企业开发实战》</h1>'''response_params = [    'HTTP/1.0 200 OK',    'Date: Sat, 10 jun 2017 01:01:01 GMT',    'Content-Type: text/plain; charset=utf-8',    'Content-Length: {}\r\n'.format(len(body)),    body,]response = b'\r\n'.join(response_params)def handle_connection(conn, addr):    request = ""    while EOL1 not in request and EOL2 not in request:        request += conn.recv(1024)    print(request)    conn.send(response)    conn.close()def main():    # socket.AF_INET    用于服务器与服务器之间的网络通信    # socket.SOCK_STREAM    基于TCP的流式socket通信    serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    # 设置端口可复用，保证我们每次Ctrl C之后，快速再次重启    serversocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)    serversocket.bind(('127.0.0.1', 8080))    # 可参考：https://stackoverflow.com/questions/2444459/python-sock-listen    serversocket.listen(1)    print('http://127.0.0.1:8080')    try:        while True:            conn, address = serversocket.accept()            handle_connection(conn, address)    finally:        serversocket.close()if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>那么问题来了，如果要迁移到Python3上要做哪些改动呢？</strong></p><ol><li><p>首先print等语法是要改的，但是这不是本次聊的重点，通过上文的总结，我们知道了Python2中str就是存储字节序列，而socket也是要求发送字节序列的，所以在Python3上，str默认是Unicode就不适用了，需要编码成bytes。</p></li><li><p>在handle_connection中，把需要用到的str都编码，如果文本都是ASCII，加一个<code>b</code>前缀即可，如果包含像中文的文本，需要使用encode进行编码。调整好后程序可以运行了。</p></li><li><p>细心观察，你会发现返回的文本被截断了，或者出现了乱码，这就涉及到Python2/3 <code>len</code> 函数的问题，关键在这一句 <code>'Content-Length: {}\r\n'.format(len(body))</code> 。</p></li><li><p>在2中已经是字节序列了，如果用3计算的是Unicode的长度。现在中文文本是 <code>Django企业开发实战</code> 2中的bytes能计算得到长度是 24 源码为 <code>'Django\xe4\xbc\x81\xe4\xb8\x9a\xe5\xbc\x80\xe5\x8f\x91\xe5\xae\x9e\xe6\x88\x98'</code>，汉子占用18个字节，英文占用6个字节。</p></li><li><p>如果是在3中，使用Unicode一个中文就占用一个长度，就没有24这么长，然后response是编码成bytes返回的，自然长度不够，出现解析错误。所以在设置Content-Length的时候要以bytes计算的长度为准。</p></li></ol><p>Python3完整修改版</p><pre class="line-numbers language-py"><code class="language-py">import socketEOL1 = b'\n\n'EOL2 = b'\n\r\n'body = '''Hello, world! <h1> from the5fire 《Django企业开发实战》</h1>'''response_params = [    'HTTP/1.0 200 OK',    'Date: Sat, 10 jun 2017 01:01:01 GMT',    'Content-Type: text/plain; charset=utf-8',    'Content-Length: {}\r\n'.format(len(body.encode('utf-8'))),    body,]response = '\r\n'.join(response_params)response = response.encode('utf-8')def handle_connection(conn, addr):    request = b""    while EOL1 not in request and EOL2 not in request:        request += conn.recv(1024)    print(request)    conn.send(response)    conn.close()def main():    # socket.AF_INET    用于服务器与服务器之间的网络通信    # socket.SOCK_STREAM    基于TCP的流式socket通信    serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    # 设置端口可复用，保证我们每次Ctrl C之后，快速再次重启    serversocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)    serversocket.bind(('127.0.0.1', 8080))    # 可参考：https://stackoverflow.com/questions/2444459/python-sock-listen    serversocket.listen(1)    print('http://127.0.0.1:8080')    try:        while True:            conn, address = serversocket.accept()            handle_connection(conn, address)    finally:        serversocket.close()if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Technology技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> Python </tag>
            
            <tag> Technology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python web 开发(四) 项目测试</title>
      <link href="/2019/02/01/blog/advanced-python-web-04/"/>
      <url>/2019/02/01/blog/advanced-python-web-04/</url>
      
        <content type="html"><![CDATA[<p>项目的前端到后端都准备好了，下面开始运行它，本来计划部署到阿里云服务器上的，但是200多的服务器还是太弱了，可以勉强跑起来，但是cup占用率过半后，导致远程连接卡到无法使用，只能在本地模拟了，由于是用的docker，其实和服务器上差异不大了。</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><a href="https://github.com/VanLiuZhi/flask_starlight.git" target="_blank" rel="noopener">后端代码地址</a></p><p><a href="https://github.com/VanLiuZhi/element_UI_Web.git" target="_blank" rel="noopener">前端代码地址</a></p><p>由于前端代码我已经编译好了，要想跑起项目直接使用后端代码就行了。</p><p>在 <code>docker-compose.yaml</code> 修改你的文件路径，准备需要映射的数据目录（MySQL，Redis）</p><p>编辑Nginx配置文件，使用了一个虚拟域名 <code>test.liuzhi.com</code> 用以模拟域名访问。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>进入 <code>compose_docker_dev</code> 目录，先通过 <code>Dockerfile</code> 创建Python环境镜像，编辑 <code>docker-compose.yaml</code>，通过命令 <code>docker-compose up -d</code> 启动服务。默认是跑flask自带的服务器，改成 <code>gunicorn auto_app:app -c gunicorn.py</code>，使用gunicorn服务器来启动项目</p><p>启动服务后，进入Python容器，做数据库初始化，这样就可以访问首页了。</p><p>通过 python crawling 抓取别人的ress订阅的数据，展示在首页上。在此之前记得启动celery，celery负责处理后台任务。</p><p>运行后看起来应该是这样的：</p><p><img src="/images/Blog/python-advanced-04/2019-02-12-22.14.27.png" alt="image"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本项目是一个单机可用的开发环境，包含的python开发的完整服务，太偏业务的内容没有讲太多，看代码差不多就能了解了。</p><p>这样的架构还是比较普通的，如果要应对高并发，只是读取缓存的并发请求，添加多台Redis实例，通过nginx负载均衡调度应用服务器，可以抗下来，这方面的经验不多，是后续可以学习和改进的地方。</p><p>在后续的下一次总结中，计划做一个有实际业务需求的，其实我本来也搞过，不过在数据上玩脱了，没有数据写的东西不太有价值，当时是看了很多公司提供的API来作为数据源的，不过要不就是需要翻墙，要么就是接口变的不提供数据了，唯一可用的GitHub的API接口实在是过于繁琐了，使用了最新的 GraphQL 接口风格，是Facebook开发的用于 API 的查询语言，要完全运用还得花时间。所以最好的数据来源还是用爬虫吧，准备学习一下爬虫，做一个数据分析的项目，把所学的东西都调度起来。</p><p>搞IT就是要能折腾，看别人怎么写，看官方的文档，从中总结，把别人讲解的变成自己的，多去实践。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Technology技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> Python </tag>
            
            <tag> Technology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python web 开发(三) 使用Docker部署项目</title>
      <link href="/2019/02/01/blog/advanced-python-web-03/"/>
      <url>/2019/02/01/blog/advanced-python-web-03/</url>
      
        <content type="html"><![CDATA[<p>docker 是 2013 年发布的开源的应用容器引擎，虽然时间不长，但是很快占据市场受到开发者的青睐，docker不仅是运维同学的专项，作为一名开发者，学习docker是必备的。下面讲解如何使用docker开发和部署项目。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>docker使用的优势：</p><ol><li><p>利用docker你可以快速搭建环境，比如在本项目中用到的Elasticsearch是基于Java的，如果常规安装，还需要准备Java环境，安装Java虚拟机等，这对于一名Python开发者来说显然耗费大量时间，但是有了docker就不一样了，只需要安装docker软件，使用Elasticsearch的镜像就可以快速搭建服务，把精力放在如何使用Elasticsearch中去。我比较推崇的一种开发模式就是本地跑Python环境，然后把各种相关服务跑在docker中，这样很容易扩展，又不影响本地的开发，也不会因为个人电脑的关系导致相关服务难以安装。</p></li><li><p>统一了环境，以前部署项目都是比较头疼的，一台新的服务器，由于安装Linux发行版不一样，在安装软件的时候经常因为缺少各种依赖浪费很多时间，以前我在阿里云上部署项目，新的服务器每次都安装有差异，我觉得把时间花在安装软件上真的是不值的。使用docker的话，本地和线上可以统一环境，只要本地能正常运行，在线上只需要调整一些安全相关的配置即可上线。</p></li></ol><p>本项目除了Python环境外，其余在开发测试阶段都是依赖于docker的，像Redis，RabbitMQ等服务都是跑在docker中，部署的话只需要构建一个当前Python环境配合已有的服务即可。</p><h2 id="docker-基本"><a href="#docker-基本" class="headerlink" title="docker 基本"></a>docker 基本</h2><p>docker 是容器技术，初学者很容易和虚拟机的概念混用，包括在使用的时候也是如此。这一点非常的重要，我在初用docker的时候，把软件都装在一个容器里面，也是看别人的博客入门给我这种感觉，其实不应该这样，这种做法更像一个虚拟机，可以用来做开发，比如打包一个完整项目的开发环境，大家用这个镜像可以马上运行项目。正确的用法应该是每个服务一个容器，彼此分类开来。</p><p>docker的概念围绕着容器container和镜像image展开，镜像是固化的文件，容器是镜像的实例，更多的可以查看我以前做的总结 <a href="http://www.liuzhidream.com/2018/10/22/Docker/Docker/">Docker 容器在 web 开发中的运用</a></p><h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><p>数据卷是为了做数据持久化，在容器内长生的数据随着容器删除就没了，这对应像mysql这样的需要持久化数据的服务当然是不允许的，所以有了数据卷的概念，把容器的一个目录和本机的一个目录映射，本机产生的数据容器可以使用，反之亦然。</p><h3 id="网络与端口"><a href="#网络与端口" class="headerlink" title="网络与端口"></a>网络与端口</h3><p>能映射数据也能映射端口，映射端口的意思就是本机的端口和容器是互通的，访问本机的端口就是访问容器的端口。</p><p>网络是比较重要的概念，不了解网络的机制让容器之间通信变得头疼，很容易卡在这里，可以使用docker来创建网络，处在同一网络中的容器可以互相通信，这个时候其实容器处在一个局域网中，只要知道ip也能通信，但是通常不这么做。</p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>Dockerfile是构建镜像的文件，通过编写Dockerfile可以创建自定义的镜像。一般镜像可以从网络下载，或者使用别人创建的，自己想要制作镜像就要使用Dockerfile，因为你可能需要很多定制，比如构建一个Python环境，并且安装依赖，安装像vim，wget等常用的软件，因为官方镜像都是精简的，默认只有Python环境。</p><h3 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h3><p>docker-compose是容器编排工具，用来组织多个容器如何运行的，是必备的工具，本项目就是使用docker-compose一次运行所有服务，不再像使用 <code>docker run</code> 这样的形式，一次跑一个容器。除了运行方便，还提供了很多配置，可以把各种参数都一次写入docker-compose.yaml文件，相比原生方式更加灵活，管理更方便。</p><p>本项目都是使用docker-compose，这个工具需要单独安装，推荐使用二进制安装的形式。</p><h2 id="开发中使用docker"><a href="#开发中使用docker" class="headerlink" title="开发中使用docker"></a>开发中使用docker</h2><p>在开发中可以使用docker来运行除Python环境本身的服务，其实你把Python环境用docker来运行也是可以的，这样把项目代码提供数据卷映射到容器，修改本地代码，使用容器来运行它，不过我要配合IDE来开发，就不把Python环境跑在docker中了。</p><p>docker-compose.yaml 文件</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis<span class="token punctuation">:</span>latest    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> redis<span class="token punctuation">-</span>web    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> 6379<span class="token punctuation">:</span><span class="token number">6379</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> ~/redis/data<span class="token punctuation">:</span>/data  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> rabbitmq<span class="token punctuation">:</span>latest    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> rabbitmq<span class="token punctuation">-</span>web    <span class="token key atrule">hostname</span><span class="token punctuation">:</span> rabbit    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> RABBITMQ_DEFAULT_USER=developer      <span class="token punctuation">-</span> RABBITMQ_DEFAULT_PASS=dev1234    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> 5672<span class="token punctuation">:</span><span class="token number">5672</span>      <span class="token punctuation">-</span> 15672<span class="token punctuation">:</span><span class="token number">15672</span>  <span class="token key atrule">elasticsearch</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> elasticsearch<span class="token punctuation">:</span>5<span class="token punctuation">-</span>alpine    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> elasticsearch<span class="token punctuation">-</span>web    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> 9200<span class="token punctuation">:</span><span class="token number">9200</span>      <span class="token punctuation">-</span> 9300<span class="token punctuation">:</span><span class="token number">9300</span>    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> discovery.type=single<span class="token punctuation">-</span>node      <span class="token punctuation">-</span> bootstrap.memory_lock=true      <span class="token punctuation">-</span> xpack.security.enabled=false      <span class="token punctuation">-</span> <span class="token string">"ES_JAVA_OPTS=-Xms256m -Xmx256m -XX:+AssumeMP"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用官方提供的镜像，这里有个套路，就是你不知道某个镜像要怎么用的时候，比如像elasticsearch你不知道它要映射什么端口，Redis数据目录是在哪个路径，可以去Docker官方查找，对应镜像都有这些信息。</p><p>使用命令 <code>docker-compose up -d</code> 就可以运行容器了，可以在本机访问9200测试elasticsearch是否已经提供正常服务。</p><h2 id="部署中使用docker"><a href="#部署中使用docker" class="headerlink" title="部署中使用docker"></a>部署中使用docker</h2><p>部署的时候，需要构建python环境的镜像，就要使用到Dockerfile。</p><pre class="line-numbers language-yaml"><code class="language-yaml">FROM python<span class="token punctuation">:</span><span class="token number">3.6</span>LABEL author="liuzhi&lt;1441765847.com<span class="token punctuation">></span>"<span class="token comment" spellcheck="true"># 换源，Python镜像基于Debian，使用阿里的Debian源</span>RUN rm /etc/apt/sources.listCOPY sources.list /etc/apt/sources.list<span class="token comment" spellcheck="true"># 运行命令，安装常用软件</span>RUN apt<span class="token punctuation">-</span>get update \    &amp;&amp; ln <span class="token punctuation">-</span>sf /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime \    <span class="token comment" spellcheck="true"># 有时候会提示需要安装apt-utils，不过我这里是基于Debian的</span>    <span class="token comment" spellcheck="true"># 这东西还装不上，没有apt-utils，安装不了第三方包，wget安装失败了</span>    <span class="token comment" spellcheck="true"># 进入容器安装wget</span>    <span class="token comment" spellcheck="true"># &amp;&amp; apt-get install -y apt-utils \</span>    <span class="token comment" spellcheck="true"># &amp;&amp; apt-get install -y wget \</span>    &amp;&amp; apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y zsh \    &amp;&amp; chsh <span class="token punctuation">-</span>s /bin/zsh root \    &amp;&amp; apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y curl \    &amp;&amp; apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y git \    &amp;&amp; apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y vim <span class="token comment" spellcheck="true"># 安装zsh的扩展，使用了 || ，不用直接安装镜像创建会失败</span>RUN sh <span class="token punctuation">-</span>c "$(wget https<span class="token punctuation">:</span>//raw.github.com/robbyrussell/oh<span class="token punctuation">-</span>my<span class="token punctuation">-</span>zsh/master/tools/install.sh <span class="token punctuation">-</span>O <span class="token punctuation">-</span>)"  <span class="token punctuation">|</span><span class="token punctuation">|</span> true<span class="token comment" spellcheck="true"># 把当前目录文件复制到容器的/code目录，主要是为了复制requirements.txt</span>ADD . /docker_fileWORKDIR docker_fileRUN pip install <span class="token punctuation">-</span>r requirements.txt<span class="token comment" spellcheck="true">#CMD ["python", "app.py"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要就是组织命令，这里安装了zsh工具，并修改默认shell为zsh，安装了curl，git，vim软件。</p><p>需要注意的是镜像源的选择，这里是基于已有的Python镜像来制作自己的镜像的，使用的是python3.6，官方有很多镜像会带alpine后缀，这是说明该镜像是基于Linux-alpine版本的，就是Linux精简版体积很小，所以砍了很多东西，推荐代码环境使用标准版，其它服务使用alpine版本。</p><p>docker-compose.yaml 文件</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">app</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> python_flask<span class="token punctuation">:</span>v1    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> python<span class="token punctuation">-</span>web    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>     <span class="token punctuation">-</span> ~/PycharmProjects/flask_starlight<span class="token punctuation">:</span>/code    <span class="token key atrule">command</span><span class="token punctuation">:</span> cd /code/flask_starlight    <span class="token key atrule">command</span><span class="token punctuation">:</span> python auto_app.py    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>     <span class="token punctuation">-</span> mysql     <span class="token punctuation">-</span> redis     <span class="token punctuation">-</span> rabbitmq     <span class="token punctuation">-</span> elasticsearch    <span class="token key atrule">expose</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token number">5000</span>    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token key atrule">net_front</span><span class="token punctuation">:</span>        <span class="token key atrule">aliases</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> python_server      <span class="token key atrule">net_backend</span><span class="token punctuation">:</span>        <span class="token key atrule">aliases</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> python_backend  <span class="token key atrule">mysql</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql<span class="token punctuation">:</span>latest    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> mysql<span class="token punctuation">-</span>web    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> ~/dev<span class="token punctuation">-</span>mysql<span class="token punctuation">:</span>/var/lib/mysql    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token key atrule">net_backend</span><span class="token punctuation">:</span>        <span class="token key atrule">aliases</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> masterdb    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token key atrule">MYSQL_ROOT_PASSWORD</span><span class="token punctuation">:</span> root1234    <span class="token key atrule">expose</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token number">3306</span>  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis<span class="token punctuation">:</span>latest    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> redis<span class="token punctuation">-</span>web    <span class="token key atrule">expose</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token number">6379</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> ~/redis/data<span class="token punctuation">:</span>/data    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token key atrule">net_backend</span><span class="token punctuation">:</span>        <span class="token key atrule">aliases</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> master_redis  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> rabbitmq<span class="token punctuation">:</span>latest    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> rabbitmq<span class="token punctuation">-</span>web    <span class="token key atrule">hostname</span><span class="token punctuation">:</span> rabbit    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> RABBITMQ_DEFAULT_USER=developer      <span class="token punctuation">-</span> RABBITMQ_DEFAULT_PASS=dev1234    <span class="token key atrule">expose</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token number">5672</span>      <span class="token punctuation">-</span> <span class="token number">15672</span>    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token key atrule">net_backend</span><span class="token punctuation">:</span>        <span class="token key atrule">aliases</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> rabbitmq_server  <span class="token key atrule">elasticsearch</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> elasticsearch<span class="token punctuation">:</span>5<span class="token punctuation">-</span>alpine    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> elasticsearch<span class="token punctuation">-</span>web    <span class="token key atrule">expose</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token number">9200</span>      <span class="token punctuation">-</span> <span class="token number">9300</span>    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> discovery.type=single<span class="token punctuation">-</span>node      <span class="token punctuation">-</span> bootstrap.memory_lock=true      <span class="token punctuation">-</span> xpack.security.enabled=false      <span class="token punctuation">-</span> <span class="token string">"ES_JAVA_OPTS=-Xms256m -Xmx256m -XX:+AssumeMP"</span>    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token key atrule">net_backend</span><span class="token punctuation">:</span>        <span class="token key atrule">aliases</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> elasticsearch_server  <span class="token key atrule">nginx</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>web    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> ~/PycharmProjects/flask_starlight/compose_docker_dev/nginx<span class="token punctuation">:</span>/etc/nginx      <span class="token punctuation">-</span> ~/PycharmProjects<span class="token punctuation">:</span>/web    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token datetime number">80:80</span>    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> NGINX_PORT=80    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> app    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> net_front<span class="token key atrule">networks</span><span class="token punctuation">:</span>  <span class="token key atrule">net_front</span><span class="token punctuation">:</span>  net_backend<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的配置就是把所有服务都跑在docker里面，Python的环境先用Dockerfile构建好后，直接指定镜像。</p><p>部署相对于开发使用会比较复杂，开发只是把docker容器当成一个服务，提供正确的端口即可，部署需要组织各个服务之间的通信。</p><p>这里就要用到网络了，使用networks创建网络，这里创建了两个网络：</p><pre><code>属于net_front网络的容器: nginx，app属于net_backend网络的容器: app，mysql，redis，rabbitmq，elasticsearch</code></pre><p>其实可以不使用network，因为docker-compose创建的容器会默认加入到一个以配置文件目录名生成的网络中，也就是它们默认已经处在一个局域网中了，这里使用network是为了让服务之间的关系清晰，通过自定义的网络分割容器，像nginx服务就不能访问mysql。</p><p>还有一点很重要的就是如何在一个容器中访问另外的容器，比如在nginx中，需要使用反向代理到Python容器，配置文件如下：</p><pre><code>user nginx;          # nginx运行的用户及用户组worker_processes 1; # worker进程个数error_log /var/log/nginx/error.log warn; # 错误日志目录pid       /var/run/nginx.pid;            # nginx启动后进程pid写入这个文件events {    worker_connections 65536; # 每个worker进行的最大连接数}http {    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format main '$remote_addr - $remote_user [$time_local] "$request" '                    '$status $body_bytes_sent "$http_referer" '                    '"$http_user_agent" "$http_x_forwarded_for"';    access_log  /var/log/nginx/access.log  main; # 访问日志    upstream frontends {        server python_server:5000;    }    include /etc/nginx/conf.d/*.conf; # 导入其它配置}</code></pre><p>可以看到，nginx的反向代理是通过 <code>python_server:5000</code> 来访问的，而这个python_server是Python容器网络的别名，或者通过服务名称app也可以，即 <code>app:5000</code>。同样的，在Python容器中要访问mysql，flask的配置应该是这样的 <code>SQLALCHEMY_DATABASE_URI = 'mysql+pymysql://root:root1234@masterdb/starlight?charset=utf8mb4'</code> 通过对MySQL容器的网络别名masterdb来访问。</p><h2 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h2><p><code>docker-compose exec server_name</code> 通过docker-compose exec 加服务名称，可以和容器进行交互，比如 <code>docker-compose exec redis cat /etc/hosts</code> 查看redis服务的hosts文件。</p><p>连接容器：</p><p><code>docker-compose exec app /bin/zsh</code></p><p>查看日志：</p><p><code>docker-compose exec logs app</code></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Technology技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> Python </tag>
            
            <tag> Technology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python web 开发(二) 前端工程</title>
      <link href="/2019/02/01/blog/advanced-python-web-02/"/>
      <url>/2019/02/01/blog/advanced-python-web-02/</url>
      
        <content type="html"><![CDATA[<p>前端最近几年发展的势头应该是最大的了，开始我在项目中是利用框架的模板来编写前端代码的，后来随着业务的复杂度不断的上升，用传统的jQuery已经很难实现需求了，这时候转向了Vue这种数据驱动的框架，这使得很多需求几行代码就搞定了，开发效率大幅度提升。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这应该是前端最好的时代了，以前用jQuery去实现，少的都是一千行起步，而且由于js的压力是在客户端，很多人基本都不怎么考虑性能。</p><p>我认为JavaScript处在一种需要重构的阶段，它的初衷不是为了编写大型应用的，所以现在各种加特性，各种扩展，包括css等，后缀不知道多少种。个人建议最好选择其中一种生态来学习，如果不是写底层，有些特性不需要了解太多。</p><p>推荐 Vue 或 React，本项目使用的是Vue，是全生态的Vue，就是前端都是基于Vue的，后端只做接口。</p><p>Vue在前端中有两个用法，一种就是作为扩展引入它，解决那些复杂的需求。另外就是整个前端都是用Vue来写的，就是常说的单页面Single page，它只会加载一个页面，其它的操作都是通过更新DOM来完成的，这节约了很多请求的开销，同时体验也很好，像企业系统等项目就很适合用Vue来做。</p><p>另外移动开发也适合Single page这样的应用，可以做混合式APP，省去了开发Android和iOS的麻烦。</p><p>当然弊端是不可少的，就是兼容性，作为新的技术，它使用了es4无法模拟的特性，使得像IE浏览器这种老内核支持很差，不过有对应的方案，可以去官方文档找。</p><p>关于Vue的学习参考官方文档即可，总的来说上手还是很快的。</p><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>通过Vue的脚手架vue-cli来构建工程，需要配合到很多工具，需要用到Node.js作为环境。由于官方一直在更新，使用最新的脚手架构建的工程应该跟我有一些出入，影响不大就行。脚手架就是快速创建工程的工具，前端全生态Vue，需要用到很到工具，如果你每个都自己搭，学习成本还是很高，其实我的前端主要精力放在开发上，我也没像Python一样很系统的学习过它的语法，主要真的是用的少，像为了实现面向对象的原型链，几乎在开发中不会去用，这也因为不做底层，套用框架的原因。</p><p>vue的生态主要就是用到了vue, vue-cli，vue-loader，webpack，理解这几个模块的用法，请求使用axios模块，不要再用ajax了。</p><p>个人建议使用nvm创建虚拟环境，因为更新很频繁，有些版本会和其它有冲突，使用虚拟环境，这样安装在全局的模块不想要了直接删除虚拟环境就行了，不会对系统造成很大的文件残留。</p><h2 id="与后端配合"><a href="#与后端配合" class="headerlink" title="与后端配合"></a>与后端配合</h2><p>虽然Node.js提供了全套的开发方案，不过本项目是以Python为主要后端，VUE应该怎么样和后端配合呢？就是把编译后的静态文件由Python来处理就行了，一般会有一个index.html文件作为入口，Python需要在首页的url返回这个index.html，然后组织好编译后的静态文件，确保能被搜索到，这属于部署阶段。</p><p>开发阶段就是以Node.js为前端环境，前端需要跑一个独立的服务，需要和后端的服务进行交互。</p><h2 id="Vue-基本"><a href="#Vue-基本" class="headerlink" title="Vue 基本"></a>Vue 基本</h2><p>使用Vue，主要是数据驱动式，所以要把思维转换过来，传统的jQuery的方式是操作DOM，而Vue底层也是操作DOM，但是用了虚拟DOM的概念，会更节省资源，而且除非必须，一般不会显示的去操作DOM，因为没这个必要，它的数据驱动式通过双向绑定很容易就修改DOM。</p><p>讲解几个比较常用的点：</p><ol><li><p>在全生态Vue的架构中，vue实例只被创建一次，之后都是围绕组件来展开的，这点很重要。</p></li><li><p>理解生命周期，这是常见的话题，尤其是在早前版本的时候，更新DOM的时间点，引发很多问题，导致不能及时修改，其实有解决方案，只是可能你用的版本还不支持。</p></li><li><p>基础部分都是围绕着数据双向绑定来的，这部分运用的差不多了，就到了组件了，组件就是把常用的功能封装出来，比如一个页面的尾部，可以独立成一个组件，在各个页面中去使用。</p></li></ol><h3 id="在组件中触发父组件的方法"><a href="#在组件中触发父组件的方法" class="headerlink" title="在组件中触发父组件的方法"></a>在组件中触发父组件的方法</h3><p>有时候需要在组件中调用父组件的方法，应该这样写 <code>@click="$emit('click_event', item.guid)"</code></p><p>在父组件中需要由该事件的处理函数 <code>&lt;post-tag v-on:click_event="tagHandler"&gt;&lt;/post-tag&gt;</code></p><p>如此，由子组件发起的事件被父组件接收，由tagHandler方法来处理。</p><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p>还有一个特性就是插槽，对于这个特性，可以用在编写组件的地方，但是最常用的还是各种框架会使用它，所以如果你不了解它，就不能很好的使用框架提供的组件。</p><p>在 element-UI 的 el-table 组件中，把remark绑定到v-model中，就是使用了作用域插槽</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">slot-scope</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>scope<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>textarea</span><span class="token style-attr language-css"><span class="token attr-name">            <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span><span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">80</span>px<span class="token punctuation">;</span> <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">1</span>px solid <span class="token hexcode">#dedede</span><span class="token punctuation">;</span></span><span class="token punctuation">"</span></span>            <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>textarea<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>备注<span class="token punctuation">"</span></span>            <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>scope.row.remark<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>textarea</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>这部分主要关注的是路由和状态管理，至于服务端渲染，还没有用过。</p><p>路由是vue生态中一定会用的，它把前端的页面请求拦截了，交由特定的组件来处理，路由可以带参数，在组件页面可以通过 <code>this.$route.params.data</code> 获取路由对象相关的数据。</p><pre class="line-numbers language-js"><code class="language-js">Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Router<span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>      name<span class="token punctuation">:</span> <span class="token string">'index'</span><span class="token punctuation">,</span>      component<span class="token punctuation">:</span> Index    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">'/article_details/:guid'</span><span class="token punctuation">,</span>      name<span class="token punctuation">:</span> <span class="token string">'ArticleDetails'</span><span class="token punctuation">,</span>      component<span class="token punctuation">:</span> ArticleDetails    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">'/auther'</span><span class="token punctuation">,</span>      name<span class="token punctuation">:</span> <span class="token string">'auther'</span><span class="token punctuation">,</span>      component<span class="token punctuation">:</span> Auther    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">'/test'</span><span class="token punctuation">,</span>      name<span class="token punctuation">:</span> <span class="token string">'test'</span><span class="token punctuation">,</span>      component<span class="token punctuation">:</span> Test    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>状态管理是比较大型的应会用到的东西，需要使用vuex来使用，我在一些别人的大型的项目中看到过，本项目没有用到不做过多赘述。</p><h2 id="项目分析"><a href="#项目分析" class="headerlink" title="项目分析"></a>项目分析</h2><p>由于这不是一个具体的实际需求的项目，前端部分主要讲个人认为需要注意的坑，和一些需要修改的地方。</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>各种依赖在package.json中，其中script模块用来描述脚本命令：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token string">"scripts"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">"dev"</span><span class="token punctuation">:</span> <span class="token string">"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js"</span><span class="token punctuation">,</span>    <span class="token string">"start"</span><span class="token punctuation">:</span> <span class="token string">"npm run dev"</span><span class="token punctuation">,</span>    <span class="token string">"unit"</span><span class="token punctuation">:</span> <span class="token string">"jest --config test/unit/jest.conf.js --coverage"</span><span class="token punctuation">,</span>    <span class="token string">"e2e"</span><span class="token punctuation">:</span> <span class="token string">"node test/e2e/runner.js"</span><span class="token punctuation">,</span>    <span class="token string">"test"</span><span class="token punctuation">:</span> <span class="token string">"npm run unit &amp;&amp; npm run e2e"</span><span class="token punctuation">,</span>    <span class="token string">"lint"</span><span class="token punctuation">:</span> <span class="token string">"eslint --ext .js,.vue src test/unit test/e2e/specs"</span><span class="token punctuation">,</span>    <span class="token string">"build"</span><span class="token punctuation">:</span> <span class="token string">"node build/build.js"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以修改默认命令，或者添加命令。</p><h3 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h3><p>如果开启了eslint，会在外层有对应的配置文件，和Python flak8类似的工具</p><h3 id="build-目录"><a href="#build-目录" class="headerlink" title="build 目录"></a>build 目录</h3><p>主要放置和webpack工具相关的东西，这部分就是对新手来说不友好的地方了，因为我看过很多人的代码结构都不一样，你为了完全理解需要仔细学习webpack。</p><p>分开了开发和生产的配置，以及编译相关的东西。</p><h3 id="config-目录"><a href="#config-目录" class="headerlink" title="config 目录"></a>config 目录</h3><p>前面的 build 目录会读取 config 目录的内容，所以把配置修改放在这里。</p><h3 id="跨域处理"><a href="#跨域处理" class="headerlink" title="跨域处理"></a>跨域处理</h3><p>在开发阶段，是没有编译代码的，所以后端和前端的服务都需要启动，这就涉及到一个老生常谈的问题，跨域，解决方案是使用代理，在index.js中去配置它。</p><pre class="line-numbers language-js"><code class="language-js">proxyTable<span class="token punctuation">:</span> <span class="token punctuation">{</span>      <span class="token string">'/api'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 使用/api 来代替 target的内容，在ajax url 里面 /api/url</span>        target<span class="token punctuation">:</span> <span class="token string">'http://0.0.0.0:5000/'</span><span class="token punctuation">,</span>        changeOrigin<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        pathRewrite<span class="token punctuation">:</span> <span class="token punctuation">{</span>          <span class="token string">'^/api'</span><span class="token punctuation">:</span> <span class="token string">'http://0.0.0.0:8083'</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它把特定的请求代理了，由前端服务来向后端请求，这样就不会被浏览器认为使用了跨域。</p><h3 id="配置编译文件路径"><a href="#配置编译文件路径" class="headerlink" title="配置编译文件路径"></a>配置编译文件路径</h3><p>这也是非常重要的一个环节，默认的编译路径也许和后端配合不上，还要去改后端的代码，其实可以配置编译路径，比如使用 <code>/static/ele_ui_web/</code> 这样webpack组织文件的时候就是以这个路径为基准，然后把编译的代码放到flask的静态文件目录就可以了，flask静态文件搜索目录默认就是 <code>static</code>。</p><pre class="line-numbers language-js"><code class="language-js">build<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Template for index.html</span>    index<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'../static/index.html'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// Paths</span>    <span class="token comment" spellcheck="true">// assetsRoot: path.resolve(__dirname, '../dist'),</span>    assetsRoot<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'../static/ele_ui_web'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    assetsSubDirectory<span class="token punctuation">:</span> <span class="token string">'static'</span><span class="token punctuation">,</span>    assetsPublicPath<span class="token punctuation">:</span> <span class="token string">'/static/ele_ui_web/'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// If you are deployed on the root path, please use '/'</span>    <span class="token comment" spellcheck="true">// assetsPublicPath: '/',</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="src-源文件"><a href="#src-源文件" class="headerlink" title="src 源文件"></a>src 源文件</h2><p>src就是放源码的文件夹，其中有一个assets文件需要注意，放在该目录下的文件会直接在编译后，扔到对应的路径中，也就是说这个目录你应该用来存放图片或不参与编译的资源。</p><h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><p>存储api相关的内容，就是和后端交互的接口部分，接口请求推荐使用axios</p><p>主模块</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> axios <span class="token keyword">from</span> <span class="token string">'axios'</span><span class="token comment" spellcheck="true">// 创建代理请求axios的实例, 更进一步的需求请配置参数</span><span class="token keyword">const</span> service <span class="token operator">=</span> axios<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  timeout<span class="token punctuation">:</span> <span class="token number">3000</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">default</span> service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接口部分，对开发和生产做统一处理，每次请求就是调用一次service实例。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> base <span class="token keyword">from</span> <span class="token string">'./base'</span><span class="token comment" spellcheck="true">// 当前接口统一请求路径处理</span><span class="token keyword">let</span> baseApiUrl <span class="token operator">=</span> <span class="token string">''</span><span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>NODE_ENV <span class="token operator">===</span> <span class="token string">'development'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  baseApiUrl <span class="token operator">=</span> <span class="token string">'/api/api/'</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  baseApiUrl <span class="token operator">=</span> <span class="token string">'/api/'</span><span class="token punctuation">}</span><span class="token keyword">const</span> getUrl <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> baseApiUrl <span class="token operator">+</span> url<span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getPostList</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    url<span class="token punctuation">:</span> <span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token string">'post/getPostList'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    method<span class="token punctuation">:</span> <span class="token string">'post'</span><span class="token punctuation">,</span>    data<span class="token punctuation">:</span> params  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>由于走axios的请求和传统的ajax不同，这个更加原生，后端取数据需要注意</p></blockquote><h3 id="components-和-view"><a href="#components-和-view" class="headerlink" title="components 和 view"></a>components 和 view</h3><p>components，存放组件的文件，view可以理解为实际组织的页面</p><h3 id="utils"><a href="#utils" class="headerlink" title="utils"></a>utils</h3><p>utils 是工具文件，比如日期转换函数。</p><h3 id="最外层"><a href="#最外层" class="headerlink" title="最外层"></a>最外层</h3><p>分别有App.vue文件，一些全局的设置可以在这里，main.js 全局初始化，index.html html文件基本结构，可以用来修改head头等，vue挂载的DOM也在这里。</p><h3 id="element-UI"><a href="#element-UI" class="headerlink" title="element-UI"></a>element-UI</h3><p>本次项目使用的前端UI组件，按照官方的要求来安装即可，各个组件都有例子，可以从例子来修改，快速上手。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Technology技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> Python </tag>
            
            <tag> Technology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python web 开发(一) 后端架构</title>
      <link href="/2019/02/01/blog/advanced-python-web-01/"/>
      <url>/2019/02/01/blog/advanced-python-web-01/</url>
      
        <content type="html"><![CDATA[<p>Python web 开发总结篇，主要分析web开发中后端架构的设计，前端工程化，服务部署，测试等和web开发相关的整个流程。做了很多准备工作，编写了一个可以用的项目，主要为演示所用，后面会上传到GitHub上，整体功能就是通过ress获得数据用于展示，也可以当场一个快速上手的开发环境，它将包括很多常见的服务。</p><p>在之前差不多就构思好了，这次一次整理发出来，开篇从后端开始。</p><a id="more"></a><h2 id="python-做-web-开发"><a href="#python-做-web-开发" class="headerlink" title="python 做 web 开发"></a>python 做 web 开发</h2><p>web 开发在互联网的浪潮中经历了数次变革，各种技术层出不穷，做为一名后辈也许体会不到10年前的程序开发是什么样的，但是总结历史，才能放眼未来，开遍写对 web 开发的发展做个概述吧（就不套用资料了，用自己的话）</p><p>初期阶段，设计出了浏览器，当时的浏览器只能查看静态页面，后来为了能让浏览器有一定的交互性，设计了早期的JavaScript语言，我没记错的话，当时应该是叫其它名字。</p><p>即使是这样，和现今的浏览器还是有很大的差距的，首先它的页面也是事先写好的，想要动态的数据就需要由程序来生成，各种语言都来搞这个事情，于是提出了CGI这样的接口标准来实现CGI程序与WEB服务器之间的通信，当然现在也不用CGI这么原始的方式(在Python核心编程一书中有将如何用CGI来生成动态页面)，Python 的服务器网关接口称为 WSGI，很多web框架都实现了这个协议，到此解决了动态数据和各个程序之间的问题。</p><p>该聊聊前端了，在不断的开发和总结中，提出了一些设计模式，就是MVC，MVP等，个人认为不需要太多的去纠结你的架构属于什么模式，也许你复用了多个模式之间的东西，像Django也不好归属，一般说它是MTV，模型，模板，视图的架构。这些架构模式，不仅适应后端框架，还适应于前端框架，GUI软件等，所以模式真的太多了，有很多公司都不好把自己归在其中，其实好用的架构才是好的。对于前端我比较推崇的是MVVM这样的框架，也就是Vue，React，Angularjs。</p><p>python 在 web 开发中虽然占据一席之地，不过由于国内环境，Java是一家独大，这里有很多因素就不展开了。另外必须要承认的是Python做为动态语言，速度上是没法和静态语言相比的，这也Python经常被吐槽的原因，但是我认为这并不是你web应用的主要瓶颈，你需要的是合理的架构，因为在web开发中，速度不是决定一切的关键，IO经常需要等待，速度再快也没用；和开发者也有关，一个普通的开发者用静态语言写了同样的服务，他占着速度的优势也许差的程序跑起来也不会太差，而Python作为静态语言本身在速度上就有欠缺，当然更需要简练的代码。好在Python作为动态语言，有着开发速度快，语言简洁的优点，仍被众多开发者青睐。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在文章开始前，先对整个项目做下简介。</p><p>后端采用flask框架，用过Django后，又用flask，还是觉得falsk好，方便扩展，精简功能，舍弃不需要的，如果是想定制一套自己的开发框架，推荐用flask。</p><p>总结嘛，就是学之所用，整体的技术栈如下：</p><pre class="line-numbers language-m"><code class="language-m">1. 数据库    1. MySQL(主数据库)，使用SQLALchemy    2. Redis(缓存，副数据库)2. 任务队列    1. Celery    2. RabbitMQ    3. Redis3. 搜索服务    Elasticsearch4. 容器技术 Docker    1. docker-compose    2. Dockerfilea5. 前端    1. Vue 生态构建前端工程    2. elemet-UI 作为主要UI组件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前端采用了Vue的生态，也就是说整个项目都是走的接口来和后端交互。前端的项目和后端是分开的。</p><p>后面的文章将逐个分析项目内容，从后端到前端，最后到部署，总结一下在此过程中，为什么要选用它，应该怎么去用，以及一些可能会出现的坑。</p><p>GitHub地址在最后测试部分。</p><p>项目实现的功能为前端展示数据，数据库存储ress抓取到的数据，Redis也会用来存储部分数据。搜索功能使用了Elasticsearch，索引的创建由celery来执行，部署和开发阶段都用到了docker。</p><h2 id="项目分析"><a href="#项目分析" class="headerlink" title="项目分析"></a>项目分析</h2><p>该项目的工程构建，层级不是很多，各个模块归属一个文件夹，其中flask_app为核心部分，包含了flask相关的基础部分，base包含了核心服务的代码，模型都在models中，接口是api_views，celery任务在handler中，其它文件基本也是这样。</p><p>对于工程构建，有很多的模式，有些复杂的项目层级关系就很复杂，无论你怎么组织，对于flask来说，你应该注意：</p><ol><li><p>重复引用问题<br>这个问题在flask中尤为突出，flask就是创建 <code>app = Flask('flask_app')</code> ，全局围绕这个app展开，如果你不组织好，很容易因为相互导入app引发问题。</p></li><li><p>app实例的参数，Flask类需要传递一个文件名来创建实例，框架将根据它来组织文件搜索路径，官方的例子实在是过于简单了，我这里用的参数是flask_app，就是所处文件的名称，这里也可以配合 <code>__file__</code> 来动态处理。这个路径的错误将导致最大的问题就是静态文件搜索错误，可以通过DEBUG，分析app实例的path是否是正确的路径。</p></li><li><p>数据库管理工具Migrate，用这个迁移工具的时候，需要把对应的模型先加载，同样因为官方的例子过于简单，在组织工程的时候很容易忽视这个问题。查看源码就知道Migrate能够找到模型是在app的实例创建的命名空间去查找的，开始我一度认为是通过静态文件检查来实现的。本项目在创建app的时候，通过load_models()方法来加载模型。</p></li><li><p>最后再总结一点，flask整体就是围绕着app来的，报错了，从app实例创建一步一步的去分析，看看源码，很快就能定位问题了。另外像request这样的模块好像没和flask交互就拿到了请求参数，这里是使用了一个本地线程的功能，request通过本地线程做桥梁和app实例来沟通，有很多地方都用到这个本地线程。</p></li></ol><h3 id="app-py"><a href="#app-py" class="headerlink" title="app.py"></a>app.py</h3><p>该文件位于flask_app中，主要是创建app做准备，包括加载配置，注册命令，初始化扩展模块，并创建app实例，以提供外部使用，这是最简单的单例模式了，你的app一定要保证全局唯一，除非你需要新的app实例。</p><h3 id="setting-py"><a href="#setting-py" class="headerlink" title="setting.py"></a>setting.py</h3><p>配置文件内容，使用类的模式来组织，Config是基类，包含基本配置参数，日志配置也在此，DevConfig是开发配置，ProdConfig是生产配置，都继承了Config。</p><p>在需要用配置的地方，通过 <code>get_config</code> 来加载对应环境的配置，通过当前环境变量判断，环境变量设置在 <code>.evn</code> 中，通过 <code>load_env_value</code> 来加载，如果使用pipenv，或者autoenv这样的虚拟环境，会自己加载 <code>.env</code> 的东西。</p><h3 id="auto-app-py"><a href="#auto-app-py" class="headerlink" title="auto_app.py"></a>auto_app.py</h3><p>最外层的启动文件，主要就是实现migrate，返回app实例。</p><h2 id="Redis-服务"><a href="#Redis-服务" class="headerlink" title="Redis 服务"></a>Redis 服务</h2><p>Redis 在 web 开发中是必备，也可以用 Memcached，通常用做缓存，缓存可以说是web开发中最廉价的解决性能问题的方案了。</p><p>一定要记住，无论什么时候，都不要让用户轻易的访问到数据库，能用缓存的尽量用缓存，因为缓存是从内存读取，内存的寻址要快多了，而数据库，要连接服务，然后访问存储设备，然后通过索引等查询技术在文件中找到数据。</p><p>本项目的 Redis 用在了数据库和缓存两个地方，数据库用在了模型的字段上，通过一个描述符来处理：</p><pre class="line-numbers language-py"><code class="language-py">class PropsItem(object):    def __init__(self, name, default=None, output_filter=None, pre_set=None):        self.name = name        self.default = default        self.output_filter = output_filter        self.pre_set = pre_set    def __get__(self, obj, objtype):        r = obj.get_props_item(self.name, None)        if r is None:            return copy.deepcopy(self.default)        elif self.output_filter:            return self.output_filter(r)        else:            return r    def __set__(self, obj, value):        if self.pre_set:            value = self.pre_set(value)        obj.set_props_item(self.name, value)    def __delete__(self, obj):        obj.delete_props_item(self.name)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以这么用 content = PropsItem(‘content’)，set_props_item方法是Redis操作的封装，在base模块的redis_db中，机制都是自动更新的，对应的键更新。</p><p>另外在sqlalchemy的扩展部分，对属于Redis处理的字段做了标注</p><pre class="line-numbers language-py"><code class="language-py">class BindDBPropertyMixin(object):    def __init__(cls, name, bases, d):        super(BindDBPropertyMixin, cls).__init__(name, bases, d)        db_columns = []        # 这个d是每个模型类的属性字典，应用启动初始化数据就会执行到这里，这样实现了对每个模型类的定制        # 下面代码从模型类的属性中取出键值对，v就是类属性的值，        # 这里判断使用PropsItem实例作为字段的模型将添加_db_columns属性        for k, v in d.items():            if isinstance(v, PropsItem):                # k 为字段名称，v是实例对象                db_columns.append((k, v.default))        setattr(cls, '_db_columns', db_columns)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过对象的_db_columns就可以获取当前模型需要被Redis处理的字段，sqlalchemy的初始化在base模块的，base_extend.py 中。</p><h2 id="缓存服务"><a href="#缓存服务" class="headerlink" title="缓存服务"></a>缓存服务</h2><p>缓存要单独说，本项目用到了Redis缓存，数据库缓存，本地缓存。</p><ol><li>Redis 缓存</li></ol><p>Redis缓存比较简单，就是用装饰器，这是很通用的做法，在Python中，有@property，通过改造它，我们实行一个逻辑，把被装饰对象注入到当前实例 <code>__dict__</code> 中，这样每次的服务都不会再走代码，Django 提供的属性缓存就是这么做的。</p><p>这里实现的逻辑是去Redis中找，能找到就不计算属性，通过键来查找。</p><pre class="line-numbers language-py"><code class="language-py">def cache(key_pattern, expire=None):    def deco(f):        arg_names, varargs, varkw, defaults = inspect.getargspec(f)        if varargs or varkw:            raise Exception("do not support varargs")        gen_key = gen_key_factory(key_pattern, arg_names, defaults)        @wraps(f)        def _(*a, **kw):            key, args = gen_key(*a, **kw)            if not key:                return f(*a, **kw)            force = kw.pop('force', False)            r = rdb.get(key) if not force else None            if r is None:                r = f(*a, **kw)                if r is not None:                    if not isinstance(r, BUILTIN_TYPES):                        r = dumps(r)                    rdb.set(key, r, expire)                else:                    r = dumps(empty)                    rdb.set(key, r, expire)            try:                r = loads(r)            except (TypeError, UnpicklingError):                pass            if isinstance(r, Empty):                r = None            return r        _.original_function = f        return _    return deco<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这都是很标准的写法，利用该装饰器就可以实现基于Redis的缓存了，缓存的使用要注意何时清除缓存，数据被更新了就应该清除缓存。</p><ol start="2"><li>本地缓存</li></ol><p>除了使用Redis缓存，还可以使用本地缓存的办法，这是一种思想的体现，本地缓存就是把数据缓存在当前进程了，这样都不需要通过Redis，速度就更快了，这个的实现也很简单，写一个类把数据都缓存在这个类中。</p><p>当然这不是万能的，这相当于自己造轮子了，如果要用集群，相信Redis能提供更好的服务。</p><ol start="3"><li>数据库缓存</li></ol><p>这也是一种缓存方法，相当于对Redis的封装，通过特定的查询接口就可以获取被缓存的查询，不必每次去数据库找，和Redis装饰器相比更加灵活。</p><p>这部分的代码比较多，用法就是调用cache方法</p><pre class="line-numbers language-py"><code class="language-py">@declared_attr    def cache(cls):        return Cache(cls, cls.cache_regions, cls.cache_label)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>任务队列也是web中常用的技术，一般的web程序都是同步阻塞的IO模型，这表示一个请求如果耗时间很长，将会影响其它用户，所以我们不能把这种耗时长的任务直接在本次请求中执行，应该交给像celery这样的异步任务队列。</p><p>虽然有了异步编程，协程等方式不会一直阻塞进程，但是它们都是最大化利用cup的，该耗时的任务还是耗时，使用celery就可以解耦这些耗时的业务，让程序更加清晰，明确。</p><p>本项目中，使用RabbitMQ做为消息代理，Redis作为结果存储，配置对应的参数后就可以使用celery了，具体的用法参考<a href="http://www.liuzhidream.com/2018/10/22/Web/Celery/">Celery 在 web 开发中的运用</a></p><h2 id="搜索服务"><a href="#搜索服务" class="headerlink" title="搜索服务"></a>搜索服务</h2><p>以前我在写web的时候，对于搜索都是直接从数据库查询的，当数据需要从多张表中获取的时候，比较头疼了，需要把每张表都查一遍，当时也找过一些全局搜索的方案，只是没在项目中用起来。</p><p>本项目用了Elasticsearch，简单来说就是查询都是去查由Elasticsearch提供的数据，那这些数据怎么来的？就是事先创建的，有点像数据库的索引，使用Elasticsearch，相当于和数据库分割了，我们不会再去查询数据。</p><p>Elasticsearch其实也是一个数据库，它由Java编写，但是它的接口是走的http服务，这使得其它语言来使用它变得非常简单。你可能会疑问不是访问了另一个数据吗？对于速度上会有什么优势吗？其实像MySQL这样的数据库只要使用特定的引擎，查询效率会上升很多，但是为了兼顾存储，一般使用innodb，所以只要针对查询做特别的优化，就可以有不错的速度。</p><p>用法参考<a href="http://www.liuzhidream.com/2019/01/11/Web/elasticsearch/">elasticsearch 全文搜索解引擎在 web 开发中的运用</a></p><p>通过创建类来存储数据</p><pre class="line-numbers language-py"><code class="language-py">class Item(Document):    id = Integer()    title = Text()    kind = Integer()    content = Text()    n_likes = Integer()    n_collects = Integer()    n_comments = Integer()    can_show = Boolean()    created_at = Date()    tags = Text(fields={'raw': Keyword()})    class Index:        name = 'test'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过add方法，去插入新的索引，这个操作由celery来完成</p><h2 id="API-设计"><a href="#API-设计" class="headerlink" title="API 设计"></a>API 设计</h2><p>api设计也是老生常谈的话题，很多公司会遵循通用的方案，比如RESTFulAPI，通过使用规范的方案，便于程序阅读。这里没有使用RESTFulAPI，使用的我比较喜欢的一种风格，就是接口名称写在接口类中，每个接口对应一个方法，通过动态路由来匹配方法。</p><p>这样设计了一个可用的API方案，如果你要想像RESTFulAPI，那么规范一下请求，做多层路由。</p><p>这里的视图就应该使用类视图了，不要用函数视图，然后对类视图注册，把请求拦截后通过匹配对应的方法来执行。</p><p>大概是这样的：</p><pre class="line-numbers language-py"><code class="language-py">class APIHandelView(MethodView):    def dispatch_request(self, *args, **kwargs):        """        重载 dispatch_request 实现动态接口路由        """        api_name = kwargs.get('api_name')        api_method = getattr(self, api_name, None)        if api_method is None:            raise ApiException(errors.api_not_found)        return api_method()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的API风格还可以进行后续的扩展，比如请求方法的限制，权限控制等，都是需求上的东西了，这也是使用类视图的好处。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基本就用到了这些，都是一个web架构常见的服务，下面讲前端部分，配合后端的接口部分。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Technology技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> Python </tag>
            
            <tag> Technology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch 全文搜索解引擎在 Web 开发中的运用</title>
      <link href="/2019/01/11/Web/elasticsearch/"/>
      <url>/2019/01/11/Web/elasticsearch/</url>
      
        <content type="html"><![CDATA[<p>搜索服务是Web开发中非常常见的服务，一般比较基本的会直接访问到数据库，但是如果要查询多个数据库才能得到搜索结果，这无疑加大了数据库的负担，<br>而且频繁的访问数据库容易成为应用的瓶颈。可以使用elasticsearch来提供搜索服务，降低数据库的压力。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>elasticsearch是基于Java的，所以在安装的时候可能需要Java环境，使用Docker来运行服务会比较简单。Elastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。下面我们以单服务的形式在Docker中来使用它，为Web应用提供搜索服务支持。另外elasticsearch的操作其实是向服务发生请求。</p><h2 id="base"><a href="#base" class="headerlink" title="base"></a>base</h2><p>通俗的将Elastic就是一个数据库，它以索引Index为顶层单位，一个Index可以理解为一个数据库，其中里面的单条记录称为Document，同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。</p><p>关于Tyoe：</p><ol><li><p>Document 可以分组，比如weather这个 Index 里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document。</p></li><li><p>不同的 Type 应该有相似的结构（schema），举例来说，id字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的一个区别。性质完全不同的数据（比如products和logs）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。</p></li></ol><h2 id="在Python中使用elasticsearch"><a href="#在Python中使用elasticsearch" class="headerlink" title="在Python中使用elasticsearch"></a>在Python中使用elasticsearch</h2><p>首先，安装elasticsearch，这里我使用Docker来运行，默认端口为9200。然后安装elasticsearch-dsl，不要使用elasticsearch，因为elasticsearch是底层服务，我们需要使用像elasticsearch-dsl这样的高级封装库，它能更方便的编写和操作查询。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> elasticsearch_dsl <span class="token keyword">import</span> Document<span class="token punctuation">,</span> Integer<span class="token punctuation">,</span> Text<span class="token punctuation">,</span> Boolean<span class="token punctuation">,</span> Q<span class="token punctuation">,</span> Keyword<span class="token punctuation">,</span> SF<span class="token punctuation">,</span> Date<span class="token keyword">from</span> elasticsearch_dsl<span class="token punctuation">.</span>connections <span class="token keyword">import</span> connectionsconnections<span class="token punctuation">.</span>create_connection<span class="token punctuation">(</span>hosts<span class="token operator">=</span>ES_HOSTS<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 连接服务</span><span class="token keyword">class</span> <span class="token class-name">Item</span><span class="token punctuation">(</span>Document<span class="token punctuation">)</span><span class="token punctuation">:</span>    id <span class="token operator">=</span> Integer<span class="token punctuation">(</span><span class="token punctuation">)</span>    title <span class="token operator">=</span> Text<span class="token punctuation">(</span><span class="token punctuation">)</span>    kind <span class="token operator">=</span> Integer<span class="token punctuation">(</span><span class="token punctuation">)</span>    content <span class="token operator">=</span> Text<span class="token punctuation">(</span><span class="token punctuation">)</span>    can_show <span class="token operator">=</span> Boolean<span class="token punctuation">(</span><span class="token punctuation">)</span>    created_at <span class="token operator">=</span> Date<span class="token punctuation">(</span><span class="token punctuation">)</span>    tags <span class="token operator">=</span> Text<span class="token punctuation">(</span>fields<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'raw'</span><span class="token punctuation">:</span> Keyword<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">class</span> <span class="token class-name">Index</span><span class="token punctuation">:</span>        name <span class="token operator">=</span> <span class="token string">'test'</span> <span class="token comment" spellcheck="true"># 指定Index的名称</span>    @classmethod    <span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">:</span>        obj <span class="token operator">=</span> cls<span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        obj<span class="token punctuation">.</span>save<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> obj<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="bulk-进行批量操作"><a href="#bulk-进行批量操作" class="headerlink" title="bulk 进行批量操作"></a>bulk 进行批量操作</h2><p>bulk相关的API可以在单个请求中一次执行多个操作(index,udpate,create,delete)，这比执行多次操作性能要好。相关API在使elasticsearch.helpers中，helpers是bulk的帮助程序，是对bulk的封装。</p><p>有三种方式bulk（），streaming_bulk（），parallel_bulk（）</p><pre class="line-numbers language-py"><code class="language-py">items = []search = Items.search()objects = ({            '_op_type': 'update',            '_id': f'{doc.id}_{doc.kind}',            '_index': 'test',            '_type': 'doc',            '_source': doc.to_dict()        } for doc in items)client = connections.get_connection(search._using)rs = list(parallel_bulk(client, objects,                        chunk_size=500))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举例了parallel_bulk的用法，这里需要迭代才会执行，使用list</p><h2 id="版本总结"><a href="#版本总结" class="headerlink" title="版本总结"></a>版本总结</h2><p>es 7.0 对应  head 插件 5.x  这是我上次的坑 如果不用5.x 的head 会连不上es</p><p>es7可以不指定index来搜索了，默认index是_doc，而7一下还是要通过index来区别数据</p><p>es5可以指定多个type在一个index中，不建议这么做，es7不能再指定多个type</p><p>可以 用<em>模糊index查询 ，比如 `abc-</em>` * 可以是用户表示，这样就全文查询所有用户了</p><h2 id="restful-接口实例"><a href="#restful-接口实例" class="headerlink" title="restful 接口实例"></a>restful 接口实例</h2><p>就是用_search 然后带上请求体，请求体由es特定的语法组成<br>es7可以不指定index来搜索了，默认index是_doc，而7一下还是要通过index来区别数据</p><ul><li>查询所有的index</li></ul><p>curl -X GET ‘<a href="http://125.124.23.121:9200/_cat/indices?v'" target="_blank" rel="noopener">http://125.124.23.121:9200/_cat/indices?v'</a><br>curl -X GET ‘<a href="http://127.0.0.1:9200/_cat/indices?v'" target="_blank" rel="noopener">http://127.0.0.1:9200/_cat/indices?v'</a></p><ul><li>查询所有的mapping，type</li></ul><p>curl ‘localhost:9200/_mapping?pretty=true’</p><ul><li>查询所有记录</li></ul><p>curl ‘localhost:9200/traffic-zjyzsd/edrtraffic/AW5oGoTioA_5X_ZtZ_53?pretty=true’<br>curl ‘localhost:9200/my_index/my_index2/_search?pretty=true’  /索引/type   不指定索引就是查询全部类型</p><ol><li>使用match匹配，accounts索引下，type是person， 字段 是 desc ，字段内容包含 “软件的”</li></ol><p>$ curl ‘localhost:9200/accounts/person/_search’  -d ‘<br>{<br>  “query” : { “match” : { “desc” : “软件” }}<br>}’</p><ol start="2"><li>默认是10条记录，from指定开始位置，默认是0，从头开始，以此做分页</li></ol><p>$ curl ‘localhost:9200/accounts/person/_search’  -d ‘<br>{<br>  “query” : { “match” : { “desc” : “管理” }},<br>  “from”: 1,<br>  “size”: 1<br>}’</p><ol start="3"><li>Elastic 认为它们是or关系，就是满足一个就行</li></ol><p>$ curl ‘localhost:9200/accounts/person/_search’  -d ‘<br>{<br>  “query” : { “match” : { “desc” : “软件 系统” }}<br>}’</p><ol start="4"><li>如果要执行多个关键词的and搜索，必须使用布尔查询。</li></ol><p>$ curl ‘localhost:9200/accounts/person/_search’  -d ‘<br>{<br>  “query”: {<br>    “bool”: {<br>      “must”: [<br>        { “match”: { “desc”: “软件” } },<br>        { “match”: { “desc”: “系统” } }<br>      ]<br>    }<br>  }<br>}’</p><ol start="5"><li>根据id查询记录</li></ol><p>curl ‘localhost:9200/accounts/person/1?pretty=true’</p><ul><li>导入数据</li></ul><p>curl -H ‘Content-Type: application/x-ndjson’  -s -XPOST localhost:9200/_bulk –data-binary edr-test.json</p><ul><li>多条件查询</li></ul><p>curl ‘localhost:9200/edr-*/edrdoc/_search?pretty=true’  -d ‘{“size”:2, “query”: {“bool”: {“must”: [{ “term”: { “eventId” : “6002” } },{“term”: { “kid”:”KB3000483” } }]}}}’</p><ul><li>单条件查询，match和term</li></ul><p>curl ‘localhost:9200/edr-<em>/edrdoc/_search?pretty=true’ -d ‘{“query” : { “match” : { “kid” : “KB3000483” }}}’<br>curl ‘localhost:9200/edr-</em>/edrdoc/_search?pretty=true’ -d ‘{“query” : { “term” : { “eventId” : “6002” }}}’</p><ul><li>时间范围查询</li></ul><p>curl ‘localhost:9200/edr-*/edrdoc/_search?pretty=true’ -d ‘{“size”:10, “query”: {“range”: { “uploadtime”: { “gte”:1578436338552, “lte”: 1578436338559} } }}’</p><ul><li>删除数据，条件删除和匹配删除</li></ul><p>curl -X Delete ‘localhost:9200/edr-usertest/edrdoc/AXEvV–mxoIOfpIMeV0J</p><p>curl -X POST ‘localhost:9200/edr-usertest/edrdoc/_delete_by_query?pretty=true’ -d ‘{“query”: { “term” : { “id” : “9856519d-cd0b-486f-b8a8-17363159315f” }}}’</p><h2 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h2><p>直接在kibana 上执行 DELETE xx_sw* 索引可以用通配符，用来统一删除数据</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Middleware </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发</title>
      <link href="/2019/01/05/Java/concurrent/"/>
      <url>/2019/01/05/Java/concurrent/</url>
      
        <content type="html"><![CDATA[<p>review</p><a id="more"></a><h2 id="基础与名词解释"><a href="#基础与名词解释" class="headerlink" title="基础与名词解释"></a>基础与名词解释</h2><p>竞态条件: 多个线程竞争同一个资源，如果对资源的访问顺序敏感，就称存在竞态条件<br>临界区: 导致竞态条件发生的代码称为临界区</p><p>Java运行至少启动两个线程，一个是main线程，一个是垃圾回收线程(当然实际肯定不止，还有其它线程协调其它工作);Java启动的每一个进程都有一个独立的JVM</p><p>JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证(也就是线程A要向线程B发送消息，线程A要把数据先写到主内存，由线程B去主内存读取数据)</p><p>Java内存模型没有具体讲述前面讨论的执行策略是由编译器，CPU，缓存控制器还是其它机制促成的。甚至没有用开发人员所熟悉的类，对象及方法来讨论。取而代之，Java内存模型中仅仅定义了线程和内存之间那种抽象的关系。众所周知，每个线程都拥有自己的工作存储单元（缓存和寄存器的抽象）来存储线程当前使用的变量的值。Java内存模型仅仅保证了代码指令与变量操作的有序性，大多数规则都只是指出什么时候变量值应该在内存和线程工作内存之间传输。这些规则主要是为了解决如下三个相互牵连的问题：</p><ol><li>原子性：哪些指令必须是不可分割的。在Java内存模型中，这些规则需声明仅适用于-—实例变量和静态变量，也包括数组元素，但不包括方法中的局部变量-—的内存单元的简单读写操作。</li><li>可见性：在哪些情况下，一个线程执行的结果对另一个线程是可见的。这里需要关心的结果有，写入的字段以及读取这个字段所看到的值。</li><li>有序性：在什么情况下，某个线程的操作结果对其它线程来看是无序的。最主要的乱序执行问题主要表现在读写操作和赋值语句的相互执行顺序上。</li></ol><p>访问临界区，需要获取到锁，操作完，释放锁。而对于锁本身，也是一种临界资源，是不允许多个线程共同持有的，同一时刻，只能够一个线程持有</p><p>Java中有另外一个概念，叫做监视器，《深入Java虚拟机》中如下描述监视器：</p><p>可以将监视器比作一个建筑，它有一个很特别的房间，房间里有一些数据，而且在同一时间只能被一个线程占据。<br>一个线程从进入这个房间到它离开前，它可以独占地访问房间中的全部数据。如果用一些术语来定义这一系列动作：</p><p>进入这个建筑叫做“进入监视器”<br>进入建筑中的那个特别的房间叫作“获得监视器”<br>占据房间叫做“持有监视器”<br>离开房间叫做“释放监视器”<br>离开建筑叫做“退出监视器”</p><p>（对于开发者来说，你使用一个synchronized关键字就有了监视器的效果，监视器依赖JVM，而JVM依赖操作系统，操作系统则会进一步依赖软件甚至硬件，就是这样层层封装）<br>其实废话这么多，一个同步方法内（同步代码块）中所有的内容，就是属于同一个监视区域</p><p>现代处理器，单CPU多核，共享三级缓存，每个核心有2个二级缓存，上面是一级缓存。数据必须通过缓存加载到寄存器，CPU不会直接从内存加载数据</p><p>要理解JMM是一种抽象的概念，不是真实存在的，是一组规则，通过这组规则控制程序中各个变量在共享数据域和私有数据域的访问方式，什么规则呢？<br>就是围绕原子性，可见性，有序性展开的</p><p>操作系统进程创建调用fork，线程的创建调用pthread_create 都是c++提供的，主要是说Linux</p><p>编译优化: JIT除了具有缓存的功能外，还会对代码做各种优化。比如 逃逸分析、 锁消除、 锁膨胀、 方法内联、 空值检查消除、 类型检测消除、公共子表达式消除</p><p>JTI即时编译，通过热点探测机制把解释器翻译执行的热点代码编译成机器码，缓存起来，方便下次调用，通过对栈顶计数，对程序计数(超过阈值认为它是热点代码)，然后触发JIT，在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两个计数器:方法调用计数器和回边计数器</p><h2 id="并发编程模型的分类"><a href="#并发编程模型的分类" class="headerlink" title="并发编程模型的分类"></a>并发编程模型的分类</h2><p><code>在并发编程中，我们需要处理两个关键问题：</code></p><p>线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体），通信是指线程之间以何种机制来交换信息。</p><p><code>在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递</code></p><p>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。<br>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。</p><p><code>同步是指程序用于控制不同线程之间操作发生相对顺序的机制</code></p><p>在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。<br>在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p><h2 id="知识点概况"><a href="#知识点概况" class="headerlink" title="知识点概况"></a>知识点概况</h2><ol><li><p>竞态条件和临界资源</p></li><li><p>JMM – Java Memony Model 是一种抽象，一组规则，围绕着3个特性展开，如何做到这三点就是我们需要理解的</p><ol><li>原子性</li><li>有序性</li><li>可见性</li></ol></li><li><p>监视器 Monitor</p></li><li><p>JTI 即时编译，通过热点探测（对程序计数统计）</p></li><li><p>并发编程模型</p><p> 线程如何<code>通信</code>和<code>同步</code></p></li><li><p>上下文: 某一时间点，CPU寄存器和计数器的内容(还有栈信息等)，线程只需要保存这些内容做切换</p></li><li><p>CLH锁即Craig, Landin, and Hagersten (CLH) locks。CLH锁是一个自旋锁。能确保无饥饿性。提供先来先服务的公平性</p></li></ol><p>线程的上下文信息是保存在内存中的，切换回来的时候去内存中找到然后恢复到寄存器中</p><h2 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h2><ol><li>实现Runable接口</li><li>继承Thread类</li><li>实现Callable接口</li></ol><p>1，2都是类似的，3是用线程池</p><ol start="7"><li><p>被阻塞的线程不会消耗CPU，但是线程状态的转换需要相对比较长的时间</p></li><li><p>park unpark 挂起，恢复</p></li></ol><h2 id="start-和-run-方法的区别"><a href="#start-和-run-方法的区别" class="headerlink" title="start 和 run 方法的区别"></a>start 和 run 方法的区别</h2><p>start方法会创建线程，进入就绪状态，分配到时间的时候片执行run方法<br>直接用run方法不会有多线程，就和普通的方法一样</p><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><ol><li><p>wait(),join(),LockSupport.lock()方法线程会进入到WAITING</p></li><li><p>wait(long timeout)，sleep(long),join(long),LockSupport.parkNanos(),LockSupport.parkUtil()增加了超时等待的功能，也就是调用这些方法后线程会进入TIMED_WAITING</p></li><li><p>当超时等待时间到达后，线程会切换到Runable的状态，另外当WAITING和TIMED_WAITING状态时可以通过Object.notify(),Object.notifyAll()方法使线程转换到Runable状态</p></li><li><p>当线程出现资源竞争时，即等待获取锁的时候，线程会进入到BLOCKED阻塞状态</p></li><li><p>当线程获取锁时，线程进入到Runable状态</p></li><li><p>线程运行结束后，线程进入到TERMINATED状态</p></li><li><p>当线程进入到synchronized方法或者synchronized代码块时，线程切换到的是BLOCKED状态，而使用java.util.concurrent.locks下lock进行加锁的时候线程切换的是WAITING或者TIMED_WAITING状态，因为lock会调用LockSupport的方法。</p></li></ol><h2 id="线程基本操作"><a href="#线程基本操作" class="headerlink" title="线程基本操作"></a>线程基本操作</h2><ol><li>interrupted 中断</li></ol><p>主要关注标志位的状态，标志位用来做判断，<br>interrupted interrupt isInterrupted</p><ol start="2"><li><p>join</p></li><li><p>sleep</p></li></ol><p>sleep线程不会失去锁</p><p>sleep()方法是Thread的静态方法，而wait是Object实例方法</p><p>wait()方法必须要在同步方法或者同步块中调用，也就是必须已经获得对象锁。<br>而sleep()方法没有这个限制可以在任何地方种使用。另外，wait()方法会释放占有的对象锁，使得该线程进入等待池中，等待下一次获取资源。而sleep()方法只是会让出CPU并不会释放掉对象锁；</p><p>sleep()方法在休眠时间达到后如果再次获得CPU时间片就会继续执行，而wait()方法必须等待Object.notift/Object.notifyAll通知后，才会离开等待池，并且再次获得CPU时间片才会继续执行</p><ol start="4"><li>yield</li></ol><p>调用后当前线程让出时间片，拥有同级别优先级的线程可以去竞争该时间片，让出时间片后，加入到下一次的cpu资源竞争中</p><h2 id="获取线程的状态"><a href="#获取线程的状态" class="headerlink" title="获取线程的状态"></a>获取线程的状态</h2><pre class="line-numbers language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程唯一标识符："</span> <span class="token operator">+</span> thread<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程名称："</span> <span class="token operator">+</span> thread<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程状态："</span> <span class="token operator">+</span> thread<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程优先级："</span> <span class="token operator">+</span> thread<span class="token punctuation">.</span><span class="token function">getPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="notify-notifyAll"><a href="#notify-notifyAll" class="headerlink" title="notify notifyAll"></a>notify notifyAll</h2><h2 id="Daemon-守护线程"><a href="#Daemon-守护线程" class="headerlink" title="Daemon 守护线程"></a>Daemon 守护线程</h2><p>一个进程包含主线程，2个子线程，1个守护线程</p><p>主线程任务完成了，子线程任务也完成了，这个时候守护线程会自己结束，不管任务有没有完成</p><h2 id="什么是线程安全？"><a href="#什么是线程安全？" class="headerlink" title="什么是线程安全？"></a>什么是线程安全？</h2><p>当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获取正确的结果，那这个对象是线程安全的。</p><h2 id="线程通信，消费者和生产者编程实践"><a href="#线程通信，消费者和生产者编程实践" class="headerlink" title="线程通信，消费者和生产者编程实践"></a>线程通信，消费者和生产者编程实践</h2><h2 id="Java中共享变量是哪些？"><a href="#Java中共享变量是哪些？" class="headerlink" title="Java中共享变量是哪些？"></a>Java中共享变量是哪些？</h2><p>方法中的局部变量不是共享的，实例域，静态域和数组元素都是在堆内存中的，是共享的</p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>分类</p><ol><li>编译器优化的重排序</li></ol><p>编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序</p><ol start="2"><li>指令级并行的重排序</li></ol><p>现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序</p><ol start="3"><li>内存系统的重排序</li></ol><p>由于处理器使用缓存，读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的，详细说明下这种情况</p><p>举例: </p><ul><li>什么是缓冲区</li></ul><p>发生这种情况是由于处理器使用了缓冲区，比如对变量的写入先写到缓冲区，然后再刷新到主存(现代的处理器使用写缓冲区来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟)</p><ul><li>场景</li></ul><p>理解这个概念后，有一段代码执行顺序是这样的，A，B线程，先写a=1，b=2到主存，然后读取主存共享变量 a=b=0</p><ul><li>执行情况</li></ul><p>内存的操作情况是 写，然后读(<code>写-&gt;读</code>) 然而有缓冲区，可能是写到缓冲区后，读主存，然后缓冲区刷新到主存(<code>读-&gt;写</code>)</p><ul><li>结论</li></ul><p>由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。可以用</p><p>常见的处理器都允许Store-Load重排序；<br>常见的处理器都不允许对存在数据依赖的操作做重排序。sparc-TSO和x86拥有相对较强的处理器内存模型，它们<code>仅允许对写-读操作做重排序</code>（因为它们都使用了写缓冲区）</p><ul><li>通过内存屏障解决重排序问题</li></ul><p>Java编译器通过插入内存屏障来解决重排序，内存屏障是指令，依托于处理器的实现，使用内存屏障有一定的性能损坏，因为原来通过缓冲区加快了处理器指令流水的运行，使用内存屏障就是要先把缓冲区数据刷新到主存后，才执行后面的指令</p><ul><li>内存屏障指令举例 </li></ul><p><code>LoadLoad Barriers</code>    </p><p>Load1; LoadLoad; Load2   确保Load1数据的装载，之前于Load2及所有后续装载指令的装载</p><p><code>StoreLoad Barriers</code>   </p><p>Store1; StoreStore; Store2  确保Store1数据对其他处理器可见（刷新到内存），之前于Store2及所有后续存储指令的存储</p><p><code>LoadStore Barriers</code>   </p><p>Load1; LoadStore; Store2   确保Load1数据装载，之前于Store2及所有后续的存储指令刷新到内存</p><p><code>StoreLoad Barriers</code>   </p><p>Store1; StoreLoad; Load2   确保Store1数据对其他处理器变得可见（指刷新到内存），之前于Load2及所有后续装载指令的装。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令</p><ul><li>内存屏障总结</li></ul><p>StoreLoad Barriers 是现代处理器都会支持的(其它的不一定)。总的来说内存屏障指令之前的指令，会先执行，有写操作的都要刷新主存后，后面的指令才执行，这样后面的指令就能读到前一个指令写入的数据(从主存读)，实现了数据的可见性</p><p><code>重排序</code></p><p>对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序(不是所有的编译器重排序都要禁止)。对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障(memory barriers，intel称之为memory fence)指令，通过内存屏障指令来禁止特定类型的处理器重排序(不是所有的处理器重排序都要禁止)</p><p>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证</p><p>总结: 重排序是对Java源代码编译后的字节码做排序，现代处理都能并行处理，也就是一次执行多条指令，而旧体系的处理器或者单片机是按照时钟周期一条一条指令执行的。编译器编译源代码，处理器去执行语句都可能发生重排序</p><h2 id="什么时候不能重排序？"><a href="#什么时候不能重排序？" class="headerlink" title="什么时候不能重排序？"></a>什么时候不能重排序？</h2><p>发生数据依赖的时候，不能重排序</p><p>如果两个操作访问同一个变量，且这两个操作有一个为写操作，此时这两个操作就存在数据依赖性，体现在<code>有写操作</code>上</p><p>读后写，写后读，写后写 都是数据依赖  读后读  没关系，都是读取</p><h2 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h2><p>遵守as-if-serial语义的编译器，runtime和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的</p><h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>通过happens-before来描述内存可见性，或者说是<code>用来描述可见性的一种规则</code></p><h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><p>指的是使用了缓存和数据库的情况下，如何保证数据一致性，我们会把高频读的数据放到缓存，但是修改数据库的时候需要把缓存删除，再建立新的</p><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>Java线程之间的通信由Java内存模型（简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。</p><p>从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。</p><h2 id="JMM相关操作"><a href="#JMM相关操作" class="headerlink" title="JMM相关操作"></a>JMM相关操作</h2><p>lock(锁定)：作用于主内存的变量，把一个变量标记为一条线程独占状态<br>unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定<br>read(读取)：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用<br>load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中<br>use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎<br>assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量<br>store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作<br>write(写入)：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中</p><p>这个只需要知道个大概就行了:</p><p>从主存复制到工作内存 -&gt; 就需要按顺序地执行read和load操作<br>从工作内存复制到主存 -&gt; 就需要按顺序地执行store和write操作</p><h2 id="Java内存模型同步规则"><a href="#Java内存模型同步规则" class="headerlink" title="Java内存模型同步规则"></a>Java内存模型同步规则</h2><p>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中</p><p>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或者assign）的变量。即就是对一个变量实施use和store操作之前，必须先自行assign和load操作</p><p>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现</p><p>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量之前需要重新执行load或assign操作初始化变量的值</p><p>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。<br>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）</p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile缓存可见性实现原理</p><p>JMM内存交互层面：volatile修饰的变量的read、load、use操作和assign、store、write必须是连续的，即修改后必须立即同步会主内存，使用时必须从主内存刷新，由此保证volatile变量的可见性。<br>底层实现：通过汇编lock前缀指令，它会锁定变量缓存行区域并写回主内存，这个操作称为“缓存锁定”，缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据。一个处理器的缓存回写到内存内存会导致其他处理器的缓存无效</p><p>汇编代码查看 -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -Xcomp (可以借助idea工具，把参数加到执行后面，观察汇编指令)</p><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><ul><li>实现Runnable接口</li><li>继承Thread类</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> concurrent<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"run method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程唯一标识符："</span> <span class="token operator">+</span> thread<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程名称："</span> <span class="token operator">+</span> thread<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程状态："</span> <span class="token operator">+</span> thread<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程优先级："</span> <span class="token operator">+</span> thread<span class="token punctuation">.</span><span class="token function">getPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">MyThread2</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"run myThread2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MyThread2 myThread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        myThread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>从1到10，1最低，10最高</p><h2 id="线程状态-1"><a href="#线程状态-1" class="headerlink" title="线程状态"></a>线程状态</h2><p>new 新建<br>runnable 可运行<br>blocked 阻塞<br>waiting 等待<br>time waiting 定时等待<br>terminated 终止</p><p>状态转换流程</p><ol><li>线程创建，进入new状态</li><li>调用 start 方法，进入 runnable 状态</li><li>JVM 按照线程优先级及时间分片等执行 runnable 状态的线程。开始执行时，进入 running 状态</li><li>如果线程执行 sleep、wait、join，或者进入 IO 阻塞等。进入 wait 或者 blocked 状态</li><li>线程执行完毕后，线程被线程队列移除。最后为 terminated 状态</li></ol><h2 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h2><p>CPU多个核是共享内存的，当2个核都要去操作变量i的时候，如何保证数据一致性？</p><p>方式:</p><ol><li>总线加锁(非常耗损性能)</li><li>缓存一致性协议</li></ol><p>现代处理器通过操作系统和处理器架构，配合特定的指令集实现缓存一致性</p><p>比较常见的协议: MESI</p><p>M 修改 Modified<br>E 独占 Exclusive<br>S 共享 Shared<br>I 无效 Invalid</p><p>流程举例:</p><ol><li>主存有变量i，CPU1读取变量i，变量变成E(独占)</li><li>CPU2读取变量i，通过广播和<code>总线嗅探机制</code>，此时变量i在CPU1和CPU2中都变成S(共享)</li><li>CPU1修改了变量i，在CPU1中，i变成M(修改)，通过总线嗅探，CPU2中i变成I(无效)</li><li>如果CPU2需要用到i，就需要从主存重新读取，此时就等待CPU1的i回写到主存。注意CPU1修改了i之后，由于CPU2的i I(无效)，此时CPU1的i是E(独占)，并且这个修改不会直接写到主存，需要在某个特定的时间点才会写入</li><li>i写入后，CPU2读取到，此时CPU1和CPU2的i又变成S(共享)</li></ol><h3 id="锁缓存行"><a href="#锁缓存行" class="headerlink" title="锁缓存行"></a>锁缓存行</h3><p>通过LOCK指令来实现的缓存一致性协议，有一个缓存行的概念 cache line 64byte</p><p>什么情况下不能用缓存一致性协议</p><ol><li>不支持(现代处理器都支持)</li><li>跨缓存行，就是超过了cache line的大小，此时就会用锁总线</li></ol><p><code>/sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size</code> 感兴趣可以看看这里的东西，这个文件记录了cache line大小，为64</p><h3 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h3><p>LRU 最近最少使用的，会被淘汰掉，在CPU的cache中就是被踢出了</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>用法分类，可以分为实例和类</p><p>给一个对象上锁，如果对象是静态的，那么就是和类有关的，就是类锁，方法也是同样的道理，也就是说首先要区分是类锁还是实例锁<br>使用了对象锁，如果临界区代码没有和被锁住的对象有交集，那么锁消除不会出现竞争</p><p>实例锁: 同一个实例访问有竞争，不同实例访问没有<br>类锁: 会拦截所有线程的访问</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-JVM 知识点总结</title>
      <link href="/2018/12/05/Java/java-jvm/"/>
      <url>/2018/12/05/Java/java-jvm/</url>
      
        <content type="html"><![CDATA[<p>JVM虚拟机总结笔记</p><h2 id="Java内存模型-内存结构"><a href="#Java内存模型-内存结构" class="headerlink" title="Java内存模型(内存结构)"></a>Java内存模型(内存结构)</h2><ol><li>堆内存 Hape</li><li>方法区(或者叫永久代) Method Area(PermGen)  jdk1.8更换为 元空间 Metaspace</li><li>线程私有空间</li></ol><p>Java内存结构分为三大块，1和2是线程共享的，我们需要理解这3块的含义和作用，基本上现代语言都是数据程序在内存中分离的，数据程序合并的在一些教学书本上有体现，比如8位，10位等处理器的汇编编程，程序简单，空间有限，所以不需要数据和程序分类，对于jvm，数据就是在1中，程序在3中执行，把类信息放在2上 — <code>"算法+数据结构=程序"</code></p><p><img src="/images/Java/Java-jvm-construction.png" alt="image"></p><h3 id="线程私有空间"><a href="#线程私有空间" class="headerlink" title="线程私有空间"></a>线程私有空间</h3><p>每个线程都会分配一个独立的空间，内部又划分为: </p><ol><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ol><p>程序计数器存储当前线程执行的字节码行号；虚拟机栈存储当前线程方法栈帧，每个方法被执行的时候都会创建一个栈帧；本地方法栈和虚拟机栈类似，区别在在于存储的是native方法的栈帧，也就是jvm C++实现的调用，每个线程都有一个独立的程序计数器，虚拟机栈是在方法执行的时候创建栈帧的，不存在垃圾回收问题，线程结束就释放，生命周期和线程一致</p><p>虚拟机栈结构图</p><p><img src="/images/Java/Java-jvm-stack.png" alt="image"></p><p>虚拟机栈的栈帧又分为: </p><ol><li><p>局部变量表: 局部变量表是变量值的存储空间，用于存放方法参数和方法内部定义的局部变量，对象引用</p></li><li><p>操作数栈: 在方法执行的过程中，会有各种字节码指令往操作数栈中入栈和出栈内容，操作数栈开辟的空间就是用来处理这些运算的</p></li><li><p>方法出口: 一个方法开始执行后，只有两种方式可以退出这个方法</p></li></ol><p>1）是执行引擎遇到任意一个方法返回的字节码指令: 传递给上层的方法调用者，是否有返回值和返回值类型将根据遇到何种方法来返回指令决定，这种退出的方法称为<code>正常完成出口</code><br>2）方法执行过程中遇到异常: 无论是java虚拟机内部产生的异常还是代码中throw出的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出的方式称为<code>异常完成出口</code></p><p>无论使用那种方式退出方法，都要返回到方法被调用的位置，程序才能继续执行</p><ol start="4"><li>动态链接: 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中方法的符号引用为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用（静态方法，私有方法等），这种转化称为静态解析，另一部分将在每一次运行期间转化为直接引用，这部分称为动态连接</li></ol><p>有一个异常StackOverflowError异常，就是方法的栈帧超过最大深度引起的</p><blockquote><p>总结:<br>理解程序计数器和虚拟机栈的作用，虚拟机栈的栈帧，debug调试的时候就是走了一个方法入栈出栈的过程，理解这个栈帧特别重要。至于局部变量表，操作数栈等主要是分析字节码的时候用的，方法出口也是比较偏向底层，动态链接也是一个编程专用的术语，做了解即可</p></blockquote><h3 id="线程共享空间"><a href="#线程共享空间" class="headerlink" title="线程共享空间"></a>线程共享空间</h3><p>堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，Eden空间(伊甸园区)、From Survivor空间(幸存者区)、To Survivor空间，默认情况下年轻代按照8:1:1的比例来分配，堆是垃圾回收重点关注的空间，之所以这么划分，是为了更好地回收内存，或者更快地分配内存。现代垃圾回收多采用分代回收算法</p><p>方法区存储类信息(类的元数据)、常量、静态变量等数据，jdk1.8改用元空间，关于这个元空间，还有很多可以展开的，元空间的出现，是因为以前永久代经常内存不足，所以改用了新的实现，最大的特点就是元空间是直接使用本地内存空间的，虽然如此，仍然是可配置的</p><p>控制参数</p><ul><li>-Xms设置堆的最小空间大小。</li><li>-Xmx设置堆的最大空间大小。</li><li>-XX:NewSize设置新生代最小空间大小。</li><li>-XX:MaxNewSize设置新生代最大空间大小。</li><li>-XX:PermSize设置永久代最小空间大小。 1.8后不适用</li><li>-XX:MaxPermSize设置永久代最大空间大小。 1.8后不适用</li><li>-XX:SurvivorRatio设置Eden和其中一个Survivor的比值</li><li>-Xss设置每个线程的堆栈大小。</li></ul><p>没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制。若要配置元空间，Metaspace相关的参数进行配置</p><blockquote><p>老年代空间大小=堆空间大小-年轻代大空间大小</p></blockquote><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>主要讨论Hotspot虚拟机的垃圾回收机制，虚拟机技术并不是Java的专利，很多语言都会使用虚拟机技术。gc是自动进行的，手动执行方法是<code>System.gc()</code>和<code>Runtime.gc()</code>，一般很少去用手动gc</p><p>垃圾回收大致经过这样一个流程: 新创建的对象都在Eden区分配，存在时间长的对象会进入From Surivor区(S0区)，更长的会进入To Survivor(S1区)，这是新生代的过程，存在更久的对象，进会进入老年代。永久代也是有垃圾回收的，比如类卸载，不过一般不关注，但是要知道，不是进入永久代的数据就是永久的</p><p><code>这里要重点聊聊为什么新生代要这样分配</code></p><p>详细流程：</p><ol><li>新对象都是进入Eden</li><li>在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的</li><li>执行GC，所有活下来的对象从Eden进入To区(使用复制算法)，From区的对象满足阈值的进入老年代，不满足的进入To区</li><li>GC执行完，From此时是空的，To区增加了对象</li><li>这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”</li><li>继续GC，不管怎样，都会保证名为To的Survivor区域是空的，直到To满了，所有对象移动到老年代</li></ol><p>Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代</p><p>为什么要有两个survivor区，是为了避免碎片化，只有一个survivor区会导致survivor的空间使用不连续，因为survivor会有存活的对象，有些进入老年代后就空下了空间，导致内存不连续，通过2个survivor互相交换就很好的解决了这个问题</p><p>至于8:1:1的比例，也是因为复制算法，和需要2个survivor做的合理分配</p><p><strong>如何进行GC？这个问题和垃圾回收器相关，不同的垃圾回收器的策略不一样</strong></p><p><code>有以下几种常见的策略:</code></p><ol><li>young GC: </li></ol><p>当Eden区满了触发，有些数据也会直接晋升到老年代，所以young GC时，老年代数据有增长是正常现象</p><ol start="2"><li>full GC: </li></ol><p>当准备要触发一次young GC时，如果发现统计数据说之前young GC的平均晋升大小比目前old gen剩余的空间大，则不会触发young GC而是转为触发full GC</p><ol start="3"><li>Minor GC</li></ol><p>Minor GC发生在Eden区；Young GC发生在Eden、S0、S1区；Major GC发生在Old区</p><p><code>触发条件:</code></p><ol><li><p>Minor GC触发条件：当Eden区满时，触发Minor GC</p></li><li><p>Full GC触发条件：</p></li></ol><p>1)调用System.gc时，系统建议执行Full GC，但是不必然执行</p><p>2)老年代空间不足</p><p>3)方法去空间不足</p><p>4)通过Minor GC后进入老年代的平均大小大于老年代的可用内存</p><p>5)由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</p><p><code>对象什么时候进入老年代？</code></p><ol><li>根据年龄</li></ol><p>JVM会给对象增加一个年龄（age）的计数器，对象每“熬过”一次GC，年龄就要+1，待对象到达设置的阈值（默认为15岁）就会被移移动到老年代，可通过 -XX:MaxTenuringThreshold调整这个阈值</p><ol start="2"><li>动态年龄判断</li></ol><p>根据对象年龄有另外一个策略也会让对象进入老年代，不用等待15次GC之后进入老年代，他的大致规则就是，假如当前放对象的Survivor，一批对象的总大小大于这块Survivor内存的50%，那么大于这批对象年龄的对象，就可以直接进入老年代了</p><p>举个例子，假如s1区大小是10M，有a=1M,b2M,c=1M,d=3M,e=1M 5个对象，把它们大小排序，然后从最小的开始相加，a+c+e+b+d a,c,e,b合计5M，达到50%了，那么d就直接进入老年代</p><ol start="3"><li>大对象直接进入老年代</li></ol><p>如果设置了 -XX:PretenureSizeThreshold这个参数，那么如果你要创建的对象大于这个参数的值，比如分配一个超大的字节数组，此时就直接把这个大对象放入到老年代，不会经过新生代</p><h3 id="什么是Stop-the-world？"><a href="#什么是Stop-the-world？" class="headerlink" title="什么是Stop the world？"></a>什么是Stop the world？</h3><p>Java中Stop-The-World机制简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互；这些现象多半是由于gc引起。</p><p>GC时的Stop the World(STW)是大家最大的敌人。但可能很多人还不清楚，除了GC，JVM下还会发生停顿现象。</p><p>JVM里有一条特殊的线程－－VM Threads，专门用来执行一些特殊的VM Operation，比如分派GC，thread dump等，这些任务，都需要整个Heap，以及所有线程的状态是静止的，一致的才能进行。所以JVM引入了安全点(Safe Point)的概念，想办法在需要进行VM Operation时，通知所有的线程进入一个静止的安全点。</p><p>除了GC，其他触发安全点的VM Operation包括：</p><ol><li><p>JIT相关，比如Code deoptimization, Flushing code cache ；</p></li><li><p>Class redefinition (e.g. javaagent，AOP代码植入的产生的instrumentation) ；</p></li><li><p>Biased lock revocation 取消偏向锁 ；</p></li><li><p>Various debug operation (e.g. thread dump or deadlock check)；</p></li></ol><h3 id="SafePoint-是什么"><a href="#SafePoint-是什么" class="headerlink" title="SafePoint 是什么?"></a>SafePoint 是什么?</h3><p>GC不是什么时候都能进行的，必须要等程序进入一个“安全点”，Java 线程都进入到 safepoint 的时候 VMThread 才能开始执行 GC</p><ol><li><p>循环的末尾 (防止大循环的时候一直不进入 safepoint，而其他线程在等待它进入safepoint)</p></li><li><p>方法返回前</p></li><li><p>调用方法的 call 之后</p></li><li><p>抛出异常的位置</p></li></ol><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><ol><li>标记—清除算法（Mark-Sweep）<br>把被标记的地方清楚掉，该区域就空余出来了，如果是连续的内存分配无法使用该区域</li></ol><p>不足:<br>标记和清除过程效率都不高<br>会产生大量碎片，内存碎片过多可能导致无法给大对象分配内存。</p><ol start="2"><li>复制算法（Copying）<br>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理</li></ol><p>不足:<br>将内存缩小为原来的一半，浪费了一半的内存空间，代价太高；如果不想浪费一半的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法<br>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低</p><ol start="3"><li>标记—整理算法（Mark-Compact）<br>与1类似，多了整理的过程</li></ol><p>不足:<br>效率不高，不仅要标记存活对象，还要整理所有存活对象的引用地址，在效率上不如复制算法</p><ol start="4"><li>分代收集算法(Generational Collection)<br>是复制算法和标记算法的整合，对不同区域使用不同策略</li></ol><p>新生代：由于新生代产生很多临时对象，大量对象需要进行回收，所以采用复制算法是最高效的。<br>老年代：回收的对象很少，都是经过几次标记后都不是可回收的状态转移到老年代的，所以仅有少量对象需要回收，故采用标记清除或者标记整理算法。</p><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p>垃圾回收器才是真正执行GC的程序，在了解垃圾回收器之前，需要知道如何判断对象是否需要回收，有引用计数法和可达性分析算法</p><p>由于引用计数很难处理对象循环引用问题，多少采用可达性分析算法</p><p>有一个GC Roots的对象作为起点，以下对象可以作为起点</p><ol><li><p>虚拟机栈中引用的对象</p></li><li><p>方法区中类静态属性引用的对象 </p></li><li><p>方法区中的常量引用的对象</p></li><li><p>本地方法栈中JNI（即一般说的Native方法）的引用的对象</p></li></ol><p>从这些起点向下走过的路径，称为引用链，当一个对象到CG Root没有任何引用链的话，则说明此对象不可用</p><blockquote><p>补充: 即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize方法。当对象没有覆盖finalize方法，或finalize方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收</p></blockquote><p>理解了对象如何被标记为可以，还有一个<code>对象引用类型</code>的概念</p><ol><li><p>强引用 一般我们new创建的，只有被标记为null了，才会被回收</p></li><li><p>软引用 内存不足的时候就会回收，不管你对象还在不在用，软引用的访问可以直达内存，类似高速缓存的效果，不用从堆中查找</p></li></ol><pre class="line-numbers language-java"><code class="language-java">Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> SoftReference<span class="token operator">&lt;</span>Object<span class="token operator">></span> sf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> obj <span class="token operator">=</span> null<span class="token punctuation">;</span> sf<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//有时候会返回null</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="3"><li>弱引用 被gc线程找到就会回收，或者说存在感低，有一些资料上说，第二次gc的时候会回收，在ThreadLocal中有使用</li></ol><pre class="line-numbers language-java"><code class="language-java">Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> WeakReference<span class="token operator">&lt;</span>Object<span class="token operator">></span> wf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>obj <span class="token operator">=</span> null<span class="token punctuation">;</span> wf<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//有时候会返回null wf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>虚引用 取不到，但是有相关的方法获取状态，可以用来判断对象是否已经从内存中删除</li></ol><pre class="line-numbers language-java"><code class="language-java">Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> PhantomReference<span class="token operator">&lt;</span>Object<span class="token operator">></span> pf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> obj<span class="token operator">=</span>null<span class="token punctuation">;</span> pf<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//永远返回null</span>pf<span class="token punctuation">.</span><span class="token function">isEnQueued</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回是否从内存中已经删除</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>有人可能会问，这些类型有什么用呢？看上面的代码，除了强引用外，其它引用都是拿强引用创建的，比如软引用，我们就可以得到对象的一个缓存高速访问，不过很少见到代码中这样用，慎重</p></blockquote><p><strong>接下来可以聊聊垃圾收集器了，它是回收算法的具体实现，由于gc的时候会swt，所以延伸了很多垃圾回收器，没有万能的垃圾回收器</strong></p><ol><li><p>Serial收集器 简单高效，单线程，swt影响严重</p></li><li><p>ParNew收集器 Serial的多线程版</p></li><li><p>Parallel Scavenge收集器 它的特定就是注重CPU的利用率，就是尽量不swt</p></li><li><p>Serial Old收集器 Serial的老年代版</p></li><li><p>Parallel Old收集器 Parallel Old收集器 的老年代版</p></li><li><p>CMS收集器（Concurrent Mark Sweep） 特点就是swt占用时间短</p></li><li><p>G1 从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的</p></li></ol><h2 id="类加载机制和流程"><a href="#类加载机制和流程" class="headerlink" title="类加载机制和流程"></a>类加载机制和流程</h2><p>该主题主要讲class文件如何被加载到jvm中去的，整个流程为: 加载，验证，准备，解析，初始化，这里不展开了</p><p>需要重点了解的是加载器和加载器工作流程(使用了双亲委派)</p><p>加载器分类:</p><ol><li><p>启动类加载器 Bootstrap ClassLoader，由jvm来提供</p></li><li><p>扩展类加载器 Extension ClassLoader</p></li><li><p>应用程序加载器或系统类加载器 Application ClassLoader</p></li></ol><p>加载过程(双亲委派):<br>appcl要加载一个类，不是它来加载，而是由它的父类就是extcl来加载，而extcl又把这个加载委托给它的父类bootcl，如果加载成功就返回，否则就重新由appcl来加载。appcl会委托父类进行加载的前提是缓存中没有找到这个类，比如第一次加载的时候</p><p>之所以使用双亲委派，是为了避免重复加载，先使用系统的。比如你自定义了java.util.HashMap类，执行的时候会去使用系统的</p><p>可以调用Class对象的getClassLoader方法获取加载器，调用getParent获取父加载器，启动类加载器java获取不到，会打印null</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>javafx<span class="token punctuation">.</span>PlatformUtil<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassLodersDemo</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>      Object object <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      ClassLodersDemo demo<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ClassLodersDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>object<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// null</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//java拿不到, null</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ClassLodersDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//app</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>PlatformUtil<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//ext</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>demo<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ext</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>demo<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//null</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="默认堆大小"><a href="#默认堆大小" class="headerlink" title="默认堆大小"></a>默认堆大小</h2><p>默认堆大小：<br>若没有在命令行中指定了初始化和最大的堆大小，则取决于计算机上的的物理内存大小</p><p>服务器端的默认堆大小<br>初始化堆大小：客户端JVM相同<br>最大堆小大：<br>32位的JVM上，物理内存小于192MB时，为物理内存的一半；物理内存大192MB且小于4GB时，为物理内存的四分之一；大于等于4GB时，都为1GB<br>64位的JVM上，物理内存小于192MB时，为物理内存的一半；物理内存大192MB且小于128GB时，为物理内存的四分之一；大于等于128GB时，都为32GB</p><p><code>System.out.println(Runtime.getRuntime().maxMemory());</code>可以打印，以我的计算机为例，结果是3817865216，差不多就是16GB的四分之一</p><p>经过测试，spring boot项目，什么都不配置，每次启动的Heap可用空间会有不同，而且可用保持不变的，下次启动会改变。最大空间固定</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/duanxz/p/6076662.html" target="_blank" rel="noopener">https://www.cnblogs.com/duanxz/p/6076662.html</a><br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html#default_heap_size" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html#default_heap_size</a></p><h2 id="常量池、运行时常量池、字符串常量池"><a href="#常量池、运行时常量池、字符串常量池" class="headerlink" title="常量池、运行时常量池、字符串常量池"></a>常量池、运行时常量池、字符串常量池</h2><p>经常会看到这些概念，这里做个总结</p><p><code>常量池</code>：即class文件常量池，是class文件的一部分，用于保存编译时确定的数据</p><p>class文件常量池在元空间中</p><p><img src="/images/Java/Java-jvm-const.png" alt="image"></p><p>可以用命令javap -verbose class文件(比如Test) Classfile class文件地址 查看</p><p><code>运行时常量池</code>：</p><p>Java语言并不要求常量一定只能在编译期产生，运行期间也可能产生新的常量，这些常量被放在运行时常量池中。</p><p>类加载后，常量池中的数据会在运行时常量池中存放！</p><p>这里所说的常量包括：基本类型包装类（包装类不管理浮点型，整形只会管理-128到127，不在这个范围的包装类型会创建新的对象，在堆空间）和String（也可以通过String.intern()方法可以强制将String放入常量池）</p><p><code>字符串常量池</code>：</p><p>HotSpot VM里，记录interned string的一个全局表叫做StringTable，它本质上就是个HashSet<string>。注意它只存储对java.lang.String实例的引用，而不存储String对象的内容。就是我们创建String包装类型，如果是同样的内容，那么引入指向同一个地方，就在字符串常量池存储引用，当然数据本身是在方法区中分配的</string></p><p>jdk 1.7后，移除了方法区(可能这么说也不规范，方法区是虚拟机规范的称呼，应该说是移除永久代吧)，<code>运行时常量池</code>在<code>方法区</code>里，<code>字符串常量池</code>在<code>堆</code>中，数据在方法区中</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Framework 与 Spring Boot</title>
      <link href="/2018/11/01/Java/Spring-framework/"/>
      <url>/2018/11/01/Java/Spring-framework/</url>
      
        <content type="html"><![CDATA[<p>Spring Framework</p><a id="more"></a><h2 id="Ioc-设计理念"><a href="#Ioc-设计理念" class="headerlink" title="Ioc 设计理念"></a>Ioc 设计理念</h2><p>IoC(Inversion of Control)控制反转；依赖注⼊(dependency injection, DI)。它是⼀个对象定义依赖关系的过程，也就是说，对象只通过构造函数参数、⼯⼚⽅法的参数或对象实例构造或从⼯⼚⽅法返回后在对象实例上设置的属性来定义它们所使⽤的其他对象。</p><p>然后容器在创建bean时注⼊这些依赖项。这个过程基本上是bean的逆过程，因此称为控制反转(IoC) 在Spring中，构成应⽤程序主⼲并由Spring IoC容器管理的对象称为bean。</p><p>bean是由Spring IoC容器实例化、组装和管理的对象。IoC容器设计理念: 通过容器统⼀对象的构建⽅式，并且⾃动维护对象的依赖关系。</p><p>IOC流程: <code>装配</code>–&gt;<code>解析</code>–&gt;<code>注册</code></p><p>本次笔记会比较乱，主要围绕各个散的知识点补充，然后就是<code>装配</code>–&gt;<code>解析</code>–&gt;<code>注册</code>这个流程，这个流程完成后，才能拿到bean，我们通常都是通过ApplicationContext来操作，不直接通过BeanFactory，下面是AnnotationConfigApplicationContext的构造器，传递的是Class对象，之后register(componentClasses)，注册，refresh()，刷新，得到上下文，bean可以获取到</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> componentClasses<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">register</span><span class="token punctuation">(</span>componentClasses<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="bean的装配方式"><a href="#bean的装配方式" class="headerlink" title="bean的装配方式"></a>bean的装配方式</h2><p>通过xml或Java代码的方式进行装配，官方推荐用<code>@Confinguration</code>加方法<code>@Bean</code>的方式进行装配</p><h3 id="1、xml装配"><a href="#1、xml装配" class="headerlink" title="1、xml装配"></a>1、xml装配</h3><p>比较传统的装配</p><ol><li>xml编写</li></ol><ul><li><p>关于bean的name和id，id是唯一标识，name是别名，一个bean可用有多个name</p></li><li><p>配置文件中不允许出现两个id相同的，否则在初始化时即会报错</p></li><li><p>但配置文件中允许出现两个name相同的，在用getBean()返回实例时，后面一个Bean被返回，应该是前面那个被后面同名的 覆盖了为了避免不经意的同名覆盖的现象，尽量用id属性而不要用name属性。如果id和name都没有指定，则用类全名作为name，如，则你可以通过getBean(“com.stamen.BeanLifeCycleImpl”)返回该实例</p></li></ul><ol start="2"><li>通过上下文获取</li></ol><pre class="line-numbers language-java"><code class="language-java">ApplicationContext context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"spring.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>记得使用ClassPathXmlApplicationContext类创建上下文</p><h3 id="2、-Configuration-Bean"><a href="#2、-Configuration-Bean" class="headerlink" title="2、@Configuration + @Bean"></a>2、@Configuration + @Bean</h3><p>用@Configuration注释类，表明这个类是一个Bean的定义源<br>@Configuration允许调用同类中的其它@Bean方法来定义bean之间的关系，如下面的address中，调用了@Bean注释的user方法</p><p>一个被 @Configuration 标注的类，相当于一个 applicationContext.xml 的配置文件，这句话的意思就是，xml能做到的事情，可以用@Configuration 标注一个类来做到，除了@Bean外，还有很多的注解来对应xml中的标签</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>     <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> User <span class="token function">user</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Address <span class="token function">address</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Address</span><span class="token punctuation">(</span><span class="token function">user</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、-ComponentScan-Component"><a href="#3、-ComponentScan-Component" class="headerlink" title="3、@ComponentScan + @Component"></a>3、@ComponentScan + @Component</h3><p>比较常用的方式，记得ComponentScan配置正确的包的扫描范围，否则报错找不到<code>BeanDefinition</code></p><p>配置包扫描后，类被 @Component 注解标识后，类就被注入</p><p>包扫描配置示例: <code>@ComponentScan(basePackages="com.learn.spring.bean")</code></p><p>spring boot的包扫描</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>excludeFilters <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FilterType<span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span> classes <span class="token operator">=</span> TypeExcludeFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FilterType<span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span> classes <span class="token operator">=</span> AutoConfigurationExcludeFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>细心的人会发现，在我们单独使用这个注解的时候，需要配置扫描路径，而spring boot没有配置，其实注解只是标识，spring boot在自动装配中去做这个事情，它要取主启动类所在包及子包下的组件。就呼应了文档注释中的描述，也解释了为什么 SpringBoot 的启动器一定要在所有类的最外层</p><p>特别注意：</p><ul><li>针对2和3的情况中，也就是用Java代码的方式装配，关于Configuration的作用</li><li>在2中，可以不用Configuration，也可以在3中，ComponentScan注解的类上加入Configuration，那么这个Configuration有什么作用？</li><li>在Configuration注解后，获取的bean都是同一个，也就是从缓存获取的</li></ul><p>用@Configuration注解标注的类表明其主要目的是作为bean定义的源，@Configuration类允许通过调用同一类中的其他@Bean方法来定义bean之间的依赖关系</p><blockquote><p>补充 @Indexed 注解</p><p><a href="https://www.cnblogs.com/aflyun/p/11992101.html" target="_blank" rel="noopener">https://www.cnblogs.com/aflyun/p/11992101.html</a> 发现有这么一个东西，@Indexed注解，默认@Component就被@Indexed注解的，说是用了@Indexed，打包项目后读取META-INT/spring.components，不做包扫描，提高性能，不过要配置开启才行（我测试了确实如此）这个东西作用大吗？难道它这个转换比IOC反射效率高吗？还是强在省去了扫描步骤，该反射还是逃不过的</p></blockquote><h2 id="BeanPostProcessor接口"><a href="#BeanPostProcessor接口" class="headerlink" title="BeanPostProcessor接口"></a>BeanPostProcessor接口</h2><p>bean的后置处理器，类可以实现该接口，可以让bean在创建的生命周期中的特定时间点，执行代码</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CatBeanPostProcessor</span> <span class="token keyword">implements</span> <span class="token class-name">BeanPostProcessor</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">postProcessBeforeInitialization</span><span class="token punctuation">(</span>Object bean<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">Cat</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Cat postProcessBeforeInitialization run..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">postProcessAfterInitialization</span><span class="token punctuation">(</span>Object bean<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>bean <span class="token keyword">instanceof</span> <span class="token class-name">Cat</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Cat postProcessAfterInitialization run..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="关于生命周期"><a href="#关于生命周期" class="headerlink" title="关于生命周期"></a>关于生命周期</h2><p>如果bean 实现了BeanNameAware  接口，Spring  传递bean  的ID  到 setBeanName 方法。<br>如果 Bean 实现了 BeanFactoryAware 接口， Spring 传递beanfactory 给 setBeanFactory 方 法 。<br>如果有任何与 bean 相关联的 BeanPostProcessors，Spring 会在postProcesserBeforeInitialization()方法内调用它们。<br>如果 bean 实现 IntializingBean 了，调用它的 afterPropertySet 方法， 如果 bean 声明了初始化方法，调用此初始化方法。<br>如果有 BeanPostProcessors 和 bean 关联，这些 bean 的postProcessAfterInitialization() 方法将被调用。<br>如果 bean 实现了 DisposableBean，它将调用 destroy()方法。</p><h2 id="ioc-流程"><a href="#ioc-流程" class="headerlink" title="ioc 流程"></a>ioc 流程</h2><p>内置bean和我们自己的bean</p><p>beanFactory</p><p>DefaultListableBeanFactory 工厂实现类，bean就在里面</p><p>注册内置bean给工厂，也就是加入 beanDefinitionMap 中</p><p>//  ConfigurationClassPostProcessor<br>//  AutowiredAnnotationBeanPostProcessor<br>//  CommonAnnotationBeanPostProcessor<br>//     EventListenerMethodProcessor<br>//     DefaultEventListenerFactory</p><p>添加2个后置处理器给工厂，这里是把class对象赋值到 beanFactory 的 beanPostProcessors 属性中，这个是一个CopyOnWriteArrayList类型的属性</p><p>ApplicationContextAwareProcessor,<br>ApplicationListenerDetector</p><h2 id="使用-Autowired注解警告Field-injection-is-not-recommended"><a href="#使用-Autowired注解警告Field-injection-is-not-recommended" class="headerlink" title="使用@Autowired注解警告Field injection is not recommended"></a>使用@Autowired注解警告Field injection is not recommended</h2><p>这个警告的意思是 <code>使用变量依赖注入的方式是不被推荐的</code>，属于不严谨的警告</p><p>idea推荐 Always use constructor based dependency injection in your beans. Always use assertions for mandatory dependencies</p><p>意思是 <code>总是使用构造器的方式强制注入</code></p><p>依赖注入有三种方式：</p><p>变量（filed）注入<br>构造器注入<br>set方法注入<br>工厂注入(好像是xml才有的)</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> RestTemplate restTemplate<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// set方法注入，不会有</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setRestTemplate</span><span class="token punctuation">(</span>RestTemplate restTemplate<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>restTemplate <span class="token operator">=</span> restTemplate<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 这么写就会有告警</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> ConsistentHashing consistentHashing<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 构造器注入就不写了，和set注入类似，构造器注入可以不用@Autowired注解</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实这是一个很值得深挖的问题，因为我发现很多人都这么写，就是用变量注入。原因如下：</p><ol><li>这整个问题只是一个规范性的问题，但是好的规范肯定有它存在的意义，后面会说</li><li>以前的idea是不会有这个问题的，新的版本有，说明spring在新版本中加强了规范</li></ol><p>要讨论这个问题前，先说2个概念</p><ol><li><p>强制依赖: 在类被加载运行的时候就必须给他的依赖就是强制依赖，构造方法型依赖注入就是强制性，你初始化这个类就要给我这个依赖 </p></li><li><p>选择依赖: 就是它在初始化的时候IOC不会给你注入，直到你使用到这个依赖时它才会把这个依赖给这个类，比如当你调用这个依赖的方法时才会给你把这个依赖给你注入进去，变量注入和set方法注入都是选择依赖</p></li></ol><p>优点: 变量方式注入非常简洁，没有任何多余代码，非常有效的提高了java的简洁性。即使再多几个依赖一样能解决掉这个问题。</p><p>缺点: 不能有效的指明依赖。相信很多人都遇见过一个bug，依赖注入的对象为null，在启动依赖容器时遇到这个问题都是配置的依赖注入少了一个注解什么的，然而这种方式就过于依赖注入容器了，当没有启动整个依赖容器时，这个类就不能运转，在反射时无法提供这个类需要的依赖。<br>在使用set方式时，这是一种选择注入，可有可无，即使没有注入这个依赖，那么也不会影响整个类的运行。<br>在使用构造器方式时已经显式注明必须强制注入。通过强制指明依赖注入来保证这个类的运行。</p><p>另一个方面:<br>依赖注入的核心思想之一就是被容器管理的类不应该依赖被容器管理的依赖，换成白话来说就是如果这个类使用了依赖注入的类，那么这个类摆脱了这几个依赖必须也能正常运行。然而使用变量注入的方式是不能保证这点的。<br>既然使用了依赖注入方式，那么就表明这个类不再对这些依赖负责，这些都由容器管理，那么如何清楚的知道这个类需要哪些依赖呢？它就要使用set方法方式注入或者构造器注入</p><p>总结下: 变量方式注入应该尽量避免，使用set方式注入或者构造器注入，这两种方式的选择就要看这个类是强制依赖的话就用构造器方式，选择依赖的话就用set方法注入</p><p>看了上面的一些设计思想，再结合业务聊聊3个的区别</p><p><code>变量注入和set注入可以不强制依赖，看起来好像这两个是一样，但是set注入有方法啊，可以在方法里面做判断，比如依赖不存在就做其它事情(给一个默认的实例等w)，这样整个类下面的代码逻辑就不会因为选择依赖问题而报错null，没错，说这么多，这句话就是核心，这也是为什么idea不推荐用变量注入，如果注入失败，类后面依赖这个变量的代码都有问题</code></p><p><code>好像依赖注入很好啊，为什么还有构造器注入呢？因为选择依赖不能暴露问题，如果你业务需求就是这个依赖没程序无法执行，那么构造器依赖就可以在程序运行的时候暴露出这个问题了</code></p><p><code>最后一点，是构造器依赖才能做到的，那就是声名final类型，final类型变量要求实例化的时候要赋值，方法注入和set注入都不能实现</code></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> RestTemplate restTemplate<span class="token punctuation">;</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">public</span> <span class="token function">RrdtoolController</span><span class="token punctuation">(</span>ConsistentHashing consistentHashing<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>consistentHashing <span class="token operator">=</span> consistentHashing<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setRestTemplate</span><span class="token punctuation">(</span>RestTemplate restTemplate<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>restTemplate <span class="token operator">=</span> restTemplate<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">final</span> ConsistentHashing consistentHashing<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考原文链接：<br><a href="https://blog.csdn.net/zhangjingao/article/details/81094529" target="_blank" rel="noopener">https://blog.csdn.net/zhangjingao/article/details/81094529</a></p><p><a href="https://blog.csdn.net/w57685321/article/details/86244753?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/w57685321/article/details/86244753?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></p><h2 id="Spring-boot-知识点收集"><a href="#Spring-boot-知识点收集" class="headerlink" title="Spring boot 知识点收集"></a>Spring boot 知识点收集</h2><ol><li><p>配置: server.context-path 就是在请求上加个默认路径</p></li><li><p>@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})</p></li></ol><p>排除此类的autoconfig，比如我们引入了mybatis的依赖，按照Spring的规范，就要装配对应的bean，没有配置数据库会报错。这个时候就能用这个注解来取消某些类的自动装配</p><ol start="3"><li>@EnableDiscoveryClient与@EnableEurekaClient</li></ol><p>都是服务client用的，如果用eureka之外的，用EnableDiscoveryClient，主要是为了组件通用化，可以通过注解参数取消服务注册，新版本可以去掉注解，具体看使用哪个版本</p><ol start="4"><li><p>spring-cloud-config-client 和 spring-cloud-starter-config 都是配置依赖，区别是一个是starter风格的</p></li><li><p>@Component(组件) @Service(业务层) @Controller(web控制层) @Repository(持久层，持久层数据一般提供CURD) 都是组件，等效的，不过语义不一样</p></li></ol><p>@Controller，装载的bean名称默认是类名首字母小写的名称，可以指定名称</p><p>@Service 用在一个接口的实现类上面</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token punctuation">(</span><span class="token string">"UserDetailsService"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserDetailsServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UserDetailsService</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>@Service(“UserDetailsService”)注解是告诉Spring，当Spring要创建UserDetailsServiceImpl的的实例时，bean的名字必须叫做”UserDetailsService”，这样当Action需要使用UserServiceImpl的的实例时,就可以由Spring创建好的”UserDetailsService”，然后注入给Action：在Action只需要声明一个名字叫“UserDetailsService”的变量来接收由Spring注入的”UserDetailsService”即可，具体代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 注入UserDetailsService</span><span class="token annotation punctuation">@Resource</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"UserDetailsService"</span><span class="token punctuation">)</span><span class="token keyword">private</span> UserDetailsService userDetailsService<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>@Resource的作用相当于@Autowired，只不过@Autowired按byType自动注入，而@Resource默认按 byName自动注入罢了</strong></p><p>@Repository对应数据访问层Bean</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Repository</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"userDao"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserDaoImpl</span> <span class="token keyword">extends</span> <span class="token class-name">BaseDaoImpl</span><span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li>@ConfigurationProperties(prefix = “mysql”)</li></ol><p>使用这个注解，可以把配置的属性装配到对象上，mysql是配置文件中的属性前缀，下面把url的属性拿到，实例对象的时候就用配置的属性去实例化</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"mysql"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MysqlData</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String url<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//    private Integer port;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> MysqlData mysqlData<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="7"><li>@Primary @Qualifier</li></ol><p>这两个注解都是用来对于Autowrite装配的时候，如果有多个实现，可以使用这两个注解<br>Qualifier接收一个参数指明实现的名称，和Autowrite一起使用，Primary只能存在一个(比如有2个实现，只能用在其中一个实现类上)，被注解的实现类优先用于Autowrite装配</p><ol start="8"><li>@EnableAutoConfiguration</li></ol><p>对自动装配这个点再做一些补充</p><p>要知道Spring的思想就是约定大于配置，这个注解在@SpringBootApplication下已经包含了，当我们使用pom引入依赖的时候，这些依赖的bean就会被装配的，主要就是自动装配发挥了作用，而约定就是这些依赖要按照一定的规范去开发，大家都遵守这些约定，才能被Spring装配到</p><p>getCandidateConfigurations  读取spring-boot项目的classpath下META-INF/spring.factories的内容</p><ol start="9"><li>修改系统服务的默认地址</li></ol><p>例如在监控中: 如果对<a href="http://localhost:8030/hystrix" target="_blank" rel="noopener">http://localhost:8030/hystrix</a> 地址中的hystrix 小尾巴不满意怎么办？还记得Spring MVC的服务器端跳转（forward）吗？只需添加类似如下的Controller，就可以使用<a href="http://localhost:8030/" target="_blank" rel="noopener">http://localhost:8030/</a> 访问到Hystrix Dashboard首页了。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HystrixIndexController</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> String <span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">"forward:/hystrix"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="10"><li>@PathVariable(“patientId”) Long id</li></ol><p>把路由中匹配的参数在方法中形参重定义，下面的例子中，注解不传递参数，默认就是把形参和url参数对应，可以传参数然后重新定义形参</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/get/{id}/{ex}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> ResponseBean<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">getCacheValue</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> String id<span class="token punctuation">,</span> <span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"ex"</span><span class="token punctuation">)</span> String abc<span class="token punctuation">)</span><span class="token punctuation">{</span>        String data <span class="token operator">=</span> metricCacheService<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ResponseBean</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="11"><li>profiles</li></ol><pre class="line-numbers language-yml"><code class="language-yml">profiles: dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-yml"><code class="language-yml">profiles:  active: dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>要记住上面两种写法是不一样的，第二种是”激活“的意思，就是激活哪个profiles文件，而第一个是准备多个profiles文件的时候用</p><ol start="12"><li><p>SpringBoot中获取ApplicationContext</p></li><li><p>通过注解 <code>@Autowired</code></p></li><li><p>通过构造器注入</p></li><li><p>实现spring提供的接口 ApplicationContextAware</p></li></ol><p>spring 在bean 初始化后会判断是不是ApplicationContextAware的子类，调用setApplicationContext（）方法， 会将容器中ApplicationContext传入进去</p><p><code>org.springframework.context.support.ApplicationContextAwareProcessor#invokeAwareInterfaces</code> 源码在这里。就是利用了后置处理器，默认添加的<code>ApplicationContextAwareProcessor</code>， 在refresh方法中，调用prepareBeanFactory方法，去添加后置处理器，源码是这里: <code>beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</code></p><p>使用举例:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationContextAware</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> ApplicationContext applicationContext<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setApplicationContext</span><span class="token punctuation">(</span>ApplicationContext applicationContext<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext <span class="token operator">=</span> applicationContext<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="13"><li>@ConditionalOnProperty(name = “spring.redis.cluster.nodes”, matchIfMissing = false)</li></ol><p>是条件装配，配置属性有spring.redis.cluster.nodes才装配，matchIfMissing是: 该属性为true时，配置文件中缺少对应的value或name的对应的属性值，也会注入成功，也就是说，如果设置true，没有spring.redis.cluster.nodes也会装配成功</p><p>havingValue = “true” 可以配置这个属性，表明name=spring.redis.cluster.nodes获取到的是否和havingValue相同，相同才装配</p><ol start="14"><li>@RequestBody 使用和不使用的区别</li></ol><p>使用：处理application/json 的数据，就是json类型的，框架会自动帮我们转换json数据为实体类<br>不使用：处理 multipart/form-data 和 application/x-www-form-urlencoded 的数据，就是表单提交的</p><ol start="15"><li>server.use-forward-headers 配置</li></ol><p>这个配置和HTTP协议的 X-Forwarded-For，X-Forwarded-Proto 属性有关</p><p>当客户端请求服务器，如果经过了负载均衡服务器到达应用服务器<br>server.use-forward-headers = false 应用服务器获取到的IP是负载均衡服务器的<br>server.use-forward-headers = true  应用服务器获取到的IP是客户端的<br>以上是资料查到的，没有做太多的测试，留个记录</p><ol start="16"><li>BeanUtils.copyProperties</li></ol><p>spring提供的bean拷贝工具 BeanUtils.copyProperties(源对象，目标对象)  目标对象的字段在源对象中存在，那么就会把源对象的值赋值给目标对象</p><ol start="17"><li>Spring 中@NotNull, @NotEmpty和@NotBlank之间的区别是什么</li></ol><pre class="line-numbers language-s"><code class="language-s">@NotNull://CharSequence, Collection, Map 和 Array 对象不能是 null, 但可以是空集（size = 0）。  @NotEmpty://CharSequence, Collection, Map 和 Array 对象不能是 null 并且相关对象的 size 大于 0。  @NotBlank://String 不是 null 且去除两端空白字符后的长度（trimmed length）大于 0，也就是传 “” 会报错<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="关于属性的含义与idea"><a href="#关于属性的含义与idea" class="headerlink" title="关于属性的含义与idea"></a>关于属性的含义与idea</h2><p>可以点击进去查看源码注释</p><p>/Users/liuzhi/.m2/repository/org/springframework/boot/spring-boot-actuator-autoconfigure/2.2.2.RELEASE/spring-boot-actuator-autoconfigure-2.2.2.RELEASE.jar!/META-INF/spring-configuration-metadata.json</p><p>在这个文件中，有相关的描述，idea就是读取了这个json文件做到属性预读取，和错误判断，比如你写的属性不支持是依据这个json文件来的</p><p>另外这个json文件只是一部分，但是整个idea能够判断你的属性是否正确并给出提示，就是依赖于json文件</p><p>可以自定义json，让不支持的属性也能被idea识别，该方法可以用来对大型项目做管理，对自定义的属性有严格的规范，这样就能通过idea一眼判断出是否有人写了不符合的属性</p><h2 id="java-jar-和-直接main方法运行的区别"><a href="#java-jar-和-直接main方法运行的区别" class="headerlink" title="java -jar 和 直接main方法运行的区别"></a>java -jar 和 直接main方法运行的区别</h2><p>把jar解压后，查看META-INF下的jar信息文件</p><pre><code>Manifest-Version: 1.0Implementation-Title: kafka-demoImplementation-Version: 0.0.1-SNAPSHOTStart-Class: com.liuzhidream.kafka.demo.KafkaDemoApplicationSpring-Boot-Classes: BOOT-INF/classes/Spring-Boot-Lib: BOOT-INF/lib/Build-Jdk-Spec: 1.8Spring-Boot-Version: 2.1.11.RELEASECreated-By: Maven Archiver 3.4.0Main-Class: org.springframework.boot.loader.JarLauncher</code></pre><p>有一个<code>Start-Class</code>。jar包的规范是由Main-Class为入口的，如果我们写一个类打成jar，那个带main方法的类就会在<code>Main-Class</code>标注，注意这是jar包的规范。这里Main-Class是<code>org.springframework.boot.loader.JarLauncher</code>，说明启动类是org.springframework.boot.loader.JarLauncher，这和直接main运行有区别了，spring boot 的jar包是通过JarLauncher去调用Start-Class标注的我们自己的启动类<code>KafkaDemoApplication</code>来运行项目的</p><p>这是一个扩展点，如果遇到一些问题，可以查看jar包信息是否正确</p><p>如果想看源码，要引入spring-boot-loader依赖，<code>/Users/liuzhi/.m2/repository/org/springframework/boot/spring-boot-loader/2.1.11.RELEASE/spring-boot-loader-2.1.11.RELEASE.jar!/org/springframework/boot/loader/JarLauncher.class</code> main方法在这，感兴趣可以深入</p><p>主要聊的是一些启动方式</p><p>mvnspring‐boot:run</p><p>boot早期版本可能会是直接启动JarLauncher javaorg.springframework.boot.loader.JarLauncher</p><h2 id="关于swagger"><a href="#关于swagger" class="headerlink" title="关于swagger"></a>关于swagger</h2><p>其实swagger是有两个版本的，而且区别还挺大的，一个是swagger-ui也就是swagger1;还有一个是springfox-swagger也就是swagger2;</p><p>Swagger Spec 是一个规范。<br>Swagger Api 是 Swagger Spec 规范 的一个实现，它支持 jax-rs, restlet, jersey 等等。<br>Springfox libraries 是 Swagger Spec 规范 的另一个实现，专注于 spring 生态系统。<br>Swagger.js and Swagger-ui 是 javascript 的客户端库，可以使用 Swagger Spec规范 。<br>springfox-swagger-ui 仅仅是以一种方便的方式封装了 swagger-ui ，使得 Spring 服务可以提供服务。</p><p>总结下来就是：</p><p>Swagger 是一种规范。<br>springfox-swagger 是基于 Spring 生态系统的该规范的实现。<br>springfox-swagger-ui 是对 swagger-ui 的封装，使得其可以使用 Spring 的服务。</p><p>常规用法</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- swagger --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springfox-swagger2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>${swagger.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springfox-swagger-ui<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>${swagger.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第三方UI实现</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springfox-swagger2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>${swagger.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springfox-bean-validators<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>${swagger.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springfox-swagger-ui<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>${swagger.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.github.xiaoymin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>swagger-bootstrap-ui<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.9.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="swagger具体配置"><a href="#swagger具体配置" class="headerlink" title="swagger具体配置"></a>swagger具体配置</h3><p>引入依赖后，需要进行配置</p><p>使用@EnableSwagger2注解后，spring boot自动装配机制就会加载对应的bean</p><p>编写一个配置类，注入配置bean，如下所示</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> Docket <span class="token function">createRestApi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Docket</span><span class="token punctuation">(</span>DocumentationType<span class="token punctuation">.</span>SWAGGER_2<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">apiInfo</span><span class="token punctuation">(</span><span class="token function">apiInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 为当前包下controller生成API文档</span>            <span class="token punctuation">.</span><span class="token function">apis</span><span class="token punctuation">(</span>RequestHandlerSelectors<span class="token punctuation">.</span><span class="token function">basePackage</span><span class="token punctuation">(</span><span class="token string">"com.XXX.controller"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 为有@Api注解的Controller生成API文档</span>            <span class="token comment" spellcheck="true">// .apis(RequestHandlerSelectors.withClassAnnotation(Api.class))</span>            <span class="token comment" spellcheck="true">// 为有@ApiOperation注解的方法生成API文档</span>            <span class="token comment" spellcheck="true">// .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))</span>            <span class="token punctuation">.</span><span class="token function">paths</span><span class="token punctuation">(</span>PathSelectors<span class="token punctuation">.</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> ApiInfo <span class="token function">apiInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ApiInfoBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">title</span><span class="token punctuation">(</span><span class="token string">"SwaggerUI演示"</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">description</span><span class="token punctuation">(</span><span class="token string">"api"</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">contact</span><span class="token punctuation">(</span><span class="token string">"macro"</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">version</span><span class="token punctuation">(</span><span class="token string">"1.0"</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就完成了一个简单的aip接口文档配置，这里主要是要返回一个Docket对象，随便看了一下源码，好像是没有默认实现的，应该是要我们自己去实现，具体的要看源码和文档了，这里不追究了，不是讨论的重点</p><h3 id="token"><a href="#token" class="headerlink" title="token"></a>token</h3><p>原生的swagger是没有和鉴权相关的，针对这点，还需要调整配置</p><p>大致的做法就是在创建Docket对象的时候，去配置它</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//添加登录认证</span><span class="token punctuation">.</span><span class="token function">securitySchemes</span><span class="token punctuation">(</span><span class="token function">securitySchemes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">securityContexts</span><span class="token punctuation">(</span><span class="token function">securityContexts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>两个方法返回数组或者用这种形式<span class="token punctuation">.</span><span class="token function">globalOperationParameters</span><span class="token punctuation">(</span>pars<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="关于日志的使用和配置"><a href="#关于日志的使用和配置" class="headerlink" title="关于日志的使用和配置"></a>关于日志的使用和配置</h2><p>首先先回顾和总结一下各个日志模块，以及它们之间的关系</p><p>Java提供的日志类是 <code>java.util.logging</code>，创建实例，然后调用对应日志级别的方法就能输出日志了</p><p><code>Commons Logging</code>是一个第三方日志库，特点是它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统<br>默认情况下，Commons Loggin自动搜索并使用Log4j（Log4j是另一个流行的日志系统），如果没有找到Log4j，再使用JDK Logging</p><p><code>Log4j</code> 聊到了一个Log4j，Log4j是Commons Logging的实现，可以说Commons Logging是一个接口</p><p><code>SLF4J 和 Logback</code>，SLF4J类似于Commons Logging，也是一个日志接口，而Logback类似于Log4j，是一个日志的实现</p><p>spring boot中主要使用SLF4J 和 Logback</p><p>依赖是这个<code>spring-boot-starter-logging</code>，已经在父依赖中默认依赖了，所以不需要显示的依赖。日志很少去定制什么(打脸了，如果是搭建日志中心，需要理解比较深)，我们关注如何配置就行了</p><p>通过spring properties配置或者xml配置，都是为了读取文件给到logback工厂类创建日志，由于配置内容很多，一般都是用xml做，所以最好不要在properties中去设置了，都在xml中设置</p><p>当然我们可以去配置日志配置文件的路径</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">logging</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 指明日志配置文件路径，默认是resource下。从父pom所在的目录加载，可以统一全部的日志配置</span>  <span class="token key atrule">config</span><span class="token punctuation">:</span> logs/logback<span class="token punctuation">-</span>spring.xml<span class="token key atrule">logging</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 指明日志配置文件路径，默认是resource下。从当前项目的classpath下加载，就是resource下</span>  <span class="token key atrule">config</span><span class="token punctuation">:</span> classpath<span class="token punctuation">:</span>logs/logback<span class="token punctuation">-</span>spring.xml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="if标签的运用"><a href="#if标签的运用" class="headerlink" title="if标签的运用"></a>if标签的运用</h3><p>如果要在xml配置中使用if标签需要加入下面的依赖</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.codehaus.janino<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>janino<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.6.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用举例</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">condition</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>property(<span class="token punctuation">"</span>ifOpenConsol<span class="token punctuation">"</span>).contains(<span class="token punctuation">"</span>true<span class="token punctuation">"</span>)<span class="token punctuation">'</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>then</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>STDOUT<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.ConsoleAppender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>${CONSOLE_LOG_PATTERN}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>charset</span><span class="token punctuation">></span></span>${logback.charset}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>charset</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--字符串 System.out 或者 System.err ，默认 System.out --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span><span class="token punctuation">></span></span>System.out<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>target</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>then</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>官方推荐使用的xml名字的格式为：logback-spring.xml而不是logback.xml，至于为什么，因为带spring后缀的可以使用<code>&lt;springProfile&gt;</code>这个标签，这样我们就可以一份日志配置满足不同环境，下面是配置示例，包含了详细的注释了</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token comment" spellcheck="true">&lt;!-- 日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --></span><span class="token comment" spellcheck="true">&lt;!-- scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true --></span><span class="token comment" spellcheck="true">&lt;!-- scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟 --></span><span class="token comment" spellcheck="true">&lt;!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span> <span class="token attr-name">scan</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">scanPeriod</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10 seconds<span class="token punctuation">"</span></span> <span class="token attr-name">debug</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--&lt;include resource="org/springframework/boot/logging/logback/base.xml" />--></span>    <span class="token comment" spellcheck="true">&lt;!-- 用来设置上下文名称，每个logger都关联到logger上下文，默认上下文名称为default --></span>    <span class="token comment" spellcheck="true">&lt;!-- 可以使用&lt;contextName>设置成其他名字，用于区分不同应用程序的记录。一旦设置，不能修改(这里指的是日志配置有些参数修改后生效，但是不能改这个)--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>contextName</span><span class="token punctuation">></span></span>logback<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>contextName</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- spring变量的值通过springProperty注入给logging的context--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>springProperty</span> <span class="token attr-name">scop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>context<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>spring.application.name<span class="token punctuation">"</span></span> <span class="token attr-name">source</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>spring.application.name<span class="token punctuation">"</span></span> <span class="token attr-name">defaultValue</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>kafka-service<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token comment" spellcheck="true">&lt;!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义变量后，可以使“${}”来使用变量 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>log.path<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>logs/${spring.application.name}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 彩色日志 --></span>    <span class="token comment" spellcheck="true">&lt;!-- 彩色日志依赖的渲染类 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>conversionRule</span> <span class="token attr-name">conversionWord</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>clr<span class="token punctuation">"</span></span> <span class="token attr-name">converterClass</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.boot.logging.logback.ColorConverter<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>conversionRule</span> <span class="token attr-name">conversionWord</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wex<span class="token punctuation">"</span></span> <span class="token attr-name">converterClass</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>conversionRule</span> <span class="token attr-name">conversionWord</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wEx<span class="token punctuation">"</span></span> <span class="token attr-name">converterClass</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 彩色日志格式 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>CONSOLE_LOG_PATTERN<span class="token punctuation">"</span></span>              <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${CONSOLE_LOG_PATTERN:-%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 其它主题风格 --></span>    <span class="token comment" spellcheck="true">&lt;!-- &lt;property name="CONSOLE_LOG_PATTERN" value="%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}) %boldYellow([%thread]) %highlight(%-5level) %boldGreen(%logger{50}) - %msg%n" />--></span>    <span class="token comment" spellcheck="true">&lt;!--文件-黑白--></span>    <span class="token comment" spellcheck="true">&lt;!-- &lt;property name="FILE_LOG_PATTERN" value="%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n" /> --></span>    <span class="token comment" spellcheck="true">&lt;!-- &lt;appender>：负责写日志的组件，它有两个必要属性name和class。name指定appender名称，class指定appender的全限定名 --></span>    <span class="token comment" spellcheck="true">&lt;!-- class为ch.qos.logback.core.ConsoleAppender 把日志输出到控制台 --></span>    <span class="token comment" spellcheck="true">&lt;!-- class为ch.qos.logback.core.FileAppender 把日志添加到文件 --></span>    <span class="token comment" spellcheck="true">&lt;!-- class为ch.qos.logback.core.rolling.RollingFileAppender 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 --></span>    <span class="token comment" spellcheck="true">&lt;!--输出到控制台--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>CONSOLE<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.ConsoleAppender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.filter.ThresholdFilter<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>level</span><span class="token punctuation">></span></span>info<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>level</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>${CONSOLE_LOG_PATTERN}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- 设置字符集 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>charset</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>charset</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--输出到文件--></span>    <span class="token comment" spellcheck="true">&lt;!-- 时间滚动输出 level为 DEBUG 日志，本配置注释比较详细，作为配置参考 --></span>    <span class="token comment" spellcheck="true">&lt;!-- 日志归档就是先把日志输出到&lt;file>${log.path}/log_debug.log&lt;/file>记录的位置，满足条件的时候，截取该部分归档到 --></span>    <span class="token comment" spellcheck="true">&lt;!-- &lt;fileNamePattern>${log.path}/debug/log-debug-%d{yyyy-MM-dd}.%i.log&lt;/fileNamePattern>中 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>DEBUG_FILE<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.RollingFileAppender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>¬        <span class="token comment" spellcheck="true">&lt;!-- 正在记录的日志文件的路径及文件名 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>file</span><span class="token punctuation">></span></span>${log.path}/log_debug.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>file</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 如果 true，事件被追加到现存文件尾部。如果 false，清空现存文件.默认为 true --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>append</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>append</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--日志文件输出格式--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>charset</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>charset</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!-- 设置字符集 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录，不同的class实现不同的策略 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rollingPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.TimeBasedRollingPolicy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- 日志归档 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileNamePattern</span><span class="token punctuation">></span></span>${log.path}/debug/log-debug-%d{yyyy-MM-dd}.%i.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileNamePattern</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>timeBasedFileNamingAndTriggeringPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxFileSize</span><span class="token punctuation">></span></span>100MB<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxFileSize</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>timeBasedFileNamingAndTriggeringPolicy</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!--日志文件保留天数--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxHistory</span><span class="token punctuation">></span></span>30<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxHistory</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rollingPolicy</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 此日志文件只记录debug级别的，通过配置onMatch和onMismatch实现，匹配的留下，不匹配的拒绝，所以只留下debug基本的 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.filter.LevelFilter<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>level</span><span class="token punctuation">></span></span>debug<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>level</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMatch</span><span class="token punctuation">></span></span>ACCEPT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMatch</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMismatch</span><span class="token punctuation">></span></span>DENY<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMismatch</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 时间滚动输出 level为 INFO 日志 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>INFO_FILE<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.RollingFileAppender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 正在记录的日志文件的路径及文件名 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>file</span><span class="token punctuation">></span></span>${log.path}/log_info.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>file</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--日志文件输出格式--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>charset</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>charset</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rollingPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.TimeBasedRollingPolicy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- 每天日志归档路径以及格式 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileNamePattern</span><span class="token punctuation">></span></span>${log.path}/info/log-info-%d{yyyy-MM-dd}.%i.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileNamePattern</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>timeBasedFileNamingAndTriggeringPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxFileSize</span><span class="token punctuation">></span></span>100MB<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxFileSize</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>timeBasedFileNamingAndTriggeringPolicy</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!--日志文件保留天数--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxHistory</span><span class="token punctuation">></span></span>15<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxHistory</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rollingPolicy</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 此日志文件只记录info级别的 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.filter.LevelFilter<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>level</span><span class="token punctuation">></span></span>info<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>level</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMatch</span><span class="token punctuation">></span></span>ACCEPT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMatch</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMismatch</span><span class="token punctuation">></span></span>DENY<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMismatch</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 时间滚动输出 level为 WARN 日志 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>WARN_FILE<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.RollingFileAppender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 正在记录的日志文件的路径及文件名 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>file</span><span class="token punctuation">></span></span>${log.path}/log_warn.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>file</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--日志文件输出格式--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>charset</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>charset</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!-- 此处设置字符集 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rollingPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.TimeBasedRollingPolicy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileNamePattern</span><span class="token punctuation">></span></span>${log.path}/warn/log-warn-%d{yyyy-MM-dd}.%i.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileNamePattern</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>timeBasedFileNamingAndTriggeringPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxFileSize</span><span class="token punctuation">></span></span>100MB<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxFileSize</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>timeBasedFileNamingAndTriggeringPolicy</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!--日志文件保留天数--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxHistory</span><span class="token punctuation">></span></span>15<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxHistory</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rollingPolicy</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 此日志文件只记录warn级别的 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.filter.LevelFilter<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>level</span><span class="token punctuation">></span></span>warn<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>level</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMatch</span><span class="token punctuation">></span></span>ACCEPT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMatch</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMismatch</span><span class="token punctuation">></span></span>DENY<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMismatch</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 时间滚动输出 level为 ERROR 日志 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ERROR_FILE<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.RollingFileAppender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 正在记录的日志文件的路径及文件名 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>file</span><span class="token punctuation">></span></span>${log.path}/log_error.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>file</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--日志文件输出格式--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>charset</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>charset</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!-- 此处设置字符集 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rollingPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.TimeBasedRollingPolicy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileNamePattern</span><span class="token punctuation">></span></span>${log.path}/error/log-error-%d{yyyy-MM-dd}.%i.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileNamePattern</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>timeBasedFileNamingAndTriggeringPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxFileSize</span><span class="token punctuation">></span></span>100MB<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxFileSize</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>timeBasedFileNamingAndTriggeringPolicy</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!--日志文件保留天数--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxHistory</span><span class="token punctuation">></span></span>15<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxHistory</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rollingPolicy</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 此日志文件只记录ERROR级别的 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.filter.LevelFilter<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>level</span><span class="token punctuation">></span></span>ERROR<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>level</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMatch</span><span class="token punctuation">></span></span>ACCEPT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMatch</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onMismatch</span><span class="token punctuation">></span></span>DENY<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>onMismatch</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- &lt;logger>用来设置某一个包或者具体的某一个类的日志打印级别、以及指定&lt;appender> --></span>    <span class="token comment" spellcheck="true">&lt;!-- &lt;logger>仅有一个name属性，一个可选的level和一个可选的addtivity属性 --></span>    <span class="token comment" spellcheck="true">&lt;!-- name:      用来指定受此logger约束的某一个包或者具体的某一个类 --></span>    <span class="token comment" spellcheck="true">&lt;!-- level:     用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF --></span>    <span class="token comment" spellcheck="true">&lt;!--            还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别 --></span>    <span class="token comment" spellcheck="true">&lt;!--            如果未设置此属性，那么当前logger将会继承上级的级别 --></span>    <span class="token comment" spellcheck="true">&lt;!-- addtivity: 是否向上级logger传递打印信息。默认是true--></span>    <span class="token comment" spellcheck="true">&lt;!--&lt;logger name="org.springframework.web" level="info"/>--></span>    <span class="token comment" spellcheck="true">&lt;!--&lt;logger name="org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor" level="INFO"/>--></span>    <span class="token comment" spellcheck="true">&lt;!--        使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作：        第一种把&lt;root level="info">改成&lt;root level="DEBUG">这样就会打印sql，不过这样日志那边会出现很多其他消息        第二种就是单独给dao下目录配置debug模式，这样配置sql语句会打印，其他还是正常info级别     --></span>    <span class="token comment" spellcheck="true">&lt;!--        root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF        不能设置为INHERITED或者同义词NULL。默认是DEBUG        可以包含零个或多个元素，标识这个appender将会添加到这个logger        就是root节点是基本，通过配置appender-ref把它们整合到一个logger中，或者单独配置logger        &lt;root>它也是&lt;logger>元素，但是它是根logger,是所有&lt;logger>的上级。只有一个level属性，因为name已经被命名为"root"，且已经是最上级了    --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>info<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>CONSOLE<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>DEBUG_FILE<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>INFO_FILE<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>WARN_FILE<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ERROR_FILE<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--开发环境:打印控制台--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>springProfile</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dev<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>logger</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.liuzhidream.kafka.demo<span class="token punctuation">"</span></span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>debug<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>springProfile</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--生产环境:输出到文件--></span>    <span class="token comment" spellcheck="true">&lt;!--生产环境下，将此级别配置为适合的级别，以免日志文件太多或影响程序性能 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>springProfile</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pro<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>info<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>CONSOLE<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>DEBUG_FILE<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>INFO_FILE<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ERROR_FILE<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>WARN_FILE<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>springProfile</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="InitializingBean接口"><a href="#InitializingBean接口" class="headerlink" title="InitializingBean接口"></a>InitializingBean接口</h2><p>当BeanFactory将bean创建成功，并设置完成所有它们的属性后，我们想在这个时候去做出自定义的反应，比如检查一些强制属性是否被设置成功，这个时候我们可以让我们的bean的class实现InitializingBean接口，以被触发<br>另一种替代实现InitializingBean的可选方案是在我们的bean的类内部定义一个init方法，然后在xml的bean定义中添加init属性即可触发调用</p><p>总结下来也就是下面的方式:</p><ol><li>init-method(xml，指向一个方法) 或 @PostConstruct(注解在类的一个方法上)</li><li>InitializingBean接口，包含afterPropertiesSet方法</li></ol><p>InitializingBean接口可以让bean在创建的生命周期中的特定时间点，执行代码</p><h2 id="XXXAware接口"><a href="#XXXAware接口" class="headerlink" title="XXXAware接口"></a>XXXAware接口</h2><p>感知接口，实现该接口的bean能获取到spring容器中记录该bean的一些属性，或者说让spring容器感知bean的存在</p><h2 id="Bean执行的顺序"><a href="#Bean执行的顺序" class="headerlink" title="Bean执行的顺序"></a>Bean执行的顺序</h2><p>初始化执行顺序：</p><p>构造方法</p><p>@PostConstruct / init-method<br>InitializingBean 的 afterPropertiesSet 方法</p><p>BeanPostProcessor的执行时机</p><p>before：构造方法之后，@PostConstruct之前<br>after：afterPropertiesSet之后</p><h2 id="refresh-方法"><a href="#refresh-方法" class="headerlink" title="refresh 方法"></a>refresh 方法</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException<span class="token punctuation">,</span> IllegalStateException <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>startupShutdownMonitor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Prepare this context for refreshing.</span>        <span class="token function">prepareRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Tell the subclass to refresh the internal bean factory.</span>        <span class="token comment" spellcheck="true">// 获得刷新的beanFactory</span>        <span class="token comment" spellcheck="true">// 对于AnnotationConfigApplicationContext，作用：</span>        <span class="token comment" spellcheck="true">// 1.调用org.springframework.context.support.GenericApplicationContext.refreshBeanFactory，</span>        <span class="token comment" spellcheck="true">// 只是指定了SerializationId</span>        <span class="token comment" spellcheck="true">// 2.直接返回beanFactory(不用创建，容器中已存在)</span>        <span class="token comment" spellcheck="true">//  对于ClassPathXmlApplicationContext，作用：</span>        <span class="token comment" spellcheck="true">// 1.调用AbstractRefreshableApplicationContext.refreshBeanFactory</span>        <span class="token comment" spellcheck="true">// 2.如果存在beanFactory，先销毁单例bean，关闭beanFactory，再创建beanFactory</span>        <span class="token comment" spellcheck="true">// 3.注册传入的spring的xml配置文件中配置的bean，注册到beanFactory</span>        <span class="token comment" spellcheck="true">// 4.将beanFactory赋值给容器，返回beanFactory</span>        <span class="token comment" spellcheck="true">// 这里就体现了注解和xml的区别，注解是先创建工厂，再注册bean，而xml是先把bean加载了，放到工厂中，再把准备好的工厂赋值给容器</span>        <span class="token comment" spellcheck="true">// 注解: 在容器启动之前就创建beanFactory</span>        <span class="token comment" spellcheck="true">// xml: 即容器启动过程中创建beanFactory</span>        ConfigurableListableBeanFactory beanFactory <span class="token operator">=</span> <span class="token function">obtainFreshBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Prepare the bean factory for use in this context.</span>        <span class="token comment" spellcheck="true">// 准备bean工厂： 指定beanFactory的类加载器， 添加后置处理器，注册缺省环境bean等</span>        <span class="token comment" spellcheck="true">// beanFactory添加了2个后置处理器 ApplicationContextAwareProcessor, ApplicationListenerDetector (new )</span>        <span class="token function">prepareBeanFactory</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Allows post-processing of the bean factory in context subclasses.</span>            <span class="token comment" spellcheck="true">// 空方法</span>            <span class="token comment" spellcheck="true">// 允许在上下文的子类中对beanFactory进行后处理</span>            <span class="token comment" spellcheck="true">// 比如 AbstractRefreshableWebApplicationContext.postProcessBeanFactory</span>            <span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// Invoke factory processors registered as beans in the context.</span>            <span class="token comment" spellcheck="true">// 1.通过beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)</span>            <span class="token comment" spellcheck="true">//   拿到ConfigurationClassPostProcessor</span>            <span class="token comment" spellcheck="true">// 2.通过ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry，注册所有注解配置的bean</span>            <span class="token comment" spellcheck="true">// 注册的顺序： @ComponentScan>实现ImportSelector>方法bean>@ImportResource("spring.xml")</span>            <span class="token comment" spellcheck="true">//  > 实现 ImportBeanDefinitionRegistrar  (相对的顺序，都在同一个配置类上配置)</span>            <span class="token comment" spellcheck="true">// 3. 调用ConfigurationClassPostProcessor#postProcessBeanFactory</span>            <span class="token comment" spellcheck="true">//  增强@Configuration修饰的配置类  AppConfig--->AppConfig$$EnhancerBySpringCGLIB</span>            <span class="token comment" spellcheck="true">// (可以处理内部方法bean之间的调用，防止多例)</span>            <span class="token comment" spellcheck="true">//  添加了后置处理器 ConfigurationClassPostProcessor.ImportAwareBeanPostProcessor (new)</span>            <span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// Register bean processors that intercept bean creation.</span>            <span class="token comment" spellcheck="true">// 注册拦截bean创建的后置处理器：</span>            <span class="token comment" spellcheck="true">// 1.添加Spring自身的：  BeanPostProcessorChecker （new）  以及注册了beanDefinition的两个</span>            <span class="token comment" spellcheck="true">//  CommonAnnotationBeanPostProcessor AutowiredAnnotationBeanPostProcessor</span>            <span class="token comment" spellcheck="true">//  重新添加ApplicationListenerDetector(new ) ，删除旧的，移到处理器链末尾</span>            <span class="token comment" spellcheck="true">// 2.用户自定义的后置处理器</span>            <span class="token comment" spellcheck="true">// 注册了beanDefinition的会通过 beanFactory.getBean(ppName, BeanPostProcessor.class) 获取后置处理器</span>            <span class="token function">registerBeanPostProcessors</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// Initialize message source for this context.</span>            <span class="token function">initMessageSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// Initialize event multicaster for this context.</span>            <span class="token comment" spellcheck="true">// 初始化事件多播器</span>            <span class="token function">initApplicationEventMulticaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// Initialize other special beans in specific context subclasses.</span>            <span class="token comment" spellcheck="true">// 空方法</span>            <span class="token function">onRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// Check for listener beans and register them.</span>            <span class="token function">registerListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// Instantiate all remaining (non-lazy-init) singletons.</span>            <span class="token comment" spellcheck="true">// 实例化所有剩余的(非懒加载)单例。</span>            <span class="token function">finishBeanFactoryInitialization</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// Last step: publish corresponding event.</span>            <span class="token function">finishRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeansException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isWarnEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                logger<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"Exception encountered during context initialization - "</span> <span class="token operator">+</span>                        <span class="token string">"cancelling refresh attempt: "</span> <span class="token operator">+</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// Destroy already created singletons to avoid dangling resources.</span>            <span class="token function">destroyBeans</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// Reset 'active' flag.</span>            <span class="token function">cancelRefresh</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// Propagate exception to caller.</span>            <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Reset common introspection caches in Spring's core, since we</span>            <span class="token comment" spellcheck="true">// might not ever need metadata for singleton beans anymore...</span>            <span class="token function">resetCommonCaches</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="AbstractBeanDefinition"><a href="#AbstractBeanDefinition" class="headerlink" title="AbstractBeanDefinition"></a>AbstractBeanDefinition</h2><p>是BeanDefinition的实现类，除了bean的id和name，bean的各种属性可以在这里面找到</p><p><code>org.springframework.beans.factory.support.AbstractBeanDefinition</code></p><h2 id="DefaultListableBeanFactory-类"><a href="#DefaultListableBeanFactory-类" class="headerlink" title="DefaultListableBeanFactory 类"></a>DefaultListableBeanFactory 类</h2><p>容器底层用DefaultListableBeanFactory，即实现了BeanDefinitionRegistry，又实现了BeanFactory</p><p>它是在我们实例化 AnnotationConfigApplicationContext 的时候，由构造器调用父类构造器去实例化的，主要是GenericApplicationContext</p><p><code>public class AnnotationConfigApplicationContext extends GenericApplicationContext implements AnnotationConfigRegistry</code></p><p>在构造器中实例化，所以上下文已经对beanFactory成员变量完成初始化了</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">GenericApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultListableBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>全类名: <code>org.springframework.beans.factory.support.DefaultListableBeanFactory</code></p><p>BeanFactory接口的实现，有几个重要的属性和方法是需要关注的</p><p>该成员变量存储bean名称到definition的映射</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** Map of bean definition objects, keyed by bean name. */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> BeanDefinition<span class="token operator">></span> beanDefinitionMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>registerBeanDefinition用来向beanDefinitionMap注册beanDefinition，方法的逻辑不复杂，去掉各种校验核心代码也就几行</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//---------------------------------------------------------------------</span>    <span class="token comment" spellcheck="true">// Implementation of BeanDefinitionRegistry interface</span>    <span class="token comment" spellcheck="true">//---------------------------------------------------------------------</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">,</span> BeanDefinition beanDefinition<span class="token punctuation">)</span>            <span class="token keyword">throws</span> BeanDefinitionStoreException <span class="token punctuation">{</span>        Assert<span class="token punctuation">.</span><span class="token function">hasText</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token string">"Bean name must not be empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Assert<span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>beanDefinition<span class="token punctuation">,</span> <span class="token string">"BeanDefinition must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>beanDefinition <span class="token keyword">instanceof</span> <span class="token class-name">AbstractBeanDefinition</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>AbstractBeanDefinition<span class="token punctuation">)</span> beanDefinition<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">validate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeanDefinitionValidationException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanDefinitionStoreException</span><span class="token punctuation">(</span>beanDefinition<span class="token punctuation">.</span><span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanName<span class="token punctuation">,</span>                        <span class="token string">"Validation of bean definition failed"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        BeanDefinition existingDefinition <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>beanDefinitionMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>existingDefinition <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isAllowBeanDefinitionOverriding</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanDefinitionOverrideException</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> beanDefinition<span class="token punctuation">,</span> existingDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>existingDefinition<span class="token punctuation">.</span><span class="token function">getRole</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> beanDefinition<span class="token punctuation">.</span><span class="token function">getRole</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isInfoEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Overriding user-defined bean definition for bean '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span>                            <span class="token string">"' with a framework-generated bean definition: replacing ["</span> <span class="token operator">+</span>                            existingDefinition <span class="token operator">+</span> <span class="token string">"] with ["</span> <span class="token operator">+</span> beanDefinition <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>beanDefinition<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>existingDefinition<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Overriding bean definition for bean '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span>                            <span class="token string">"' with a different definition: replacing ["</span> <span class="token operator">+</span> existingDefinition <span class="token operator">+</span>                            <span class="token string">"] with ["</span> <span class="token operator">+</span> beanDefinition <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isTraceEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    logger<span class="token punctuation">.</span><span class="token function">trace</span><span class="token punctuation">(</span><span class="token string">"Overriding bean definition for bean '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span>                            <span class="token string">"' with an equivalent definition: replacing ["</span> <span class="token operator">+</span> existingDefinition <span class="token operator">+</span>                            <span class="token string">"] with ["</span> <span class="token operator">+</span> beanDefinition <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>beanDefinitionMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> beanDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasBeanCreationStarted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Cannot modify startup-time collection elements anymore (for stable iteration)</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>beanDefinitionMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>beanDefinitionMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> beanDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span>                    List<span class="token operator">&lt;</span>String<span class="token operator">></span> updatedDefinitions <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>beanDefinitionNames<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    updatedDefinitions<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>beanDefinitionNames<span class="token punctuation">)</span><span class="token punctuation">;</span>                    updatedDefinitions<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>beanDefinitionNames <span class="token operator">=</span> updatedDefinitions<span class="token punctuation">;</span>                    <span class="token function">removeManualSingletonName</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Still in startup registration phase</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>beanDefinitionMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> beanDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>beanDefinitionNames<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">removeManualSingletonName</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>frozenBeanDefinitionNames <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>existingDefinition <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token function">containsSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">resetBeanDefinition</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h2><p>@Async、@EnableAsync</p><ol><li>使用注解，定义异步线程池，覆盖方法，提供一个线程池</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configurable</span><span class="token annotation punctuation">@EnableAsync</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreadPoolConfigTest</span> <span class="token keyword">implements</span> <span class="token class-name">AsyncConfigurer</span>    提供线程池<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>定义异步任务，@Async注解即可，然后去调用这个bean</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 marshmallow 模块序列化数据</title>
      <link href="/2018/10/23/Python/marshmallow/"/>
      <url>/2018/10/23/Python/marshmallow/</url>
      
        <content type="html"><![CDATA[<p>在接口开发中，从数据库查询得到的数据通常是需要转换的，或者从一个对象序列化需要的特定数据，可以为此写一个方法，为何不尝试使用marshmallow模块呢，它提供了非常全面的数据处理方案。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一般用法是创建scheme的类，使用实例化的dump方法，方法接受待序列化的对象，即可返回一个被处理过的marshmallow对象，同时也可以反序列化。</p><h2 id="scheme-类"><a href="#scheme-类" class="headerlink" title="scheme 类"></a>scheme 类</h2><pre class="line-numbers language-py"><code class="language-py">from marshmallow import Schema, fieldsimport datetimeclass BaseSchema(Schema):    id = fields.Str()    created_at = fields.Str()    updated_at = fields.Str()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="序列化数据"><a href="#序列化数据" class="headerlink" title="序列化数据"></a>序列化数据</h2><pre class="line-numbers language-py"><code class="language-py">def marshal(data, schema):    if isinstance(data, (list, tuple)):        return [marshal(d, schema) for d in data]    result, errors = schema.dump(data)    if errors:        for item in errors.items():            print('{}: {}'.format(*item))    return resultclass Item(object):    created_at = datetime.datetime.now()    updated_at = datetime.datetime.now()instance = Item()marshal(instance, BaseSchema())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 特殊方法</title>
      <link href="/2018/10/23/Python/pytho-advanced-1/"/>
      <url>/2018/10/23/Python/pytho-advanced-1/</url>
      
        <content type="html"><![CDATA[<p>常见特殊方法总结</p><a id="more"></a><h2 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h2><blockquote><p>property(fget=None, fset=None, fdel=None, doc=None) -&gt; property attribute</p><p>fget is a function to be used for getting an attribute value, and likewise<br>fset is a function for setting, and fdel a function for del’ing, an<br>attribute.  Typical use is to define a managed attribute x</p></blockquote><p>基本写法</p><pre class="line-numbers language-py"><code class="language-py">class C(object):    def getx(self): return self._x    def setx(self, value): self._x = value    def delx(self): del self._x    x = property(getx, setx, delx, "I'm the 'x' property.")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个类中，x属性被描述符托管，对x的修改，复制都会被拦截（需要描述符类实现了这些方法）</p><p>Decorators make defining new properties or modifying existing ones easy:</p><p>装饰器写法</p><pre class="line-numbers language-py"><code class="language-py">class C(object):    @property    def x(self):        "I am the 'x' property."        return self._x    @x.setter    def x(self, value):        self._x = value    @x.deleter    def x(self):        del self._x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要知道静态方法，类方法，property都是构建描述符的类，这种方法有一个特点，就是对当前对象的属性进行维护</p><p>就是将某种特殊类型的类的实例指派给另一个类的属性(注意：这里是类属性，而不是对象属性)。</p><p>描述符有两种情况，静态方法，类方法，property都可以归为一种情况，这种情况有弊端就是维护多个属性很困难，不利于代码重构</p><p>另一种情况就是使用描述符对象，能够实现在多个属性上重复利用同一个存储逻辑的方式，把一个类的操作托付与另一个类</p><p>使用描述符类</p><pre class="line-numbers language-py"><code class="language-py">class Age(object):    # _value = '1'    def __init__(self, age):        print(age, id(self))        self.age = age    def __set_name__(self, owner, name):        self.name = name    def __get__(self, instance, owner):        return self.age, id(self)    def __set__(self, instance, value):        self.age = value    def __delete__(self, instance):        del self.ageclass XiaoMin:    age_1 = Age('18')    age_2 = Age('19')a = XiaoMin()b = XiaoMin()print(b.age_1)a.age_1 = '20'print(a.age_1)print(b.age_1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意py3.6使用了新的描述符协议，增加了<strong>set_name</strong>特殊方法，这里传递的name就会指向age_1，age_2<br>实例a, b的age_1属性都是同一个，描述符类中的instance指向实例a, 或b，owner指向类XiaoMin</p><p>a.age_1和b.age_1都是一样的，a.age_1修改也会影响b.age_1。只有instance的执行不一样</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 学习笔记</title>
      <link href="/2018/10/23/Python/base/"/>
      <url>/2018/10/23/Python/base/</url>
      
        <content type="html"><![CDATA[<p>基础永远是重中之重，虽然在应用开发中，很少会去使用语言的一些特性，比如一些高级话题，描述符，元类。但是掌握这些可以帮助理解框架源代码，从更深层次理解语言。</p><a id="more"></a><h2 id="callable-object"><a href="#callable-object" class="headerlink" title="callable(object)"></a>callable(object)</h2><p>检查对象object是否可调用。如果返回True，object仍然可能调用失败；但如果返回False，调用对象ojbect绝对不会成功。</p><ul><li>注意：类是可调用的，而类的实例实现了<strong>call</strong>()方法才可调用。</li><li>版本：该函数在python2.x版本中都可用。但是在python3.0版本中被移除，而在python3.2以后版本中被重新添加。</li></ul><h2 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir() 函数"></a>dir() 函数</h2><p>dir() 函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。如果参数包含方法 <code>__dir__()</code>，该方法将被调用。如果参数不包含 <code>__dir__()</code>，该方法将最大限度地收集参数信息。</p><p>与之对应的属性有 <code>__dict__</code>，也可以查看对象的属性，实例的 <code>__dict__</code> 仅存储与该实例相关的实例属性，正是因为实例的 <code>__dict__</code> 属性，每个实例的实例属性才会互不影响。类的<strong>dict</strong>存储所有实例共享的变量和函数(类属性，方法等)，类的<code>__dict__</code> 并不包含其父类的属性。所以不能通过 <code>__dict__</code> 在一个继承关系中，尤其是还动态修改属性后，判断属性是否存在，要获取完整的属性列表，使用dir()。</p><h2 id="标准库-inspect"><a href="#标准库-inspect" class="headerlink" title="标准库 inspect"></a>标准库 inspect</h2><p>inspect 作为Python的标准库，主要有以下作用：</p><ol><li><p>对是否是模块，框架，函数等进行类型检查。</p></li><li><p>获取源码</p></li><li><p>获取类或函数的参数的信息</p></li><li><p>解析堆栈</p></li></ol><p>一般来说，可以得到对象的各种信息，函数的参数，类的文档字符串等。</p><h2 id="继承一个类"><a href="#继承一个类" class="headerlink" title="继承一个类"></a>继承一个类</h2><p>如果已经定义了Person类，需要定义新的Student和Teacher类时，可以直接从Person类继承：</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> gender<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>name <span class="token operator">=</span> name            self<span class="token punctuation">.</span>gender <span class="token operator">=</span> gender<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义Student类时，只需要把额外的属性加上，例如score：</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> gender<span class="token punctuation">,</span> score<span class="token punctuation">)</span><span class="token punctuation">:</span>            super<span class="token punctuation">(</span>Student<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>name<span class="token punctuation">,</span> gender<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>score <span class="token operator">=</span> score<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一定要用 <code>super(Student, self).__init__(name, gender)</code> 去初始化父类，否则，继承自 Person 的 Student 将没有 name 和 gender。<br>函数 <code>super(Student, self)</code> 将返回当前类继承的父类，即 Person ，然后调用<strong>init</strong>()方法，注意self参数已在super()中传入，在<strong>init</strong>()中将隐式传递，不需要写出（也不能写）。</p><p><code>super(Teacher,self).__init__(name,gender)</code> 和 <code>Person.__init__(self,name,gender)</code> 等价的，二者选一就好。</p><p>:::tip<br>在新的py3中，使用super变的简洁了，<code>super().__init__(name, gender)</code>，类的形式<code>Person.__init__(self,name,gender)</code>没变<br>:::</p><p>假如一个类C继承了类A和类B，类A和类B有不同的属性，并且类C在创建时要初始化这些属性，此时在类C的构造函数<strong>init</strong>中使用super(C，self).<strong>init</strong>调用就无法实现了</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>a <span class="token operator">=</span> a    <span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>b <span class="token operator">=</span> b    <span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>            super<span class="token punctuation">(</span>C<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># &lt;----这样写是错误的</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正确的写法:</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>            A<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>self<span class="token punctuation">,</span> a<span class="token punctuation">)</span>            B<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>self<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>建议养成习惯，不要使用super()这个函数，即便是单继承，也使用上面的方式</strong></p><h2 id="反射-amp-自省"><a href="#反射-amp-自省" class="headerlink" title="反射 &amp; 自省"></a>反射 &amp; 自省</h2><p>当执行对象的方法，或者对某个字段赋值的时候，你要操作的字段名或者方法名在编码的时候不确定，这时候需要通过某种机制访问未知的属性。</p><p>这个机制被称为反射（反过来让对象告诉我们他是什么），或是自省（让对象自己告诉我们他是什么）。</p><ol><li>使用反射获取到的函数和方法可以像平常一样加上括号直接调用</li><li>获取到类后可以直接构造实例</li><li>不过获取到的字段不能直接赋值，因为拿到的其实是另一个指向同一个地方的引用，赋值只能改变当前的这个引用而已</li></ol><h2 id="单下划线-双下划线"><a href="#单下划线-双下划线" class="headerlink" title="单下划线/双下划线"></a>单下划线/双下划线</h2><p>Python 用下划线作为变量前缀和后缀指定特殊变量/方法。</p><p>主要存在四种情形：</p><ol><li><code>object</code> # public</li><li><code>__object__</code> # special, python system use, user should not define like it</li><li><code>__object</code> # private (name mangling during runtime)</li><li><code>_object</code> # obey python coding convention, consider it as private;</li></ol><p>核心风格：避免用下划线作为变量名的开始。</p><p>因为下划线对解释器有特殊的意义，而且是内建标识符所使用的符号，我们建议程序员避免用下划线作为变量名的开始。一般来讲，变量名 <code>_object</code> 被看作是“私有 的”，在模块或类外不可以使用，不能用 <code>'from moduleimport *'</code>(这种情况单双下划线都适用，而且只是用了*号不能导入，导入整个模块，或直接导入下划线开头的模块都是可行的) 导入。当变量是私有的时候，用 <code>_object</code> 来表示变量是很好的习惯。因为变量名 <code>__object__</code> 对Python来说有特殊含义，对于普通的变量应当避免这种命名风格。</p><p>python有关private的描述，python中不存在protected的概念，要么是public要么就是private，但是python中的private不像C++, Java那样，它并不是真正意义上的private，通过name mangling（名称改编(目的就是以防子类意外重写基类的方法或者属性)，即前面加上“单下划线”+类名，eg：instance._Class__object）机制就可以访问private了。</p><p><strong>“单下划线”</strong>：使用单下划线定义的属性或变量，它表示该方法或者属性是该类型的私有方法或属性。但其实在Python中不存在真正意义上的私有方法或者属性，前面加单下划线_只是表示你不应该去访问这个方法或者属性，因为它不是接口的一部分。</p><p>这个意思其实是一种定义，约束，你非要去访问也可以，所以在代码中我们看到单下划线开头的对象，就是让你不要去访问它。举个例子，在Django关于froms的代码中：</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">class</span> <span class="token class-name">BaseForm</span><span class="token punctuation">(</span>StrAndUnicode<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token operator">=</span>None<span class="token punctuation">,</span> files<span class="token operator">=</span>None<span class="token punctuation">,</span> auto_id<span class="token operator">=</span><span class="token string">'id_%s'</span><span class="token punctuation">,</span> prefix<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># ...</span>            self<span class="token punctuation">.</span>_errors <span class="token operator">=</span> None  <span class="token comment" spellcheck="true"># Stores the errors after clean() has been called.</span>        @property        <span class="token keyword">def</span> <span class="token function">errors</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token triple-quoted-string string">"""Return an ErrorDict for the data provided for the form."""</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>_errors <span class="token keyword">is</span> None<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>full_clean<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>_errors<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码截取自Django框架，可以看到_errors属性是私有的，它在clean()方法调用后被赋值，如果要查看错误，访问errors属性，而不是（也不应该）访问_errors获取错误信息。所以多看看源代码，学习其编程风格，有些人在命名变量的时候，同名的被使用了，就加个下划线，这是错误的风格。</p><p><strong>“双下划线”</strong>：双下划线开头的变量也是设计成私有的概念，不过区别于单下划线，它确实不能直接访问，Python中不存在真正意义上的私有变量。对于双下划线开头的方法和属性虽然我们不能直接引用，那是因为Python默认在其前面加了前缀_类名，通过特别的机制（变量轧压）可以访问到。官方设计双下划线的目的，可以在继承中防止方法被覆写。</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">__method</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'__method in class A'</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">_method</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'_method in class A'</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">run_method</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>hasattr<span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">'__method'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># False</span>            self<span class="token punctuation">.</span>__method<span class="token punctuation">(</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>_method<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">__method</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'__method in class B'</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">_method</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'_method in class B'</span><span class="token punctuation">)</span>    a <span class="token operator">=</span> A<span class="token punctuation">(</span><span class="token punctuation">)</span>    a<span class="token punctuation">.</span>run_method<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># output:</span>    <span class="token comment" spellcheck="true"># __method in class A</span>    <span class="token comment" spellcheck="true"># _method in class A</span>    <span class="token comment" spellcheck="true"># 很正常的输出，没有问题</span>    b <span class="token operator">=</span> B<span class="token punctuation">(</span><span class="token punctuation">)</span>    b<span class="token punctuation">.</span>run_method<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># output</span>    <span class="token comment" spellcheck="true"># __method in class A</span>    <span class="token comment" spellcheck="true"># _method in class B</span>    <span class="token comment" spellcheck="true"># 在解释器编译代码后，会进行变量轧压，或称为属性扩展，A类的__method变成了_A__method</span>    <span class="token comment" spellcheck="true"># 所以实例a，b去执行self.__method()都是去访问属性_A__method，print(dir(a))可以看到</span>    <span class="token comment" spellcheck="true"># _A__method在输出列表中，像hasattr等方法，要用_A__method作为属性名称</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>变量轧压：Python把以两个或以上下划线字符开头且没有以两个或以上下划线结尾的变量当作私有变量。私有变量会在代码生成之前被转换为长格式（变为公有）。转换机制是这样的：在变量前端插入类名，再在前端加入一个下划线字符。这就是所谓的私有 <code>变量轧压</code>（Private name mangling）。</p><p>属性扩张：一个属性命名前加了2个下划线，属性会扩展为<code>_类__属性</code>，属性扩展后，要用扩展后的变量名去获取属性。</p><p>注意：</p><ul><li>一是因为轧压会使标识符变长，当超过255的时候，Python会切断，要注意因此引起的命名冲突。</li><li>二是当类名全部以下划线命名的时候，Python就不再执行轧压。</li></ul><p>总结：理解单双下划线，Python私有变量的真正含义，它并不是语法严格限制，而是一种设计或风格，什么是变量轧压，使用了单双下划线后，<code>from moduleimport *</code> 要注意。</p><h2 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h2><table><thead><tr><th align="center">name</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center"><code>__class__</code></td><td align="left">类对象的类型</td></tr><tr><td align="center"><code>__name__</code></td><td align="left">在模块外和类中代表不同的含义，类中调用返回类名（str），只能类调用，实例调用：<code>self.__class__.__name__</code></td></tr><tr><td align="center"><code>__doc__</code></td><td align="left">类的文档字符串</td></tr><tr><td align="center"><code>__bases__</code></td><td align="left">类的所有父类组成的元祖，只能类调用，实例需要通过 <code>__class__</code></td></tr><tr><td align="center"><code>__dict__</code></td><td align="left">得到一个属性字典，类和实例都可以调用，得到它们对应的属性</td></tr><tr><td align="center"><code>__module__</code></td><td align="left">类定义所在的模块（类的全名是 <code>__main__.className</code>，如果类位于一个导入模块mymod中，那么 <code>className.__module__</code> 等于 mymod）</td></tr><tr><td align="center"><code>__str__</code></td><td align="left">实例来调用，打印实例，输出实例都会执行定义的方法</td></tr><tr><td align="center"><code>__repr__</code></td><td align="left">实例调用，输出不变，打印变</td></tr><tr><td align="center"><code>__getattribute__</code></td><td align="left">获取属性，针对所有属性运行</td></tr><tr><td align="center"><code>__getattr__</code></td><td align="left">获取属性，针对未定义的属性运行</td></tr><tr><td align="center"><code>__getitem__</code></td><td align="left">字典相关获取属性</td></tr><tr><td align="center"><code>__slots__</code></td><td align="left">限制实例能绑定的属性</td></tr></tbody></table><h2 id="time"><a href="#time" class="headerlink" title="time"></a>time</h2><p>该模块归属在 gengrice operating system services中，接近操作系统底层。围绕着Unix  Timestamp 进行。 需要注意的是在该模块中的大多数函数是调用了所在平台C library的同名函数(比如sleep，其实是调用了平台的C代码)， 所以要特别注意有些函数是平台相关的，可能会在不同的平台有不同的效果。另外一点是，由于是基于Unix Timestamp，所以其所能表述的日期范围被限定在 1970 - 2038 之间，如果你写的代码需要处理在前面所述范围之外的日期，那可能需要考虑使用datetime模块更好。为了解决这个问题，C出里新的标准库代替原来的，这里留个心眼。</p><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>在Python中，文件对象sys.stdin、sys.stdout和sys.stderr分别对应解释器的标准输入、标准输出和标准出错流。在程序启动时，这些对象的初值由sys.<strong>stdin</strong>、sys.<strong>stdout</strong>和sys.<strong>stderr</strong>保存，以便用于收尾(finalization)时恢复标准流对象。</p><p>print语句默认写入标准输出流，也可重定向至文件或其他可写对象(所有提供write方法的对象)。这样，就可以使用简洁的print语句代替笨拙的object.write(‘hello’+’\n’)写法。因此，在python中调用 print obj 打印对象时，缺省情况下等效于调用sys.stdout.write(obj+’\n’).</p><p>控制台重定向(&gt;和&gt;&gt;)：<br>Windows命令提示符(cmd.exe)和Linux Shell(bash等)均通过”&gt;”或”&gt;&gt;”将输出重定向。其中，”&gt;”表示覆盖内容，”&gt;&gt;”表示追加内容。类似地，”2&gt;”可重定向标准错误。重定向到”nul”(Windows)或”/dev/null”(Linux)会抑制输出，既不屏显也不存盘。</p><p>示例：</p><pre><code>Linux 下python print_test.py &gt;&gt;out.txt</code></pre><h2 id="argv-获取输入参数"><a href="#argv-获取输入参数" class="headerlink" title="argv 获取输入参数"></a>argv 获取输入参数</h2><p>获取输入参数</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sysa <span class="token operator">=</span> sys<span class="token punctuation">.</span>argv<span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 在shell输入python print_test.py 321</span><span class="token comment" spellcheck="true"># 打印：['print_test.py', '321']</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="操作Excel"><a href="#操作Excel" class="headerlink" title="操作Excel"></a>操作Excel</h2><ul><li>xlrd 读取文件，但不能对其进行操作</li><li>xlwt 生成Excel文件（可以用来控制生成的格式），但是不能在已有的Excel文件基础上进行修改</li><li>xluntils 可以修改文件，该模块需要依赖于xlrd，xlwt</li></ul><pre class="line-numbers language-py"><code class="language-py">wb = Workbook()ws = wb.active #激活 worksheet，就是创建一张表，表名默认，worksheet就是该表的对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>xlwt 中  write_merge(5,6,4,7,’hello’)  在第五行，第四列这里输入数据，结果跨1行（5+1），<br>跨3列（4+3）</p><p>openpyxl：也可以用来操作Excel，由于文件格式的原因，在超过最大行数的时候，xlwt将不能处理，这时候可以使用 <code>openpyxl</code></p><h2 id="内置序列函数"><a href="#内置序列函数" class="headerlink" title="内置序列函数"></a>内置序列函数</h2><ul><li><p>map(func, seq1[, seq2,…])<br>第一个参数接受一个函数名，后面的参数接受一个或多个可迭代的序列，返回的是一个列表。</p></li><li><p>filter(func, seq1[, seq2,…])<br>用法和map一样，对每个迭代的元素执行func，如果返回结果是真，这个值就留下。</p></li><li><p>reduce()<br>函数接收的参数和 map()类似，一个函数 f，一个list，但行为和 map()不同，reduce()传入的函数 f 必须接收两个参数，reduce()对list的每个元素反复调用函数f，并返回最终结果值。</p></li></ul><p>调用 reduce(f, [1, 3, 5, 7, 9])时，reduce函数将做如下计算：</p><ol><li>先计算头两个元素：f(1, 3)，结果为4；</li><li>再把结果和第3个元素计算：f(4, 5)，结果为9；</li><li>再把结果和第4个元素计算：f(9, 7)，结果为16；</li><li>再把结果和第5个元素计算：f(16, 9)，结果为25；</li><li>由于没有更多的元素了，计算结束，返回结果25。</li></ol><p>上述计算实际上是对 list 的所有元素求和。虽然Python内置了求和函数sum()，但是，利用reduce()求和也很简单。<code>__iter__</code>，<code>__next__</code> 这个结合，实现一个迭代器，让对象可以迭代。</p><ul><li>zip([iterable, …])<br>zip()是Python的一个内建函数，它接受一系列可迭代的对象作为参数，将对象中对应的元素打包成一个个tuple（元组），然后返回由这些tuples组成的list（列表）。若传入参数的长度不等，则返回list的长度和参数中长度最短的对象相同。利用*号操作符，可以将list unzip（解压）。</li></ul><pre class="line-numbers language-s"><code class="language-s">>>> a = [1,2,3]>>> b = [4,5,6]>>> c = [4,5,6,7,8]>>> zipped = zip(a,b)[(1, 4), (2, 5), (3, 6)]>>> zip(a,c)[(1, 4), (2, 5), (3, 6)]>>> zip(*zipped)[(1, 2, 3), (4, 5, 6)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="时间模块"><a href="#时间模块" class="headerlink" title="时间模块"></a>时间模块</h2><ul><li><p>utc时区：协调世界时，又称世界统一时间，世界标准时间，国际协调时间，简称UTC 不属于任意时区</p></li><li><p>中国大陆、中国香港、中国澳门、中国台湾、蒙古国、新加坡、马来西亚、菲律宾、西澳大利亚州的时间与UTC的时差均为+8，也就是UTC+8。</p></li><li><p>时间模块有调用操作系统底层的函数，所以你直接看源码看不出什么东西来，源码上的函数是对应到底层的，这个函数真正的实现在底层。</p></li><li><p>一般用time, datetime这两个模块。</p></li></ul><ol><li>time<br>该模块一般用的少</li></ol><ul><li>获取时间戳：time.time()</li><li>由给定的时间返回时间戳：time.mktime(t)，t是一个时间元组。先设一个时间元组，9个参数，最后3位可为0：</li></ul><pre class="line-numbers language-py"><code class="language-py">t = (2016,7,21,22,47,45,0,0,0）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>时间戳返回日期</li></ul><pre class="line-numbers language-py"><code class="language-py">import timetimeStamp = 1557502800timeArray = time.localtime(timeStamp)otherStyleTime = time.strftime("%Y-%m-%d %H:%M:%S", timeArray)print(otherStyleTime)import datetimetimeStamp = 1557502800dateArray = datetime.datetime.utcfromtimestamp(timeStamp)otherStyleTime = dateArray.strftime("%Y-%m-%d %H:%M:%S")print(otherStyleTime)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>英文显示：time.asctime(t)</li><li>格式化结果：time.strftime()，time模块是封装好的一个类，可以理解为直接的time就是时间，但是你不能这么用，得调用类的方法，而strftime方法是将结果格式化的方法</li><li>时区转换：<code>time.gmtime()</code> 将时间戳转换成UTC时区，这里的时间戳就是time.time()</li></ul><ol start="2"><li>datetime<br>常用的时间对象处理模块</li></ol><p>datetime 模块包含了几个常用的模块来处理时间，如date日期，datetime当前日期加上时间</p><ul><li>获取时间：datetime.datetime.now()</li></ul><pre class="line-numbers language-py"><code class="language-py">datetime.date.today()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>时间计算（如做加减法，返回几天前的日期）：获取的时间 和 datetime.timedelta(days=1)<br>做计算，如果是加法就可以得到当前时间一天后的时间，也可传分钟minutes等其它变量，用他们英文的复数形式。</p></li><li><p>时间对象格式化，字符串转换时间对象</p></li></ul><p>strftime：这个函数是时间对象的格式化函数，只要你是时间对象就可以用这个格式化，结果是str</p><p>strptime：这个是上面是反着的，将一个字符串转换成时间对象，字符串要和格式化模式一致。比如 <code>‘2017-8-12’</code> 对应的格式化模式是 <code>‘%Y-%m-%d'</code> 这里的Y如果用小写y，就不对了，小写对应的是 <code>%y</code></p><ul><li>time模块可以直接调用上面的函数<br>datetime模块你要先创建一个时间对象才能使用上面的函数。因为datetime格式化是类的方法，你要先创建一个实例（时间对象）才能调用方法，而对于time来说这个两个是模块里面的函数，不是类的方法。直接看源码即可理解。</li></ul><table><thead><tr><th align="center">格式符</th><th>说明</th></tr></thead><tbody><tr><td align="center">%a</td><td>星期的英文单词的缩写：如星期一， 则返回 Mon</td></tr><tr><td align="center">%A</td><td>星期的英文单词的全拼：如星期一，返回 Monday</td></tr><tr><td align="center">%b</td><td>月份的英文单词的缩写：如一月， 则返回 Jan</td></tr><tr><td align="center">%B</td><td>月份的引文单词的缩写：如一月， 则返回 January</td></tr><tr><td align="center">%c</td><td>返回datetime的字符串表示，如03/08/15 23:01:26</td></tr><tr><td align="center">%d</td><td>返回的是当前时间是当前月的第几天</td></tr><tr><td align="center">%f</td><td>微秒的表示： 范围: [0,999999]</td></tr><tr><td align="center">%H</td><td>以24小时制表示当前小时</td></tr><tr><td align="center">%I</td><td>以12小时制表示当前小时</td></tr><tr><td align="center">%j</td><td>返回 当天是当年的第几天 范围[001,366]</td></tr><tr><td align="center">%m</td><td>返回月份 范围[0,12]</td></tr><tr><td align="center">%M</td><td>返回分钟数 范围 [0,59]</td></tr><tr><td align="center">%P</td><td>返回是上午还是下午–AM or PM</td></tr><tr><td align="center">%S</td><td>返回秒数 范围 [0,61]。。。手册说明的</td></tr><tr><td align="center">%U</td><td>返回当周是当年的第几周 以周日为第一天</td></tr><tr><td align="center">%W</td><td>返回当周是当年的第几周 以周一为第一天</td></tr><tr><td align="center">%w</td><td>当天在当周的天数，范围为[0, 6]，6表示星期天</td></tr><tr><td align="center">%x</td><td>日期的字符串表示 ：03/08/15</td></tr><tr><td align="center">%X</td><td>时间的字符串表示 ：23:22:08</td></tr><tr><td align="center">%y</td><td>两个数字表示的年份 15</td></tr><tr><td align="center">%Y</td><td>四个数字表示的年份 2015</td></tr><tr><td align="center">%z</td><td>与utc时间的间隔 （如果是本地时间，返回空字符串）</td></tr><tr><td align="center">%Z</td><td>时区名称（如果是本地时间，返回空字符串）</td></tr></tbody></table><ul><li>时间戳和时间对象转换</li></ul><pre class="line-numbers language-py"><code class="language-py">d = datetime.datetime.fromtimestamp(timeStamp) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>d.timestapo()</code>，3.0 datetime模块时间对象的方法，如果是2.0，先把时间对象转换成时间元组，利用time模块的time.mktime(t)也可以得到时间戳。</p><p>由于time模块的时间对象是 <code>struct_time</code> 元组，并不是很好用，所以推荐获取时间戳用time.time()，其余时间处理都使用datetime，然后利用 <code>datetime.datetime.fromtimestamp(time.time())</code> 可以由时间戳转换为时间对象。</p><p>时间对象处理注意：</p><p><code>seconds</code> 是 <code>timedelta</code> 对象的属性，datetime不能调用这个属性，即对时间计算才能使用这个属性。另外利用这个去做时间比较不是很靠谱，如果你的差超过了一天，那么转换的秒数溢出了，会显示0，而且如果是负数（理论值），但是时间是没有负秒数的，所以显示会和实际不符（猜测显示的可能为补码的结果）最好的时间差处理是，利用datetie.timedelte加出时间差和现在时间做比较大小。</p><p>:sunny:总结：时间对象，时间戳，时间对象格式化成字符串，字符串转换为时间对象，时间对象计算（可以将结果转换成秒，在比较的时候有作用，只要是时间对象，都可以进行算数运算）</p><h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><ol><li>基本顺序存储结构——列表与元组</li></ol><ul><li><p>切片一般是字符串，不过列表也是可以切片的，从a到b, 这个b可以用负数来做索引。关于倒叙排列 a [ : : -1]，只操作最后一步“步进”</p></li><li><p>isdigit()，字符串才有的方法，判断是不是数字</p></li><li><p><code>a[1:20] = [5]</code> 可以对列表某部分切片了进行值修改，属于在原处修改</p></li><li><p>复制（浅拷贝）<code>s[:]   or  s.copy()</code></p></li><li><p><code>s.extend(t)  or  s += t</code> 在后面插入一组，相当于 <code>+=</code>，区别于append，append的参数是一个元素，元素可以是list，dict</p></li><li><p><code>s.insert(i, x)</code> 在i处插入x(可以是任意对象)</p></li><li><p>清空：<code>del s[:]   or   s.clear()</code></p></li><li><p>删除：<code>s.pop([i])</code> 默认删除尾部元素，否则删除i处的元素(在删除索引处元素时，相比于del感觉风格要好一点)，<code>s.remove(x)</code> 删除第一个等于x的元素<br><code>s.reverse()</code> 列表反向</p></li></ul><p>:sunny:上面这几个操作 <code>pop</code> 有返回值，其它都没有，所以你不能把v = list.append(1) v的值为append方法的返回值None</p><ul><li>range快速生成列表，在3x中，返回的是迭代器(3.x中很多类似函数都返回了迭代器)，如果要步进是小数，需要自己实现，Python不提供这样的函数</li></ul><ol start="2"><li>基本哈希存储结构——字典</li></ol><table><thead><tr><th>name</th><th>description</th></tr></thead><tbody><tr><td>len(d)</td><td>返回字典元素个数</td></tr><tr><td>d[key]</td><td>返回key对应的value</td></tr><tr><td>d[key]=value</td><td>为字典元素赋值，如果没有则增加元素</td></tr><tr><td>del d[key]</td><td>删除字典元素</td></tr><tr><td>key ind/key not ind</td><td>查看key是否在d中</td></tr><tr><td>iter(d)</td><td>返回一个迭代器，具有<strong>next</strong>()方法</td></tr><tr><td>clear()</td><td>清空</td></tr><tr><td>copy()</td><td>浅复制</td></tr><tr><td>fromkeys(seq[,value])</td><td>以seq作为键，value作为值建立字典，默认value为None</td></tr><tr><td>get(key[,default])</td><td>安全的get方法，如果不存在返回default，如果不指定default则报错</td></tr><tr><td>items()</td><td>列出一个键值对的view</td></tr><tr><td>keys()</td><td>列出key的view,通常用于遍历</td></tr><tr><td>values()</td><td>Return a new view of the dictionary’s values.</td></tr><tr><td>pop(key[,default])</td><td>如果键值key存在与字典中，删除dict[key]，返回dict[key]的value值。key值必须给出。否则，返回default值。如果default值没有过出，就会报出KeyError异常。pop()方法至少接受一个参数，最多接受两个参数。</td></tr><tr><td>popitem()</td><td>弹出一个键值对，为key的哈希序列中的第一个</td></tr><tr><td>setdefault(key[,default])</td><td>安全的添加操作，如果存在就返回value不更改值，如果不存在添加一个key:default的表项，default默认为0</td></tr><tr><td>update([other])</td><td>更改操作，other可以是键值对的列表或元组（二级的），也可以是字典，用other中的键值对添加到或替换原有键值对</td></tr></tbody></table><p>字符串：<code>s.upper()</code> 小写转大写</p><ul><li>sort：修改原列表 </li><li>sorted：产生一个新的列表</li></ul><p>多条件排序，按set_name升排序，然后按cluster_type降序，cluster_type是字符串的，如果是数字的，可以 <code>-x['cluster_type']</code></p><p>sorted(b, key=lambda x: (x[‘set_name’], x[‘cluster_type’][::-1]))</p><p>字符串处理，分割用split()，替换用replace() ，strip，lstrip, rstrip分别用于去除首位，左边，右边的指定字符串。替换可以把换行去了，str.replace(‘\n’, ‘’)，或者去空格。</p><p>python是没有null类型的，这个类型其它语言的，如js，sql。所以当前端传过这样的类型来需要注意，sql也是，如果一个没有赋值的字段，他可能是null的，但是判断布尔会出错，你会取得一个‘null’字符串。</p><p>python dict函数：一般用法传入关键字，其它方法：</p><ol><li>dict(zip([‘one’, ‘two’, ‘three’], [1, 2, 3]))   # 映射函数方式来构造字典（也是利用了传入可迭代对象的方法）</li><li>dict([(‘one’, 1), (‘two’, 2), (‘three’, 3)])    # 可迭代对象方式来构造字典</li></ol><p><code>python setdefault（key, default）</code> 不是设置值，而是返回结果，当键不存在的时候，才会去设置值，并返回设置了的值。如果你没写default，而键不存在，则返回None，必须注意返回的值是字典的键对应的值，不是这个字典。</p><p>:sunny:切片补充：</p><p>总有人面试出一些诡异的问题，在切片中，做了以下的总结：</p><ol><li>切片超过索引不会报错</li><li>关于步进：步进的值不能是0(0报错)，可以是正数或负数，符号影响切片的方向，正号从左向右切，符号相反，值代表步进多少</li><li>start和end，start不能大于end（这里的大于应该从切片的位置来考虑，不能看数值，即开始切片的位置不能在end后面）否则切片结果为空，注意在负步进中，也是从start切到end，不过从右边开始切</li><li>start和end可以是负索引，和列表操作一样，当list很长，你不知道最后的索引是多少时，可以用负索引，10为list长度，正索引范围是0到9负索引范围是-1到-11</li><li>切片是不会循环的，步进决定切片方向，正负索引要从它的实际位置来做运算，字符串和tuple也可以切片</li></ol><p>举例：</p><pre class="line-numbers language-python"><code class="language-python">    list_data <span class="token operator">=</span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>list_data<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>list_data<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">:</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># [] # 超范围为空</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>list_data<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># [] 根据第3点，数值满足，但是切的位置不满足，-1相当于是索引9的位置</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>list_data<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># [1, 2, 3, 4, 5]</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>list_data<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># [] 一定要注意，步进不是加负号就倒叙</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>list_data<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># [9, 7, 5, 3]，负步进是反向切片，所以用正步进实现不了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><p>内置函数，any(iterable)，可迭代序列每个元素都是False，返回False，如果其中一个是True，返回True。这可以用在对多个对象判断逻辑，把它们写在元组里面，使用any函数。</p><h2 id="all"><a href="#all" class="headerlink" title="all"></a>all</h2><p>内置函数，all(iterable)，可迭代的每个元素都是True，返回True，否则返回False</p><h2 id="浮点数精度"><a href="#浮点数精度" class="headerlink" title="浮点数精度"></a>浮点数精度</h2><p>以下情况就是精度损失造成的</p><pre><code>print(0.1 * 3) # 0.30000000000000004</code></pre><p>为什么会有精度损失：</p><p>Python 中使用双精度浮点数来存储小数。在 Python 使用的 IEEE 754 标准（52M/11E/1S）中，8字节64位存储空间分配了52位来存储浮点数的有效数字，11位存储指数，1位存储正负号，即这是一种二进制版的科学计数法格式。虽然52位有效数字看起来很多，但麻烦之处在于，二进制小数在表示有理数时极易遇到无限循环的问题。</p><p>所以在使用float的时候，千万要小心精度，推荐金钱计算使用decimal</p><p>精度控制round函数，注意它的四舍五入比较特殊，不是单纯的记一个四舍五入，round() 如果只有一个数作为参数，不指定位数的时候，返回的是一个整数，而且是最靠近的整数（这点上类似四舍五入）。但是当出现.5的时候，两边的距离都一样，round()取靠近的偶数，这就是为什么round(2.5) = 2。当指定取舍的小数点位数的时候，一般情况也是使用四舍五入的规则，但是碰到.5的这样情况，如果要取舍的位数前的小树是奇数，则直接舍弃，如果偶数这向上取舍。(这个函数的用法非常的扯淡，不如decimal好)</p>{% blockquote %}Note The behavior of round() for floats can be surprising: for example, round(2.675, 2) gives 2.67 instead of the expected 2.68. This is not a bug: it’s a result of the fact that most decimal fractions can’t be represented exactly as a float. See Floating Point Arithmetic: Issues and Limitations for more information.根据官方的说法，是看浮点数被省略后，尽量取接近的值{% endblockquote %}<ol><li>不指定小数点位数, 即取整数, 四舍五入: (取到哪一位的后面一位, 若遇到.5 奇进偶不进)<pre><code>round(2.3)   2.0round(2.6)   3.0round(2.5)   2.0round(1.5)   2.0</code></pre></li><li>指定小数点位数, 即有小数位, 四舍五入: (取到哪一位的后面一位, 若遇到.5 偶进奇不进)<pre><code>round(2.635,2)  2.63round(2.645,2)  2.65round(2.655,2)  2.65round(2.665,2)  2.67round(2.675,2)  2.67</code></pre></li></ol><h2 id="和"><a href="#和" class="headerlink" title="/ 和 //"></a>/ 和 //</h2><p>6.0 / 3.0 = 2.0，6.0，3.0是浮点数，那么结果也是浮点数2.0，更精确的说，只要” / “ 两边有一个数是浮点数，那么结果就是浮点数。</p><p>在Python2.2版本以前也是这么规定的，但是，Python的设计者认为这么做不符合Python简单明了的特性，于是乎就在Python2.2以及以后的版本中增加了一个算术运算符” // “来表示整数除法，返回不大于结果的一个最大的整数，而” / “ 则单纯的表示浮点数除法，但是，为了折中，所有2.X版本中，也是为了向后兼容，如果要使用” // “，就必须加上一条语句：<code>from __future__ import division</code><br>一看到这句，” / “就表示 浮点数除法，返回浮点结果，” // “表示整数除法。</p><p>但是，在Python3.0时，就没有这种折中情况了，” / “就一定表示<code>浮点数除法</code>，返回浮点结果，” // “表示<code>整数除法</code>。</p><h2 id="slots"><a href="#slots" class="headerlink" title="slots"></a><strong>slots</strong></h2><p>在类中定义，用来限制类能被绑定的属性。需要注意一些情况：</p><ul><li><p>正常使用，没有继承关系，除了限制的属性其它的不能被绑定</p></li><li><p>继承情况，分为两种，一是类定义了 <code>__slots__</code>，被其它类继承；二是类继承自其它类，父类没有定义 <code>__slots__</code>，而类自己定义了 <code>__slots__</code>。</p></li></ul><ol><li><p>第一种情况下，类自己的slots是可以发挥作用的，但是继承这个类的子类就没有属性绑定限制了，但是子类的 <code>__slots__</code>属性是可以访问的（实例和类都可以打印 <code>__slots__</code> 子类没定义，打印父类的值，子类定义了，打印子类的值），如果想要父类的绑定限制，需要在子类中定义 <code>__slots = ()</code> 一个空元组，这样子类的属性绑定就被触发了，能被添加的属性由父类的元组和子类的元组构成，但是子类是空元组，就是需要子类来显示定义 <code>__slots__</code> 来触发熟悉绑定限制。</p></li><li><p>第二种情况，一个类定义了属性绑定，但是它有继承，这个时候该类的slots是发挥不了作用的。需要父类定义 <code>__slots = ()</code> 一个空元组，子类的slots才发挥作用。</p></li></ol><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># __slots__ = ('a',)</span>        __slots__ <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">pass</span>    <span class="token keyword">class</span> <span class="token class-name">D</span><span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token punctuation">:</span>        __slots__ <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token punctuation">)</span>        <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在应用开发中，也是很少使用slots，一般在看源代码的时候会见到</p><h2 id="给类添加方法"><a href="#给类添加方法" class="headerlink" title="给类添加方法"></a>给类添加方法</h2><p>python的 <code>MethodType(方法， 实例（如果是给类添加方法，就用None）， 类)</code> 用来给类或实例绑定方法。<br>例子：</p><pre class="line-numbers language-py"><code class="language-py">s = Stuedent()  s.set_name = MethodType(set_name, s, Student)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="获取项目依赖"><a href="#获取项目依赖" class="headerlink" title="获取项目依赖"></a>获取项目依赖</h2><p><code>pip freeze &gt; requirements.txt</code> 获取项目依赖。 <code>pip instal requirements.txt</code> 安装依赖。</p><h2 id="eval-amp-exec"><a href="#eval-amp-exec" class="headerlink" title="eval &amp; exec"></a>eval &amp; exec</h2><p>可以执行动态的代码，比如给一个字符串计算结果。区别：eval返回结果，exec不返回。这就要注意了，<code>exec('print 1')</code> 但是用eval就不行，print 不返回结果，你可以做布尔运算，这样是返回结果的。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><pre class="line-numbers language-py"><code class="language-py">def  function(runfun):    def  fun(runfun):        runfun()    return fun<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>记住，当函数function被调用后，就产生一个闭包，闭包是fun，自由变量是runfun。</p><p>装饰器：功能函数，原函数，使用装饰器，就是将原函数的引用指向功能函数。由于装饰器是为了给原函数增加功能，所以功能函数实现的时候需要接受一个函数的引用作为参数，这个引用即为原函数。</p><p>关于自由变量：</p><pre class="line-numbers language-py"><code class="language-py">def func1(x):    def func2(n):        print x ** n    return func2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当我们 <code>a = func1(5)</code>，内嵌的函数得到了自由变量 <code>5</code>，虽然func1的调用结束了，但是 <code>5</code> 会被记录下来，执行 <code>a(2)</code> 得到 <code>25</code>。通过闭包得到了一个自由变量，这种是运用了嵌套作用域，如果n的值在func1中赋值了，利用的是默认参数来保留嵌套作用域的状态，在低版本中这样用，当时没有引进E的概念，n按照命名空间的原则查找。保持住状态，是闭包的最大运用（js, python 语言亦如此）记住这个保持住状态，你可能会需要这样的特性来设计程序。</p><p>这里就涉及到了python作用域查找，LGB，B是内置，新的版本引入了嵌套作用域，LEGB，查找流程是 <code>L→B</code>。</p><p>js：Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。js中用闭包就可以在外部取到函数内部的变量（我会在最外层设置一个全局变量，在这个函数里面去把结果赋值给最外层，这样函数外部可以随时取这个变量，当然有闭包，并且还有这样的需求，最好是用闭包）。</p><p>对于作用域，一个函数内变量是处在这个作用域里面的，只有函数嵌套才会涉及到作用域嵌套的问题。</p><p>变量作用域，在函数里面大家是通用的，嵌套发生在函数与函数嵌套的时候。但是有一个情况，你通过if语句决定的变量，在条件不满足的时候，就无法取到了，即这个变量的作用域在不满足条件的时候，对于整个函数不是全局的。</p><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>python 命名空间，用字典来记录。局部命名空间（当前函数），全局命名空间（当前模块），内置命名空间（存放内置函数和异常），理解变量查找顺序。</p><p>Python 的一个特别之处在于其赋值操作总是在最里层的作用域。赋值不会复制数据——只是将命名绑定到对象。删除也是如此：”del y” 只是从局部作用域的命名空间中删除命名 y 。事实上，所有引入新命名的操作都作用于局部作用域。理解命名空间生命周期。函数的命名空间是属于自己的，递归调用的函数也有自己的命名空间。</p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>导入的模块会存储在sys.modules表中，重复导入只要能在表中找到，则从内存中取出，不再去执行导入操作。</p><p>在导入这里涉及到了字节码的相关知识：做为顶层文件（被执行的，导入其它模块的文件），我们通常看不到pyc，因为顶层文件的pyc在内部使用后就被丢弃了，而属于被导入的文件会创建pyc，并且保留下来。pyo也是字节码，称为最佳化字节码文件。</p><p>不要重复导入一个模块，这样做不到覆盖模块属性，应使用 <code>reload（）</code>。不要做两个模块互相导入，如果处理不好逻辑容易出错。<code>python3  reload</code> 被移到imp中，需要 <code>from  imp  import  reload</code> 才能使用。重载后import的模块对象改变了，会对使用import的有影响，但是重载之前的from不会，因为from是复制。记住对于from，它是复制了模块的变量给了新变量（两个同名），变量已经被复制出来了，reload模块不会影响复制出来的变量。</p><ul><li><p>模块是对象，导入后，模块将拥有属性，可以使用自省获取模块属性。对于使用from的导入，要重载，先重载对应模块，在重新执行from</p></li><li><p>递归导入：两个模块相互导入对方。逻辑上处理不对，极其容易发生错误，尽量避免这种导入尤其是在其中还使用from</p></li><li><p>单下划线开头的变量只是不能被from module import *  形式导入，from module import _变量名是可以导入的</p></li><li><p>程序直接执行和导入也是有区别的，第五部分7题（python学习手册4）（对于这些非常绕的概念，没有必要完全理解，实际开发运用我们是不会这样做的，还是那句话，书上讲的不要和实际混淆，例如模块名字和系统名字重复，导致导入失败，既然你都知道了，就不要取同名，也省的使用非常绕的导入方法，就为了同名，还不如重新取个名字）</p></li></ul><p>理解 <code>from &amp; import</code></p><p>sys.path</p><p>模块的搜索路径，在程序启动时进行配置，自动将顶级文件的主目录（或者指定当前工作目录的一个空字符串）、任何PYTHONPATH目录、已创建的任何 <code>.pth</code> 文件路径的内容，标准库目录合并。得到一个目录列表。</p><p>对于sys.path 修改环境变量是永久影响的，sys.path.append()在程序结束后失效。</p><p><code>import from</code> 是赋值语句</p><ol><li>import将整个模块对象赋值给一个变量名，</li><li>from将一个或多个变量名赋值给另一个模块中同名的对象</li></ol><p>理解模块对象。记住from是赋值，import是导入。在使用上仍有些许区别（只需理解from是copy就行了，理解2的意义）</p><ul><li>注意：from的第一步也是普通的导入操作。因此，from总是会把整个模块导入到内存中（如果还没导入的话），无论是从这个文件中复制出多少变量名。它不是你想的只加载你需要的部分，如一个函数，虽然导入全部，但是你没指明的模块还是用不了。可能在效率上差了点，但是影响不大。</li><li>或者这样理解：from也是导入，先导入，然后将变量复制过来。</li></ul><p><strong>变量的含义一定是由源代码中的赋值语句的位置决定的</strong></p><ul><li>使用import导入的模块，它的全局作用域一定是其所在的文件</li><li>函数绝对无法看见其它函数内的变量名，除非它们从物理上处于这个函数内</li><li>模块程序代码绝对无法看见其它模块内的变量名，除非明确的进行了导入</li><li>一段程序的作用域完全由程序所处的文件中实际位置决定，作用域绝不会被函数调用或模块导入影响。（这体现了python的静态作用域，有些语言是动态作用域，作用域依赖于运行期间的调用）</li></ul><p>命名空间嵌套：<code>a.py  b.py  c.py   b导入了a，  c 导入了b，  c中通过b.a可以访问到a模块</code>。</p><p>包：理解 <code>__all__</code>，<code>__init__.py</code> 跨目录导入的时候就应该用包导入。包文件里面可以赋值和执行代码，会在导入包的时候执行，赋值的变量也会加到命名空间里。这里和执行文件所处的位置有重要关系。</p><p>例子：dir1是一个文件夹，下面有包dir2。代码在dir1下执行，可以导入dir2包，<code>import dir2</code> 不要这样写 <code>import dir1.dir2</code>。若dir1也是一个包，代码在它的上层目录执行，就应该是 <code>import dir1.dir2</code>。这样两个包的包文件的代码会被执行，变量也可以取到。</p><p>该部分也许用到的较少，实际结合下书607页（python学习手册第四版）内容。主要是：</p><ul><li>代码的执行位置</li><li>包文件（只有被导入的包，包文件才被执行，变量才能加到命名空间，如果代码本身处在一个包下，那么这个包的包文件因为你不导入所以不被执行）</li><li>跨文件：有些时候想从另一个文件中拿一个模块来，此时代码所处的是文件或者包亦无所谓，你跨的目录就得是包，一级一级得包结构下去，而且这个包的上一级目录必须在<code>sys.path</code> 中，注意这句话，这个包的上级目录必须在 <code>sys.path</code>中，只能到上级目录，把自身（包）加进去就找不到了。A下有 <code>a，b</code>，b想拿a，<code>sys.path</code> 的路径就要到A，到A/a不可以。若路径只到A的上一级，应该是 <code>import A.b</code> Ab都要是包。</li></ul><p>注意：sys.path 路径在搜索的时候，是在这个列表上从左到右来进行的。</p><p>包相对导入和绝对导入：</p><p>绝对就是完整路径，从sys.path路径开始搜索。p2.6默认是相对，p3默认是绝对。这样带来问题，<code>import  module</code>，p3默认使用绝对路径，如果是系统模块，则同目录下的包导入失败。</p><h2 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h2><p>顶层语句直接被执行，定义的函数将被创建，函数的引用写入内存，变量被创建命名空间，python会检查代码并填充局部命名空间。在python运行那行代码之前，就发现了对变量的赋值，并把它添加到局部命名空间中。</p><p>在函数中做这样的语句 <code>i = i +1</code>，它的本质为：python 是静态作用域，程序在编译的时候就已经知道了变量作用范围。（在代码中给一个变量赋值的地方决定了这个变量将存在于哪个命名空间，也就是它可见的范围）比如定义函数：</p><pre class="line-numbers language-py"><code class="language-py">def  func2():    i = i +1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这是一个函数，它被定义了，函数所处的模块被导入，或者自身被执行的时候，就要引入这个函数到内存，并且创建它的命名空间，所以说它是静态作用域，等到做func2()，即执行函数的时候，解释器会知道i是静态作用域。这里 <code>i = i + 1</code>，是对 i 进行赋值，记住 i 是被赋值的，所以不是查找变量，i 被加入函数自己的局部作用域，后面的 <code>i + 1</code> 是执行语句，函数在创建命名空间时，只管创建，还不执行，等到执行的时候，计算 <code>i + 1</code>，因为i 是局部的，该函数没有i 的值，所有会报错。记住命名空间先创建，执行的时候去找变量。</p><pre class="line-numbers language-py"><code class="language-py">i = 1def  func2():    a = i +1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样是对的, 执行的时候，<code>i</code> 在局部没找到，去找全局</p><p>但是如果是这样：</p><pre class="line-numbers language-py"><code class="language-py">i = 1    def  func2()    a = i +1    i = a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>i</code> 会被当成局部变量，导致执行 <code>a = i+1</code> 时出错。 <code>i</code> 必须要声明才能用，要在函数里面取得外部的i, 可以在开始指定 <code>global  i</code>。</p><h2 id="动态类型与对象引用"><a href="#动态类型与对象引用" class="headerlink" title="动态类型与对象引用"></a>动态类型与对象引用</h2><p>变量类型的概念只存在对象中。例如 <code>a = 3</code>。创建一个对象来表示 <code>3</code>，这个对象由值3和头信息组成，头信息是一个指向 <code>int</code> 的对象的指针。它的步骤应该是这样的：</p><ul><li>创建一个变量a，如果它还没创建的话。</li><li>进行引用，a变量的引用是对象3。</li></ul><p>深刻理解 <code>变量，对象，引用</code></p><ul><li>变量：变量是一个系统表的元素，拥有指向对象的链接空间</li><li>对象：对象是分配的一块内存，有足够的空间去表示它们所代表的值</li><li>引用：是自动形成的从变量到对象的指针</li><li>引用计数器：对象拥有引用计数器</li></ul><p>理解共享引用，两个对象都指向同一个对象</p><p>对于赋值，每次都是创建新的引用，但是列表支持在原处修改（修改某个元素，不会创建新的对象，把变量赋值为3，则原来指向列表对象，想再指向整形对象，此时创建的新对象），原处修改的，如果想不改变原来的值，可以进行对象拷贝。</p><p>加深：a=3, b=a也是实现了共享引用，和列表一样，但是它不支持在原处修改。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>python 依赖于类型的行为称为多态。为对象来编写接口，而不是为数据类型来编写接口，注意多态的弊端，如果你的接口某个运算只能使用整形，传字符串就出错了，但是多态的灵活性是一种实实在在的好处，是否需要判断类型，可做权衡。一般说python是动态类型语言。</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>每次对函数调用都会创建一个新的本地作用域。</p><p>理解 <code>LEGB</code> 作用域，E中闭包的运用（2.2中加入的功能），这是一种高级的技术，是函数式编程的运用。为了取得函数内部的参数，实现一个闭包，在外部来调用，js中的讲解。</p><p>嵌套作用域的变量在嵌套的函数被调用的时候才进行查找，在循环中，会以最后循环的值为准。使用默认参数，避开嵌套作用域查找。</p><p>分析一个函数的时候，先分析变量的赋值，看其所处的作用域。即先看这个变量会处于什么<br>作用域，再去分析代码。</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">func1</span><span class="token punctuation">(</span>parm1<span class="token punctuation">)</span><span class="token punctuation">:</span>        parm1 <span class="token operator">=</span> parm1        <span class="token keyword">def</span> <span class="token function">func2</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span> parm1<span class="token punctuation">,</span> s        <span class="token keyword">return</span> func2    <span class="token comment" spellcheck="true"># 这样是正确的</span>    <span class="token keyword">def</span> <span class="token function">func1</span><span class="token punctuation">(</span>parm1<span class="token punctuation">)</span><span class="token punctuation">:</span>        parm1 <span class="token operator">=</span> parm1        <span class="token keyword">def</span> <span class="token function">func2</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span> parm1<span class="token punctuation">,</span> s            parm1 <span class="token operator">=</span> parm1 <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">return</span> func2    <span class="token comment" spellcheck="true"># 这样就出错了，以为函数第一，先创建，第二对赋值的变量创建作用域（静态作用域），</span>    <span class="token comment" spellcheck="true"># print 语句等函数执行的时候才去执行，次数需要的参数parm1是局部的（因为下一句赋值的</span>    <span class="token comment" spellcheck="true"># 关系），所以程序出错。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>python3  nonlocal ：</p><p>在python2 中只有 <code>global</code> 被声明的变量会将作用域变成全局。<code>nonlocal</code> 的作用：如果在嵌套函数中赋值，该变量会被判定为局部作用域，如果不先赋值就会出错，如果外层有同名变量，在不改变内层变量名的情况下（内层变量名和外层一样），想引用外层的变量，只有声明变量是 <code>nonlocal</code>。其实改个变量名也可以解决事情。</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">func1</span><span class="token punctuation">(</span>parm1<span class="token punctuation">)</span><span class="token punctuation">:</span>        parm1 <span class="token operator">=</span> parm1        <span class="token keyword">def</span> <span class="token function">func2</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            parm2 <span class="token operator">=</span> parm1            parm2 <span class="token operator">=</span> parm2 <span class="token operator">+</span> <span class="token string">'ss'</span>            <span class="token keyword">print</span> parm2        <span class="token keyword">return</span> func2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若要 <code>parm1 = parm1</code> ,要先 <code>nonlocal  param1</code>。局部作用域里的代码可以读外部作用域（包括全局作用域）里的变量，但不能更改它。一旦进行更改，就会将其当成是局部变量。而如果在更改前又进行了读取操作，则会抛出异常。这里的改变，即赋值，给想变的变量赋值（是不行的，只能使用关键字，如果外部有个x，将x进行 <code>parm = x</code>，是读取了x的值，后面用parm，不属于改变）</p><p>如果上面的例子不好理解nonlocal，可以这样理解：</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">mufunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        a <span class="token operator">=</span> <span class="token number">123</span>        <span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            a <span class="token operator">=</span> a<span class="token punctuation">(</span>标记<span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个函数里面，对于 <code>func a</code> 根据上面所学，应该知道这里a是声明，那么a的作用域被确定，当然因为没有赋值变量就引用，是要报错的。为了让a（标记1）可以拿到上层函数的a，就可以使用关键字：</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">mufunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        a <span class="token operator">=</span> <span class="token number">123</span>        <span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            nonlocal a            a <span class="token operator">=</span> a<span class="token punctuation">(</span>标记<span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>            <span class="token comment" spellcheck="true"># a = 123+1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><ul><li>理解位置参数和关键字参数，针对调用 <code>*</code> 和 <code>**</code> 接收参数时的使用（编写函数）</li><li>调用的时候，传递参数也可以用 <code>*</code> 和 <code>**</code>，python 将进行参数解包</li><li><code>function（1，2，a，b=2）</code>，<code>*</code> 得到 <code>1，2，a</code>，<code>**</code> 得到 <code>b=2</code></li></ul><p>keyword-only(python3)在函数定义的时候，跟在 <code>*</code>args，或直接用 <code>*</code>，后面的参数在调用时，必须用关键字的形式。</p><pre class="line-numbers language-py"><code class="language-py">def dog(name, host, *, age):    print(name, host, age)func(1,2,b=2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>理解函数参数是通过赋值传递到函数中，赋值的方式是通过对象引用。</p><h2 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h2><p>链式编程 是将多个操作（多行代码）通过点号”.”链接在一起成为一句代码。 例如：<code>a.v.fun( )</code></p><h2 id="函数注释-Function-Annotations"><a href="#函数注释-Function-Annotations" class="headerlink" title="函数注释 Function Annotations"></a>函数注释 Function Annotations</h2><p>python3 新增加的特性，可以对函数增加变量注释，以及返回值注释，然后可以通过 <code>__annotations__</code> 获取到注释信息的字典。</p><p>注意：使用该特性并不会对参数以及返回值做限制，lambda不支持函数注释</p><p>例子：</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> <span class="token string">'x'</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token number">5</span> <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">,</span> c<span class="token punctuation">:</span> list<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">:</span> <span class="token string">'xx'</span><span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">:</span> float<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> max<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>func<span class="token punctuation">.</span>__annotations__<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># {'a': 'x', 'b': 11, 'c': &lt;class 'list'>, 'args': 'xx', 'kwargs': &lt;class 'float'>, 'return': 9}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><p>也称为匿名函数（因为没有函数名）</p><p>特性：是一个表达式，而不是一个语句；主体是一个单个的表达式，而不是一个代码块，只能编写简单的函数，不能用像if这样的语句（但可以写if关联的表达式）。由于是表达式，可以出现在列表中，def不能。一个表达式，得到的是函数的引用。</p><h2 id="文件流与二进制流"><a href="#文件流与二进制流" class="headerlink" title="文件流与二进制流"></a>文件流与二进制流</h2><p><code>stringIO  BytesIO</code>，文本流的文件（txt,world,excel）才用StringIO，二进制流（视频，图片）用BytesIO</p><h2 id="动态载入模块"><a href="#动态载入模块" class="headerlink" title="动态载入模块"></a>动态载入模块</h2><p>可能会有需求根据需要载入不同的模块，利用多态的特性进行程序设计</p><ol><li>exec()函数<pre class="line-numbers language-py"><code class="language-py">modelname = 'string'exec('import'+modelname)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>或者利用 <code>__import__</code> （推荐）<pre class="line-numbers language-py"><code class="language-py">modelname = 'string'string = __import__(modelname)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h2 id="处理json"><a href="#处理json" class="headerlink" title="处理json"></a>处理json</h2><p>json是按照一定格式的字符串，json模块有 <code>loads，dumps，load，dump</code></p><p>后两个是文件相关的，前两个是直接转换成字符串的。</p><p>dumps将基本类型转换成json格式字符串，转换后的类型是str，需要注意的是，dumps的参数里面如果包含对象，就不是基本类型，无法进行转换，转换的对象必须是serializable(可序列化)的，不然会报类型错误。这时候需要设置参数 <code>json.dumps(mydata, default=changefun)</code> 接受一个函数的引用，这个函数用来处理不能直接转换的类型。函数示例：</p><pre class="line-numbers language-PY"><code class="language-PY">def changefun(obj):    if hasattr(obj, 'display'):        return obj.display<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象相关内容</p><h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>委托的概念，就是你想访问A类的时候，通过B类来访问，一般实现在B类中创建一个私有属性，指向A的实例。</p><p>class ：class语句是对象的创建者并且是一个隐含的赋值运算—执行时，它会产生类对象，并把其引用值存储在前面所使用的变量名。就是说，只有代码跑到这里，或者是导入class语句才发挥作用。</p><p>注意：一个对象的属性查找顺序遵循首先查找实例对象自己，然后是类，接着是类的父类。如果有一个类变量叫“data”, 实例也有一个变量同名，那么通过self.data去找到的只是实例的，当实例没有这个变量，才会找到类变量。一般类变量访问通过类名来获取。</p><p>加深：类本身拥有自己的类变量（保存在内存），当一个TestClass类的对象被构造时，会将当前类变量拷贝一份给这个对象，当前类变量的值是多少，这个对象拷贝得到的类变量的值就是多少；而且，通过对象来修改类变量，并不会影响其他对象的类变量的值，因为大家都有各自的副本，更不会影响类本身所拥有的那个类变量的值；只有类自己才能改变类本身拥有的类变量的值。这也是python的特别，不同于C++的静态变量。</p><p>类变量是不是共享？当我们创建的实例，类变量会被复制一份给实例，各个实例用的是自己的，要修改类变量，只能用类去访问，不能用实例去访问，实例访问的是自己的类变量（由类复制一份给它的）。所以实例操作类变量，是操作自己的类变量，影响不了其它实例，要真正修改类变量，还用用类本身去访问。</p><p>理解隐式调用：方法第一个参数总是接收方法调用的隐性主体，也就是实例对象。python会自动把实例方法的调用对应到类方法函数：<br>instance.method(args…)           class.method(instance, args…)</p><p>对于类来说，写在def语句外的都是类变量，想在方法中引用这个变量，需要加上类名。如果变量在class之外，像函数查找变量一样来操作。</p><p>类的构造函数可以有多个，但是只会使用最后一个</p><p>在python中，当对对象进行点号运算时，就会发生继承，而且涉及了搜索属性定义树（一个或多个命名空间）</p><p>类接口技术常用的技巧：超类，继承，重写，扩展，提供（提供者模式）</p><table><thead><tr><th>name</th><th>description</th></tr></thead><tbody><tr><td>Super</td><td>定义一个method函数以及在子类中期待一个动作delegate</td></tr><tr><td>Inheritor</td><td>没有提供任何新的变量名，因此会获得Super中定义的一切内容</td></tr><tr><td>Replacer</td><td>用自己的模版覆盖Super的method</td></tr><tr><td>Extender</td><td>覆盖并回调默认method，从而定制Super的method</td></tr><tr><td>Provider</td><td>实现Super的delegate方法预期的action方法</td></tr></tbody></table><p>研究这些子类来了解它们定制的共同的超类的不同的途径，下面就是这个文件：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Super</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">method</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'in Super.method'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># Defaulr behavior</span>    <span class="token keyword">def</span> <span class="token function">delegate</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>action<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># Expected to be definde</span><span class="token keyword">class</span> <span class="token class-name">Inheritor</span><span class="token punctuation">(</span>Super<span class="token punctuation">)</span><span class="token punctuation">:</span>          <span class="token comment" spellcheck="true"># Inherit method verbatim</span>    <span class="token keyword">pass</span><span class="token keyword">class</span> <span class="token class-name">Replacer</span><span class="token punctuation">(</span>Super<span class="token punctuation">)</span><span class="token punctuation">:</span>           <span class="token comment" spellcheck="true"># Replace method completely</span>    <span class="token keyword">def</span> <span class="token function">method</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'in Replacer.method'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Extender</span><span class="token punctuation">(</span>Super<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">method</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'staring Extender.method'</span><span class="token punctuation">)</span>        Super<span class="token punctuation">.</span>method<span class="token punctuation">(</span>self<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'ending Extender.method'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Provider</span><span class="token punctuation">(</span>Super<span class="token punctuation">)</span><span class="token punctuation">:</span>           <span class="token comment" spellcheck="true"># Fill in a required method</span>    <span class="token keyword">def</span> <span class="token function">action</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'in Provider.action'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于抽象超类：超类Super中定义了一个函数test。调用了自身的action函数。但是Super中并没有定义action函数。这个超类也会称为抽象超类。意思是说，类的部分行为由子类来提供。</p><p>委托，拦截了对实例属性的访问。即在当前类里面，访问委托类的属性，都会被拦截。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Wrapper</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> object<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>wrapper <span class="token operator">=</span> object    <span class="token keyword">def</span> <span class="token function">__getattr__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> attname<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span> <span class="token string">'do some thing'</span>        <span class="token keyword">return</span> getattr<span class="token punctuation">(</span>self<span class="token punctuation">.</span>wrapper<span class="token punctuation">,</span> attname<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>属性名称：对象命名空间</p><p>点号的属性名指的是特定对象定属性，并且遵循模块和类定规则。就类和实例对象而言，引用规则增加了继承搜索这个流程。</p><p>赋值语句（object.X = value）</p><p>在进行点号运算的对象的命名空间内创建或修改属性名X，并没有其他作用。继承树的搜索只发生只属性引用时，而不是属性的赋值运算时。</p><p>引用（object.X）</p><p>就基于类的对象而言，会在对象内搜索属性名X，然后是其上所有可读取的类（使用继承搜索流程）</p><p>对于目前类来说，结合着函数部分的内容，理解作用域是关键，赋值和引用也是关键，看到一条语句要知道它是赋值还是引用，将大大加深你对程序的理解。</p><p>加深：作用域总是由赋值语句的位置决定。这里引申一下python3 关键字 nolocal 可以让变量查找作用域到达外层，这样就可以取函数外层的变量了，但不是将其设置为全局（global）。一定要理解赋值和引用。</p><pre><code>def  A():    x = 'a'    def B():        x += 1</code></pre><p>在这个例子里面，内层的x还没赋值就参与了运算，是不对的，一般像 y = x + 1是把外层的x拿来，是不能改变x的，要改变，是对变量操作，所以变量要先赋值。所以要用global ，或者nolocal 。还是那句话，这些例子和概念是为了理解LEGB，实际开发我们没必要设置一样的变量名。</p><p>命名空间字典：</p><p>模块和类一样，它们的命名空间是以字典的形式来实现的。属性点号的运算其实内部是字典的索引运算，而属性继承其实就是搜索链接的字典。</p><p>内省的方法对函数也适用</p><p>模块和类：模块是数据or逻辑包，通过编写python or C 实现，通过导入来使用。类，由class语句创建，通过调用来使用，总是位于一个模块中。</p><p>抽象超类：</p><p>抽象类是会调用方法的类，但没有继承或定义该方法，而是期待该方法由子类填补。当行为无法预测，非得等到更为具体的子类编写时才知道，通常可以用这种方式把类通用化。OOP软件框架也使用这种方式作为客户端定义，可定制的运算的实现方法。</p><p>通过在子类中重新定义方法，然后再调用超类的方法，可以给这个方法增加功能，而不是完全覆盖。</p><p>python 方法的绑定和未绑定：一般情况，我们都是直接调用方法的。方法是对象，可以获取方法对象而不调用。实例去获取的时候，方法被绑定到实例，得到新对象加上括号就可以调用了。而用类去获取，得到的就是无绑定方法对象，要执行需要把实例作为第一个参数传入。注意，在python3中，无绑定方法将变成函数，它不再是方法对象。显示类型测试程序可能受到影响，如果你打印一个非实例的类方法，它在Python2.6中显示“无绑定方法（unbound method）”，在Python3.0中显示“函数”（function）</p><p>python 扩展内置类型：一般情况，通过继承内置类型，重载运算符，但是最后还是要调用超类的方法。最好有这种需要的时候多查阅下资料。</p><h3 id="继承搜索机制"><a href="#继承搜索机制" class="headerlink" title="继承搜索机制"></a>继承搜索机制</h3><p>只在新式类中，继承搜索是从左到右，广度优先。</p><p>py2继承object的才是新式类，py3写不写object都是新式类</p><p>经典类py2中：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">P1</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'p1-foo'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">P2</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'p2-foo'</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">bar</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'p2-bar'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">C1</span><span class="token punctuation">(</span>P1<span class="token punctuation">,</span> P2<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span><span class="token keyword">class</span> <span class="token class-name">C2</span><span class="token punctuation">(</span>P1<span class="token punctuation">,</span> P2<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">bar</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'C2-bar'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">D</span><span class="token punctuation">(</span>C1<span class="token punctuation">,</span> C2<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新式类：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">P1</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'p1-foo'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">P2</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'p2-foo'</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">bar</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'p2-bar'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">C1</span><span class="token punctuation">(</span>P1<span class="token punctuation">,</span> P2<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span><span class="token keyword">class</span> <span class="token class-name">C2</span><span class="token punctuation">(</span>P1<span class="token punctuation">,</span> P2<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">bar</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'C2-bar'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">D</span><span class="token punctuation">(</span>C1<span class="token punctuation">,</span> C2<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>经典类<pre class="line-numbers language-py"><code class="language-py"> d = D() d.foo() # 输出 p1-foo  d.bar() # 输出 p2-bar <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><ul><li>实例d调用foo()时，搜索顺序是 <code>D =&gt; C1 =&gt; P1</code></li><li>实例d调用bar()时，搜索顺序是 <code>D =&gt; C1 =&gt; P1 =&gt; P2</code><br>换句话说，经典类的搜索方式是按照“从左至右，深度优先”的方式去查找属性。d先查找自身是否有foo方法，没有则查找最近的父类C1里是否有该方法，如果没有则继续向上查找，直到在P1中找到该方法，查找结束。</li></ul><ol start="2"><li>新式类<pre class="line-numbers language-py"><code class="language-py"> d=D()  d.foo() # 输出 p1-foo  d.bar() # 输出 c2-bar <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><ul><li>实例d调用foo()时，搜索顺序是 <code>D =&gt; C1 =&gt; C2 =&gt; P1</code></li><li>实例d调用bar()时，搜索顺序是 <code>D =&gt; C1 =&gt; C2</code><br>可以看出，新式类的搜索方式是采用“广度优先”的方式去查找属性。</li></ul><p>现在是新式类，使用钻石查找规则，在一个父类里面，如果执行了self.method()，这时将从头开始查找一遍。新类是广度优先，A继承了B，C。找了B，然后找C，再找B的父类。如果是旧类，是深度优先，A继承了B，C，B里面找不到就去找B的父类，一直向上，找不到才来C里面找。</p><h3 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h3><p>Python支付属性描述符的概念—带有 <code>__get__</code> 和 <code>__set__</code> 方法的类，分配给类属性并且由实例继承，这拦截了对特定属性的读取和写入访问。描述符在某种意义上是特性的一种更加通用的形式。实际上，特性是定义特定类型描述符的一种简化方式，该描述符运行关于访问的函数。描述符还用来实现slots特性</p><p>注意区分描述符状态和实例状态，描述符自身也是一个类，它有自己的实例，已经调用描述符的实例，所以有两个实例，要注意区分。</p><p>描述符结合 <code>__slots__</code> 使用</p><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>装饰器是利用语法糖@把原来繁琐的方法简化了，装饰器可以分为以下几种：</p><ol><li>普通装饰器</li><li>被装饰对象带参数</li><li>装饰器带参数（被装饰对象同时也可以带参数）</li><li>基于类的装饰器</li><li>带参数的类装饰器</li><li>对类作用装饰器</li><li>装饰器之上的装饰器</li></ol><p>对于1，2，3种情况，都是在前面的基础上进行扩展，是比较常见的情况，为了适应函数不确定的参数，推荐使用可变参数来设计装饰器：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_run_time</span><span class="token punctuation">(</span>show_time<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">ff</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">_func</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">import</span> time            <span class="token keyword">import</span> datetime            <span class="token keyword">if</span> show_time<span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            a <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>            f<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>            b <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">(</span>b <span class="token operator">-</span> a<span class="token punctuation">)</span><span class="token punctuation">,</span> type<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> _func    <span class="token keyword">return</span> ff@get_run_time<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> kwargs<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># func = get_run_time(True)(func) # 不使用语法糖的情况</span><span class="token comment" spellcheck="true"># func(a=12, b=15)</span>func<span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>装饰器也可以是类，由于装饰函数要能callable(因为函数就是能call的，所以类要考虑这个问题)，不然会报错 <code>object is not callable</code> 此时类需要实现 <code>__call__</code>，实例如下（混合了装饰器之上的装饰器，就是把上个装饰器后的结果（一个对象的引用）作为装饰函数的参数传入）：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_run_time</span><span class="token punctuation">(</span>debug<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    获取运行时间    """</span>    flag <span class="token operator">=</span> <span class="token string">'able'</span> <span class="token keyword">if</span> debug <span class="token keyword">else</span> <span class="token string">'disable'</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">_func</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">import</span> time            start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>            func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>            end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>            run_time <span class="token operator">=</span> end <span class="token operator">-</span> start            <span class="token keyword">print</span><span class="token punctuation">(</span>run_time<span class="token punctuation">)</span>        <span class="token keyword">return</span> _func    <span class="token keyword">return</span> f<span class="token keyword">class</span> <span class="token class-name">Logging</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    类装饰器    """</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> func<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>func <span class="token operator">=</span> func    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'logging call'</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>func<span class="token punctuation">(</span><span class="token punctuation">)</span>@Logging@get_run_time<span class="token punctuation">(</span>debug<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">my_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    _list <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">30</span> <span class="token operator">*</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'this is my_func'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># my_func = Logging(get_run_time(False)(my_func)) # 不使用语法糖的情况</span>my_func<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面来看带参数的类装饰器：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_run_time</span><span class="token punctuation">(</span>debug<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    获取运行时间    """</span>    flag <span class="token operator">=</span> <span class="token string">'able'</span> <span class="token keyword">if</span> debug <span class="token keyword">else</span> <span class="token string">'disable'</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">_func</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">import</span> time            start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>            func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>            end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>            run_time <span class="token operator">=</span> end <span class="token operator">-</span> start            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'run_time: {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>run_time<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> _func    <span class="token keyword">return</span> f<span class="token keyword">class</span> <span class="token class-name">LoggingConfig</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    带参数的类装饰器    """</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> level<span class="token operator">=</span><span class="token string">'info'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>level <span class="token operator">=</span> level    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> func<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>level<span class="token punctuation">)</span>            func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        <span class="token keyword">return</span> wrapper@LoggingConfig<span class="token punctuation">(</span><span class="token string">'waring'</span><span class="token punctuation">)</span>@get_run_time<span class="token punctuation">(</span>debug<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">my_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    _list <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">30</span> <span class="token operator">*</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'this is my_func'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># my_func = LoggingConfig()(get_run_time(False)(my_func)) # 不使用语法糖的情况</span>my_func<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>带参数的类装饰器情况还是比较特别的，之所以要这么写，理解 <code>LoggingConfig()(get_run_time(False)(my_func))</code> 就很明了了，类的参数要在类实例化的时候传入，所以把参数写在类 <code>__init__</code> 方法内，然后类需要实现<code>__call__</code> 方法，这个时候就是类的 <code>__call__</code> 要接收一个函数的引用，就是被装饰函数对象的引用。需要注意<code>@LoggingConfig()</code> 的括号不能去掉，不然 <code>__init__</code> 方法出错。</p><p>来看最后一种情况，对类作用装饰器，这个时候可以把类也当成一个对象的引用，类似函数对象的引用，特别注意类要实例化，所以设计装饰器的时候，最后的返回很重要，大致会有两种情况：</p><ol><li>返回类对象的引用，这种情况下，一般是利用装饰器对类进行类属性的操作，比如利用 <code>hasattr</code>判断类是否有特定属性，然后执行一些逻辑，最后返回类对象的引用：</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">as_view</span><span class="token punctuation">(</span>need_login<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">_auth</span><span class="token punctuation">(</span>view_clz<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> need_login<span class="token punctuation">:</span>            setattr<span class="token punctuation">(</span>view_clz<span class="token punctuation">,</span> <span class="token string">'need_login'</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> view_clz    <span class="token keyword">return</span> _auth@as_view<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 即使不传参数也不能省去括号，否则as_view(need_login=False) 的need_login就指向A</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    a <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>x <span class="token operator">=</span> x        <span class="token keyword">if</span> hasattr<span class="token punctuation">(</span>A<span class="token punctuation">,</span> <span class="token string">'need_login'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'need_login is {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>getattr<span class="token punctuation">(</span>A<span class="token punctuation">,</span> <span class="token string">'need_login'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'A not has need_login'</span><span class="token punctuation">)</span>a <span class="token operator">=</span> A<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>返回类实例，这种情况，最内侧是返回一个函数对象的引用，这个函数对象的引用现在指向类，当我们实例化类的时候，就会调用这个函数对象的内容，而这个内容就是返回一个类的实例：</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">as_view</span><span class="token punctuation">(</span>login<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'as_view is {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>login<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">_wrapper</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'cls is {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">_instance</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># setattr(cls, 'need_login', True) # 如果打开这一句，你会发现A仍然没有属性need_login</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'param is {}--{}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>args<span class="token punctuation">,</span> kwargs<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> cls<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># return cls 不能在这里返回类对象的引用，因为上一层返回的是_instance，是一个对象的引用</span>        <span class="token keyword">return</span> _instance    <span class="token keyword">return</span> _wrapper@as_view<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    a <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>x <span class="token operator">=</span> x        <span class="token keyword">if</span> hasattr<span class="token punctuation">(</span>A<span class="token punctuation">,</span> <span class="token string">'need_login'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'need_login is {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>getattr<span class="token punctuation">(</span>A<span class="token punctuation">,</span> <span class="token string">'need_login'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'A not has need_login'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span>__name__<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 此时A已经指向_instance，即使你在上面添加了属性need_login，这个属性也不是A的，这是装饰器需要注意的地方，这对于情况一是不存在的，情况一是把对象的引用进行属性添加，返回的也是这个对象的引用，所以情况1 A.__name__ 仍然是 A。</span>a <span class="token operator">=</span> A<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 结果：</span><span class="token comment" spellcheck="true"># as_view is False</span><span class="token comment" spellcheck="true"># cls is &lt;class '__main__.A'></span><span class="token comment" spellcheck="true"># _instance</span><span class="token comment" spellcheck="true"># param is (2,)--{}</span><span class="token comment" spellcheck="true"># A not has need_login</span><span class="token comment" spellcheck="true"># 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般在应用开发中，会使用情况一对类做一些属性限制，非常好用。</p><ul><li><p>函数装饰器，类装饰器：@staticmethod  类似这样的形式，其中staticmethod 也称为元函数，运用于类的称为类装饰器。装饰器在编写的时候，我们只要知道，装饰器是接受被装饰对象为参数，并将其重新赋值给装饰对象，依照此基础就可以来写装饰器。相对于类装饰器，更像是对类进行扩展，把类在装饰函数里面执行操作后（一般是添加属性等），然后返回本身。</p></li><li><p>装饰器的理念是对原函数、对象的加强，相当于重新封装，所以一般装饰器函数都被命名为wrapper()，意义在于包装。函数只有在被调用时才会发挥其作用。比如@logging装饰器可以在函数执行时额外输出日志，@cache装饰过的函数可以缓存计算结果等等。</p></li><li><p>而注解和特性则是对目标函数或对象添加一些属性，相当于将其分类。这些属性可以通过反射拿到，在程序运行时对不同的特性函数或对象加以干预。比如带有Setup的函数就当成准备步骤执行，或者找到所有带有TestMethod的函数依次执行等等。</p></li></ul><p>:green_apple:<strong>装饰器陷阱：</strong></p><p>使用装饰器需要注意两个地方，最好不要在装饰函数之外添加逻辑功能；使用了装饰器，函数签名会被改变。</p><ol><li>第一种情况，如下实例代码：</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">html_tags</span><span class="token punctuation">(</span>tag_name<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'begin outer function.'</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">wrapper_</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"begin of inner wrapper function."</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>            content <span class="token operator">=</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&lt;{tag}>{content}&lt;/{tag}>"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>tag<span class="token operator">=</span>tag_name<span class="token punctuation">,</span> content<span class="token operator">=</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'end of inner wrapper function.'</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> wrapper    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'end of outer function'</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> wrapper_<span class="token comment" spellcheck="true"># @html_tags('b')</span><span class="token keyword">def</span> <span class="token function">hello</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'Toby'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token string">'Hello {}!'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>name<span class="token punctuation">)</span>hello <span class="token operator">=</span> html_tags<span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span>hello<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'Toby'</span><span class="token punctuation">)</span>hello<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'Toby'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码结果：</p><pre><code>begin outer function.end of outer functionbegin of inner wrapper function.end of inner wrapper function.&lt;b&gt;Hello Toby!&lt;/b&gt;&lt;b&gt;Hello Toby!&lt;/b&gt;</code></pre><p>因为装饰器在定义后就会执行了，因为Python的代码在定义的时候就会确定作用域，变量等，所以 <code>'end of inner wrapper function.'</code> 之上的代码在对hello使用装饰器后就会打印了。调用hello两次，只会执行装饰器函数里面的代码。</p><p>即：<code>'print("&lt;{tag}&gt;{content}&lt;/{tag}&gt;".format(tag=tag_name, content=content))'</code> 所以代码结果是这样的。</p><p>所以最好不要在装饰器函数之外添加逻辑功能，这里的逻辑功能是print，如果是一些复杂的逻辑，<code>它只会在定义的时候执行一次</code>。</p><ol start="2"><li>获取被装饰函数的函数签名，文档字符串等返回的将是闭包的函数信息。</li></ol><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">html_tags</span><span class="token punctuation">(</span>tag_name<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'begin outer function.'</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">wrapper_</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"begin of inner wrapper function."</span><span class="token punctuation">)</span>            <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token triple-quoted-string string">"""                doc string                """</span>                content <span class="token operator">=</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&lt;{tag}>{content}&lt;/{tag}>"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>tag<span class="token operator">=</span>tag_name<span class="token punctuation">,</span> content<span class="token operator">=</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'end of inner wrapper function.'</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> wrapper        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'end of outer function'</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> wrapper_    <span class="token comment" spellcheck="true"># @html_tags('b')</span>    <span class="token keyword">def</span> <span class="token function">hello</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'Toby'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        hello doc string         """</span>        <span class="token keyword">return</span> <span class="token string">'Hello {}!'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>name<span class="token punctuation">)</span>    hello <span class="token operator">=</span> html_tags<span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span>    hello<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'Toby'</span><span class="token punctuation">)</span>    hello<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'Toby'</span><span class="token punctuation">)</span>    <span class="token keyword">import</span> inspect    doc <span class="token operator">=</span> inspect<span class="token punctuation">.</span>getdoc<span class="token punctuation">(</span>hello<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>hello<span class="token punctuation">.</span>__name__<span class="token punctuation">,</span> doc<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># wrapper doc string</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原因就是因为使用@语法糖，原函数的引用被修改了：<code>hello = html_tags('b')(hello)</code>，那么新的hello的函数信息指向 <code>wrapper</code>。这是最容易发生问题的地方，尤其是使用多次装饰器，如果你需要这样的复杂逻辑，一定要小心对象的引用早已改变，如果还使用原对象名称进行操作，无疑是出BUG。</p><p>如果需要原函数的信息，可以使用标准库 <code>functool.wrapt</code>，对闭包的函数进行装饰：</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">import</span> functools    <span class="token keyword">def</span> <span class="token function">html_tags</span><span class="token punctuation">(</span>tag_name<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'begin outer function.'</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">wrapper_</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"begin of inner wrapper function."</span><span class="token punctuation">)</span>            @functools<span class="token punctuation">.</span>wraps<span class="token punctuation">(</span>func<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 在此运用装饰器</span>            <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token triple-quoted-string string">"""                doc string                """</span>                content <span class="token operator">=</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&lt;{tag}>{content}&lt;/{tag}>"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>tag<span class="token operator">=</span>tag_name<span class="token punctuation">,</span> content<span class="token operator">=</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'end of inner wrapper function.'</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> wrapper        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'end of outer function'</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> wrapper_    <span class="token comment" spellcheck="true"># @html_tags('b')</span>    <span class="token keyword">def</span> <span class="token function">hello</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'Toby'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        hello doc string        """</span>        <span class="token keyword">return</span> <span class="token string">'Hello {}!'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>name<span class="token punctuation">)</span>    hello <span class="token operator">=</span> html_tags<span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span>    hello<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'Toby'</span><span class="token punctuation">)</span>    hello<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'Toby'</span><span class="token punctuation">)</span>    <span class="token keyword">import</span> inspect    doc <span class="token operator">=</span> inspect<span class="token punctuation">.</span>getdoc<span class="token punctuation">(</span>hello<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>hello<span class="token punctuation">.</span>__name__<span class="token punctuation">,</span> doc<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>inspect<span class="token punctuation">.</span>signature<span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># py3之前的版本仍然获取到闭包函数信息</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>inspect<span class="token punctuation">.</span>getsource<span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># py3之前的版本仍然获取到闭包函数信息</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><pre><code>begin outer function.end of outer functionbegin of inner wrapper function.end of inner wrapper function.&lt;b&gt;Hello Toby!&lt;/b&gt;&lt;b&gt;Hello Toby!&lt;/b&gt;hello hello doc string(name='Toby')def hello(name='Toby'):    """    hello doc string    """    return 'Hello {}!'.format(name)</code></pre><p>除了functool.wrapt模块，还可以使用第三方模块wrapt，如果使用该模块，要按照给定的规则来重新包装函数，和functool.wrapt直接使用装饰器相比需要改动代码，另外Python3.x之前functool.wrapt模块并不能得到函数签名和函数源码等，在3.x之后变得可行了。</p><h3 id="利用-dict-做缓存"><a href="#利用-dict-做缓存" class="headerlink" title="利用 dict 做缓存"></a>利用 <strong>dict</strong> 做缓存</h3><p>实例方法可以利用装饰器变成属性，其实质是，方法本身也是类的一个属性，通过装饰器，让访问这个属性的时候传回方法计算后期待的值，实现了将方法变成属性。</p><p>实例和类都有 <code>__dict__</code> 属性，写一个装饰器，让方法变成属性可以直接访问，同时将方法作为属性添加到实例的 <code>__dict__</code> 中去，这样下次再访问这个属性方法的时候，根据属性查找规则，会先去实例里面找，因为实例已经添加了方法的属性键值对，所以直接取到了，不会再去类里面调用方法来计算属性了，从而实现了缓存（在运用的时候，代码运行起来，就每次都是去取缓存了，必须要停下来才去重新计算，所以如果你想要用一些动态技术来生成属性的值，记得把 <code>__dict__</code> 里面的原属性删除，这样你的方法才会被再次调用，重新做缓存）</p><p>以下的例子中，hello只会被执行一次，因为下次从实例里面取，不再调用类的方法了。</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">from</span> cached_property <span class="token keyword">import</span> cached_property    <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>        acs <span class="token operator">=</span> <span class="token string">'11'</span>        patt <span class="token operator">=</span> property<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>z <span class="token operator">=</span> z            self<span class="token punctuation">.</span>info <span class="token operator">=</span> None        @cached_property        <span class="token keyword">def</span> <span class="token function">exinfo</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> type<span class="token punctuation">(</span>self<span class="token punctuation">.</span>info<span class="token punctuation">)</span> <span class="token operator">==</span> dict<span class="token punctuation">:</span>                res <span class="token operator">=</span> self<span class="token punctuation">.</span>info            <span class="token keyword">else</span><span class="token punctuation">:</span>                res <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>                self<span class="token punctuation">.</span>info <span class="token operator">=</span> res            <span class="token keyword">return</span> res        <span class="token keyword">def</span> <span class="token function">mydata</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">'zxc'</span>    a <span class="token operator">=</span> A<span class="token punctuation">(</span><span class="token string">'ss'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>__dict__<span class="token punctuation">,</span> A<span class="token punctuation">.</span>__dict__<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>exinfo<span class="token punctuation">,</span> a<span class="token punctuation">.</span>__dict__<span class="token punctuation">,</span> A<span class="token punctuation">.</span>__dict__<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>exinfo<span class="token punctuation">,</span> a<span class="token punctuation">.</span>__dict__<span class="token punctuation">,</span> A<span class="token punctuation">.</span>__dict__<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="避免循环递归"><a href="#避免循环递归" class="headerlink" title="避免循环递归"></a>避免循环递归</h3><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">__getattribute__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> object<span class="token punctuation">.</span>__getattribute__<span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token string">'other'</span><span class="token punctuation">)</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>利用超类，传递的实例是本对象的。理解方法调用的时候传递的self很重要，你可以改实例，不使用隐式传参。</p><p>对于赋值和删除也需要考虑这个问题，用超类来避免循环。或者用 <code>self.__dict__['other'] = other</code>，这个对于取属性不能用，因为取属性就要循环了。总结：取属性要特别注意，获取和删除不能直接对实例的属性进行赋值，要用超类的setattr方法或者实例的 <code>__dict__</code> 来赋值。</p><h2 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h2><p>和一般语言返回布尔值不同，python更加灵活：</p><p>在Python中，空字符串为假，非空字符串为真。非零的数为真。</p><p>数字和字符串之间、字符串之间的逻辑操作规律是：</p><ol><li>对于and操作符：<br>只要左边的表达式为真，整个表达式返回的值是右边表达式的值，否则，返回左边表达式的值</li><li>对于or操作符：<br>只要两边的表达式为真，整个表达式的结果是左边表达式的值。</li></ol><ul><li>如果是一真一假，返回真值表达式的值</li><li>如果两个都是假，比如空值和0，返回的是右边的值。（空值或0）</li></ul><h2 id="usr-bin-env-python"><a href="#usr-bin-env-python" class="headerlink" title="!/usr/bin/env python"></a>!/usr/bin/env python</h2><p>脚本语言的第一行，目的就是指出，你想要你的这个文件中的代码用什么可执行程序去运行它，就这么简单。</p><ul><li>#!/usr/bin/python是告诉操作系统执行这个脚本的时候，调用/usr/bin下的python解释器</li><li>#!/usr/bin/env python这种用法是为了防止操作系统用户没有将python装在默认的/usr/bin路径里。当系统看到这一行的时候，首先会到env设置里查找python的安装路径，再调用对应路径下的解释器程序完成操作</li><li>#!/usr/bin/python相当于写死了python路径</li><li>#!/usr/bin/env python会去环境设置寻找python目录,推荐这种写法</li></ul><p>env是Linux命令，可以启动python。env命令用于显示系统中已存在的环境变量，以及在定义的环境中执行指令。</p><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>类似C的概念。<code>assert group is None, "msg"</code> 其中group是一个变量，如果断言表达式正确，则代码继续，错误则除非断言异常，<code>AssertionError</code> 会把信息打印出来。</p><h2 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h2><p>浅拷贝和深拷贝的加深理解：因为没有这样的需要，所以一直没有注意。再来看看两个点的概念</p><ul><li>浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部的子对象。</li><li>深拷贝(deepcopy)： copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。</li></ul><p>要完全获得一个对象的复制，用深拷贝（深拷贝比较费时间，可能会影响效率），浅拷贝不会拷贝对象内部的子对象，这句话很重要，如果你要拷贝的对象是一个列表，并且列表每一个元素都是一个不可变的，那么浅拷贝效果和深拷贝一样。但是如果你的元素是一个可变对象，比如一个列表，那么原值和新值的这个列表对象都是指向同一个引用的，改其中一个另一个结果也会影响，但是如果是不可变对象，改变其中一个不影响另一个，因为这个不可变对象的拷贝已经是新的引用。</p><p>解析</p><ol><li>b = a: 赋值引用，a 和 b 都指向同一个对象。</li></ol><p><img src="/images/Python/python-copy-1.png" alt="image"></p><ol start="2"><li>b = a.copy(): 浅拷贝, a 和 b 是一个独立的对象，但他们的子对象还是指向统一对象（是引用）。</li></ol><p><img src="/images/Python/python-copy-2.png" alt="image"></p><ol start="3"><li>b = copy.deepcopy(a): 深度拷贝, a 和 b 完全拷贝了父对象及其子对象，两者是完全独立的。</li></ol><p><img src="/images/Python/python-copy-3.png" alt="image"></p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>除了利用引用计数回收外，还有一个垃圾回收机制，gc(garbage collection)。gc这种机制很多语言都会用，但是python兼顾二者，引用计数回收能在对象计数为0的时候就马上回收。但是引用计数会出现循环引用的情况，只有容器类型对象会出现循环引用，不可变对象不会。例如：</p><pre><code>def myfunc():    l = []    l.append(l)</code></pre><p>这个操作会循环引用对象I，对于循环引用的情况，利用引用计数来回收就不行了，所以出现了gc机制。这个机制是自动的，可以认为触发。垃圾回收机制会根据内存的分配和释放情况的而被调用，比如分配内存的次数减去释放内存的次数大于某一个阈值的时候。</p><h2 id="Python-常见文件格式"><a href="#Python-常见文件格式" class="headerlink" title="Python 常见文件格式"></a>Python 常见文件格式</h2><p>Python源代码遵循 GPL (GNU General Public License) 协议，由 Guido van Rossum 于 1989 年底发明，第一个公开发行版发行于 1991 年。</p><p>Python 常被称为胶水语言，能把用其他语言编写的各模块 (尤其是 C/C++) 轻松地联结在一起。常见情形是，用 Python 快速生成程序原型 (有时甚至是程序最终界面)，然后对其中有特别要求的部分，用更合适的语言改写；譬如：3D 游戏中的图形渲染模块，性能要求特别高，就可用 C/C++ 重写，而后封装为 Python 可调用的扩展类库。需要注意的是，在您使用扩展类库时可能需要考虑平台问题，某些扩展类库可能不提供跨平台实现。</p><p>一般认为，Python 是一种解释性语言，Python 在执行时，会先将 .py 文件中的源代码编译成  byte code (字节码)，然后再由 Python Virtual Machine 来执行这些编译 byte code。</p><p>这种机制的基本思想跟 Java、.NET 一致；但 Python Virtual Machine 与 Java 或 .NET 的 Virtual Machine 不同的是：Python 的 Virtual Machine 是一种更高级的 Virtual Machine。这里的高级并不是通常意义上的高级，不是说 Python 的 Virtual Machine 比 Java 或 .NET 的功能更强大，更拽，而是说和 Java 或 .NET 相比，Python 的 Virtual Machine 距真实机器的距离更远。或者可以这么说，Python 的 Virtual Machine 是一种抽象层次更高的 Virtual Machine。</p><p>Python 提供了一种中间编译结果保存机制，即 byte code，或更准确地说，保存 PyCodeObject。事实上，Python 确实提供了这样一种机制 —— .pyc 文件。在执行一个 .py 文件的源代码之后，Python 并不会自动生成与该 .py 文件对应的 .pyc 文件。Python 会根据需要自动触发、创建 .pyc 文件，原理很简单，就是利用 Python 的 import 机制。</p><p>在 Python 运行过程中如碰到 import abc 这样的语句，Python 将会在设定好的 path 中寻找 abc.pyc 或 abc.dll 文件。若没有这样的文件，而只是发现了 abc.py 文件，那么，Python 会首先将 abc.py 编译成相应的 PyCodeObject 中间结果，然后再创建 abc.pyc 文件，并将中间结果写入该文件。接下来，Python 才会对 abc.pyc 文件进行一个 import 动作，实际上也就是将 abc.pyc 文件中的 PyCodeObject 重新在内存中复制出来，加以运行。</p><p>由于 Python .pyc 文件的此种运行机制，所以，可随时删除所有中间过程 .pyc 文件，当 Python 再次运行时，还会重生成这些 .pyc 文件，对您所编辑程序的运行并无任何影响。当然，得有源代码才行。</p><p>视窗用 python.exe 运行 .py ，用 pythonw.exe 运行 .pyw。因为安装视窗版 Python 时，扩展名 .py 自动被登记为用 python.exe 运行， 而 .pyw 则被登记为用 pythonw.exe 运行。 </p><ul><li><code>.py 文件</code><br>以 .py 作扩展名的文件是 Python 源代码文件，由 python.exe 解释，可在控制台下运行。</li></ul><p>当然，也可用文本编辑器或其它专用 Python IDE (集成开发环境) 工具进行修改。</p><ul><li><code>.pyc 文件</code><br>以 .pyc 作扩展名的文件是 python 编译文件。.pyc 文件是不能直接用文本编辑器进行编辑，其优点是 .pyc 文件的执行速度要远快于 .py 文件。</li></ul><p>至于为什么要有 .pyc 文件，因为 .py 文件是可直接看到源码的。若是软件开发商，不可能把源码泄漏出去？所以，就需编译成 .pyc 后再发布。</p><p>但 .pyc 文件只是经简单编译，并未加密，因此，有些工具还能反编译它得出源代码。</p><ul><li><code>.pyw 文件</code><br>.pyc 文件执行时，桌面会出现类似 CMD 命令的黑色 shell 窗口，十分难看，于是 .pyw 文件就应运而生了。.pyw 文件与 .pyc 文件的执行，本质上并没什么区别，只是 .pyw 文件执行的时候不会出现类似 CMD 命令的黑色 shell 窗口。</li></ul><p>.pyw 文件格式主要是设计用来运行 Python 纯 GUI (图形用户界面) 程序的。纯 GUI (图形用户界面) 程序的用户不需要看到类似 CMD 命令的黑色 shell 控制台窗口。当 .pyw 文件运行时，所有 stdout、stderr 输出无效，所有原 stdin 的读取只会得到 EOF。</p><p>值得一提的是，开发纯 GUI (图形用户界面) 程序时，可暂时把 .pyw 改成 .py，以便运行时调出控制台窗口，看到所有错误信息，方便修改、调试。</p><p>注意：采用 PyQt、PySide 等 GUI (图形用户界面) 开发框架开发的程序，源文件仍可采用 .py，无需单独使用 .pyw。</p><ul><li><code>.pyo 文件</code><br>“python -O 源文件” 即可将 Python 源程序编译成 .pyo 文件，但有时仍得采用 .pyc 作后缀，才能正常运行。</li></ul><p>.pyo 文件是相对 .pyc 而言的，优化编译后的 Python 文件。 同样，.pyo 文件也不能直接用文本编辑器进行编辑。</p><ul><li><code>.pyd 文件</code><br>.pyd 文件是非 Python，由其它编程语言 “编写-编译” 生成的 Python 扩展模块。</li></ul><p>Python 要导入 .pyd 文件，实际上是在 .pyd 文件中封装了一个 module。在 python 中使用时，把它当成 module 来用就可以了，即：”import 路径名.modulename” 即可，路径名为 .pyd 文件所在的路径。</p><p>基于 Qt/C++ 的 PyQt、PySide GUI (图形用户界面) 开发框架绑定，会为每个 Qt/C++ 库 .dll 文件生成一个中间 .pyd 文件。PyWin32 项目分发包中，也存在很多 MicroSoft Windows OS 相应 .dll 文件的中间 .pyd 文件。</p><p>Cython 可将个人基于 Python 语言编写的 Python 模块编译成具有 C 语言特性的 .pyd 文件。</p><p>.pyd 文件有时也是用 D 语言按照一定格式编写，编译生成的二进制文件。</p><p>那么什么是 “D 语言” 呢？它是 C/C++ 的综合进化版，不仅具有二者的全部优点，且整体性能更佳，但其抽象程度高。D 语言最初由 Digital Mars 公司就职的 Walter Bright 于 2001 年发布，意图改进 C++ 语言。目前最新 D 语言被简称为 D2。最主要的 D 语言实现是 DMD。</p><p>D 语言源自 C/C++，借鉴了众多编程语言的特色和现代编译器技术，融会贯通了设计者丰富的实践经验，使之具备了非凡的威力 ── 既有 C/C++ 语言的强大威力，又有 Python 和 Ruby 的开发效率。它集众多系统级编程所需的功能于一身，例如垃圾回收、手工内存操作、契约式设计、高级模板技术、内嵌汇编、内置单元测试、Mixin 风格多继承、类 Java 包管理机制、内置同步机制、内建基本运行时信息。</p><h2 id="文本与二进制"><a href="#文本与二进制" class="headerlink" title="文本与二进制"></a>文本与二进制</h2><p>在 Python 2 中，文本类型（也就是 unicode）和二进制类型（也就是 str）的边界非常模糊。很多函数的参数既可以是文本，也可以是二进制。</p><p>但是在 Python 3 中，文本类型和二进制类型的字符串被完全的区分开了。Python 3对文本和二进制数据作了更为清晰的区分。</p><p>文本总是Unicode，由str类型表示，二进制数据则由bytes类型表示。</p><p>不能拼接字符串和字节包，也无法在字节包里搜索字符串（反之亦然），也不能将字符串传入参数为字节包的函数（反之亦然）。</p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>a = 0011 1100</p><p>b = 0000 1101</p><table><thead><tr><th>name</th><th align="center">Description</th><th align="left">Example</th></tr></thead><tbody><tr><td>&amp;</td><td align="center">按位与运算符</td><td align="left">参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0    (a&amp;b)输出结果12，二进制解释：00001100</td></tr><tr><td>|</td><td align="center">按位或运算符</td><td align="left">只要对应的二个二进位有一个为1时，结果位就为1。    (a|b)输出结果61，二进制解释：00111101</td></tr><tr><td>^</td><td align="center">按位异或运算符</td><td align="left">当两对应的二进位相异时，结果为1    (a^b)输出结果49，二进制解释：00110001</td></tr><tr><td>~</td><td align="center">按位取反运算符</td><td align="left">对数据的每个二进制位取反,即把1变为0,把0变为1。<del>x类似于-x-1    (</del>a)输出结果-61，二进制解释：11000011，在一个有符号二进制数的补码形式。</td></tr><tr><td>&lt;&lt;</td><td align="center">左移动运算符</td><td align="left">运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。    a&lt;&lt;2输出结果240，二进制解释：11110000</td></tr><tr><td>&gt;&gt;</td><td align="center">右移动运算符</td><td align="left">把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数    a&gt;&gt;2输出结果15，二进制解释：00001111</td></tr></tbody></table><p>关于异或：</p><p>异或是一种基于二进制的位运算，用符号XOR或者 ^ 表示，其运算法则是对运算符两侧数的每一个二进制位，同值取0，异值取1。它与布尔运算的区别在于，当运算符两侧均为1时，布尔运算的结果为1，异或运算的结果为0。</p><p>简单理解就是不进位加法，如1+1=0，,0+0=0,1+0=1。</p><p>性质</p><p>1、交换律 可任意交换运算因子的位置，结果不变</p><p>2、结合律（即(a^b)^c == a^(b^c)）</p><p>3、对于任何数x，都有x^x=0，x^0=x，同自己求异或为0，同0求异或为自己</p><p>4、自反性 A ^ B ^ B = A ^ 0 = A ，连续和同一个因子做异或运算，最终结果为自己</p><p>异或运算，只看运算方法，会觉得很奇怪，但是由方法引申出一些性质，再把这些性质作为公式或口诀熟记，异或才能真正去解决问题。</p><p>比如：</p><ol><li>两个变量交换<pre><code>a = a^b</code></pre></li></ol><p>b = a^b</p><p>a = a^b</p><pre><code>2. 判断奇偶数更简单高效的做法奇数二进制的最低位一定是1，偶数二进制的最低位一定是0，所以拿一个数和1作异或就可以判断奇偶性3. 可以去除一些数组中重复的数，利用4个特性## ASCII`ord()` 函数接受一个字符，转换成ASII码。`chr()` 接受一个整型ASII变量，转换成字符## logging 模块logging模块很灵活，是项目必备的模块，日志级别 `CRITICAL &gt; ERROR &gt; WARNING &gt; INFO &gt; DEBUG`，默认logger的level是logging.WARNING，低于该级别的就不输出了。在导入模块后，通过logging.basicConfig(level=logging.NOTSET)来配置日志级别，这里设置为NOTSET，所有级别都会被输出（貌似和设置DEBUG级别是一样的效果，感觉作用在于重写类对象，新增加级别的时候设置NOTSET可以不受控制）## mappingproxy（不可变映射类型）python3.3开始,types模块中引入了一个封装类名叫MappingProxyType，如果给这个类一个映射,它会返回一个只对映射视图。虽然是个只读的视图,但是它是动态的,这意味着如果对原映射做出了改动，我们可以通过这个视图观察到,但是无法通过这个视图对原映射做出修改。```python    #示例    from types import MappingProxyType    #创建一个集合    index_a = {'a' : 'b'}    #创建index_a的映射视图    a_proxy = MappingProxyType(index_a)    print(a_proxy)    a_proxy['a']    # #不能对a_proxy视图进行修改    # a_proxy['b'] = 'bb'    #但是可以对原映射进行修改    index_a['b'] = 'bb'    print(a_proxy)</code></pre><p>另外值得注意的是，类的 <code>__dict__</code> 属性也是mappingproxy的，之所以这么做是为了保证类级别的属性和方法只能是字符串，也帮助解释器更快的查找类级别的属性（因为它是字符串的）。类的属性是实例共享的，这也保证了类的统一性。所以你不应该设计这样的程序：通过<code>class.__dict__.update(dict()STATUS=0)</code>去修改类的属性，可以做的是修改实例的属性，记住创建实例会把类的属性复制一份给实例。</p><h2 id="利用偏函数设计程序"><a href="#利用偏函数设计程序" class="headerlink" title="利用偏函数设计程序"></a>利用偏函数设计程序</h2><p>偏函数是将所要承载的函数作为partial()函数的第一个参数，<code>原函数的各个参数依次作为partial()函数后续的参数</code>，除非使用关键字参数。</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">from</span> functools <span class="token keyword">import</span> partial    <span class="token keyword">def</span> <span class="token function">mod</span><span class="token punctuation">(</span> n<span class="token punctuation">,</span> m <span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> n <span class="token operator">%</span> m    mod_by_100 <span class="token operator">=</span> partial<span class="token punctuation">(</span> mod<span class="token punctuation">,</span> <span class="token number">100</span> <span class="token punctuation">)</span>     <span class="token keyword">print</span> mod<span class="token punctuation">(</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">7</span> <span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 2</span>    <span class="token keyword">print</span> mod_by_100<span class="token punctuation">(</span> <span class="token number">7</span> <span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 2  mod(100, 7) 原函数的各个参数依次作为partial()函数后续的参数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进制转换</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">from</span> functools <span class="token keyword">import</span> partial    bin2dec <span class="token operator">=</span> partial<span class="token punctuation">(</span> int<span class="token punctuation">,</span> base<span class="token operator">=</span><span class="token number">2</span> <span class="token punctuation">)</span>    <span class="token keyword">print</span> bin2dec<span class="token punctuation">(</span> <span class="token string">'0b10001'</span> <span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 17</span>    <span class="token keyword">print</span> bin2dec<span class="token punctuation">(</span> <span class="token string">'10001'</span> <span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 17</span>    hex2dec <span class="token operator">=</span> partial<span class="token punctuation">(</span> int<span class="token punctuation">,</span> base<span class="token operator">=</span><span class="token number">16</span> <span class="token punctuation">)</span>    <span class="token keyword">print</span> hex2dec<span class="token punctuation">(</span> <span class="token string">'0x67'</span> <span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 103</span>    <span class="token keyword">print</span> hex2dec<span class="token punctuation">(</span> <span class="token string">'67'</span> <span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 103</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a>random模块</h2><p>random.random() 生成1到0之间的随机数，可以到小数点后好几位。</p><p>random.uniform(10, 20) 可以指定随机数范围，生成的结果仍然是带小数的。</p><p>通过指定seed，可以控制随机数的生成。random.seed(time.time())，在调用随机数生成之前指定相同的seed，参数为时间戳，时间戳也必须是一样的，这样多次调用random得到的随机数就是一样的了。</p><p>random.randint(1, 10) 指定范围，并且生成的随机数为整数。</p><p>random.randrange(1, 20, 3) 限定范围，指定step，相当于从[1, 4, 7, 10, 13, 16, 19]中取一个随机数。</p><p>random.choice(sequence) 从序列中取一个，random.choices(sequence, k=3) 取三个。</p><p>random.sample(sequence, 3) 从序列中取样3个元素，不会取重复的，而choice可能会选到重复的。</p><h2 id="标准库itertools进行分组"><a href="#标准库itertools进行分组" class="headerlink" title="标准库itertools进行分组"></a>标准库itertools进行分组</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> itertools <span class="token keyword">import</span> groupby_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>_list<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> x<span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>a <span class="token operator">=</span> groupby<span class="token punctuation">(</span>_list<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> x<span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="sys-exit-os-exit"><a href="#sys-exit-os-exit" class="headerlink" title="sys.exit() os._exit()"></a>sys.exit() os._exit()</h2><p>os._exit()会直接将python程序终止，之后的所有代码都不会继续执行。<br>sys.exit()会引发一个异常：SystemExit，如果这个异常没有被捕获，那么python解释器将会退出。<br>如果有捕获此异常的代码，那么这些代码还是会执行。捕获这个异常可以做一些额外的清理工作。0为正常退出，其他数值（1-127）为不正常，可抛异常事件供捕获。</p><h2 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h2><p>在 linux 环境下用 Python 进行项目开发过程中经常会遇到多个进程对同一个文件进行读写问题，而此时就要对文件进行加锁控制，在 Python 的 linux 版本下有个 fcntl 模块可以方便的对文件进行加、解锁控制。</p><pre class="line-numbers language-py"><code class="language-py">import fcntlfile_path = "/home/ubuntu/aaa.json"f = open(file_path, 'w')fcntl.flock(f.fileno(), fcntl.LOCK_EX)    # 加锁，其它进程对文件操作则不能成功f.write("something")fcntl.flock(f.fileno(), fcntl.LOCK_UN)    # 解锁f.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>fcntl.flock(f.fileno(), operation)    operation 的操作包括以下选项：</p><p>fcntl.LOCK_EX</p><p>排他锁：    除加锁进程外其他进程没有对已加锁文件读写访问权限</p><p>fcntl.LOCK_UN</p><p>解锁：        对加锁文件进行解锁</p><p>fcntl.LOCK_SH</p><p>共享锁：    所有进程都没有写权限，即使加锁进程也没有，但所有进程都有读权限</p><p>fcntl.LOCK_NB</p><p>非阻塞锁：    如果指定此参数，函数不能获得文件锁就立即返回，否则，函数会等待获得文件锁。</p><p>LOCK_NB可以同LOCK_SH或LOCK_NB进行按位或（|）运算操作。</p><p>fcnt.flock(f.fileno(),fcntl.LOCK_EX|fcntl.LOCK_NB)</p><h2 id="文件操作模式"><a href="#文件操作模式" class="headerlink" title="文件操作模式"></a>文件操作模式</h2><p>r    以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。<br>rb    以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。<br>r+    打开一个文件用于读写。文件指针将会放在文件的开头。<br>rb+    以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。<br>w    打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。<br>wb    以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。<br>w+    打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。<br>wb+    以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。<br>a    打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。<br>ab    以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。<br>a+    打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。<br>ab+    以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Collect 站点收藏</title>
      <link href="/2018/10/22/Collect/collect/"/>
      <url>/2018/10/22/Collect/collect/</url>
      
        <content type="html"><![CDATA[<p>常用内容收集整理，内容来自网络与个人整理</p><a id="more"></a><h1 id="收藏内容"><a href="#收藏内容" class="headerlink" title="收藏内容"></a>收藏内容</h1><p>内容来自<a href="https://panjiachen.github.io/awesome-bookmarks/" target="_blank" rel="noopener">某位大佬</a>，网络收集与个人整理</p><h2 id="注册码"><a href="#注册码" class="headerlink" title="注册码"></a>注册码</h2><p><a href="http://idea.lanyus.com/" target="_blank" rel="noopener">IntelliJ IDEA</a></p><p><a href="https://blog.csdn.net/songfei_dream/article/details/93161900" target="_blank" rel="noopener">https://blog.csdn.net/songfei_dream/article/details/93161900</a></p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p><a href="https://www.jianshu.com/p/3ae2f024c291" target="_blank" rel="noopener">申请Let’s Encrypt永久免费SSL证书(来自简书)</a><br><a href="https://app.netlify.com/" target="_blank" rel="noopener">Netlify 是一个提供网络托管的综合平台</a></p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p><a href="https://github.com/nuxt/consola" target="_blank" rel="noopener">consola</a> 优雅命令行 console vuepress 也使用了</p><p><a href="https://github.com/nuxt/webpackbar" target="_blank" rel="noopener">webpackbar</a> webpack 打包进度可视化</p><p><a href="https://github.com/zouhir/jarvis" target="_blank" rel="noopener">jarvis</a> webpack dashboard</p><p><a href="https://github.com/Popmotion/popmotion" target="_blank" rel="noopener">popmotion</a> 一个函数式声明前端动画库</p><p><a href="https://github.com/lukechilds/merge-images" target="_blank" rel="noopener">merge-images</a> 图片合成</p><p><a href="https://github.com/NigelOToole/direction-reveal" target="_blank" rel="noopener">direction-reveal</a> 一个根据鼠标进入方向展现 hover 描述的库</p><p><a href="https://github.com/webkul/micron" target="_blank" rel="noopener">micron</a> 通过动画属性绑定动画效果的库</p><p><a href="https://github.com/sweetalert2/sweetalert2" target="_blank" rel="noopener">sweetalert2</a> 一个自适应优美自定义性强的弹出框</p><p><a href="https://github.com/photonstorm/phaser" target="_blank" rel="noopener">phaser</a> 这是一个为桌面和移动浏览器开发 HTML5 游戏的快速开源框架。<br>你可以为 iOS、 Android 和不同的本地应用程序创建游戏。</p><p><a href="https://github.com/Botre/vue-sauce" target="_blank" rel="noopener">vue-sauce</a> 一个可以展示 vue 源码的指令</p><p><a href="https://github.com/atomiks/tippyjs" target="_blank" rel="noopener">tippy.js </a>tooltip/popover library</p><p><a href="https://github.com/kutlugsahin/vue-smooth-dnd" target="_blank" rel="noopener">vue-smooth-dnd</a> Vue wrappers components for smooth-dnd</p><p><a href="https://github.com/text-mask/text-mask" target="_blank" rel="noopener">text-mask</a> 一个可以让 input 按照规则输入(如电话,email,日期等)</p><p><a href="https://github.com/CompuIves/codesandbox-client" target="_blank" rel="noopener">codesandbox-client</a> 在线 web 开发容器</p><p><a href="https://github.com/fkling/astexplorer" target="_blank" rel="noopener">astexplorer</a> 一个在线 ast 生成器</p><p><a href="https://github.com/sarahdayan/dinero.js" target="_blank" rel="noopener">dinero.js</a> 一个钱计算的库</p><p><a href="https://github.com/atulmy/crate" target="_blank" rel="noopener">crate</a> 一个 react 全栈练习(pc,mobile,rn,api)demo</p><p><a href="https://github.com/Jasonette/JASONETTE-iOS" target="_blank" rel="noopener">Jasonette</a>一个用 json 来构建 hybrid 的框架</p><p><a href="https://github.com/vuegg/vuegg" target="_blank" rel="noopener">vuegg</a> 一个 vue 可视化拖拽界面生成器</p><p><a href="https://github.com/sindresorhus/refined-github" target="_blank" rel="noopener">refined-github</a> 优化 github 默认功能的 chrome 插件</p><p><a href="https://github.com/lerna/lerna" target="_blank" rel="noopener">lerna</a> 大项目版本控制工具，项目中可以有多个 package.json 文件</p><p><a href="https://github.com/himynameisdave/git-labelmaker" target="_blank" rel="noopener">git-labelmaker</a> 命令行快速创建 github</p><p><a href="https://github.com/krasimir/react-in-patterns" target="_blank" rel="noopener">react-in-patterns</a> 一本开源叫你写 react 的书</p><p><a href="https://github.com/tehnokv/picojs" target="_blank" rel="noopener">picojs</a> js 人脸识别库</p><p><a href="https://github.com/RevillWeb/img-2" target="_blank" rel="noopener">img-2</a> 一个提高图片加载性能和体验的库，懒加载使用 web worker 模糊预览</p><p><a href="https://github.com/Valve/fingerprintjs2" target="_blank" rel="noopener">fingerprintjs</a> 是一个快速的浏览器指纹库</p><p><a href="https://github.com/epoberezkin/ajv" target="_blank" rel="noopener">ajv</a> 一个 json schema 验证的库</p><p><a href="https://github.com/xx45/dayjs" target="_blank" rel="noopener">dayjs</a> 一个轻量级类 moment.js API 时间库</p><p><a href="https://github.com/tapio/live-server" target="_blank" rel="noopener">live-server</a> 一个建议快速 dev 开发自动刷新的 http server</p><p><a href="https://github.com/zeit/serve" target="_blank" rel="noopener">serve</a>快速起本地静态服务</p><p><a href="https://github.com/PrismJS/prism" target="_blank" rel="noopener">primjs</a> 代码高亮</p><p><a href="https://github.com/RelaxedJS/ReLaXed" target="_blank" rel="noopener">ReLaXed</a> 一个将 document html 转成 PDF 的工具</p><p><a href="https://github.com/fabricjs/fabric.js" target="_blank" rel="noopener">fabric.js</a> 基于 canvas 创建交互式的图片编辑界面非常适合用来做图片合成类工作。</p><p><a href="https://github.com/tabler/tabler" target="_blank" rel="noopener">tabler</a> 高颜值 ui 模板</p><p><a href="https://github.com/liabru/matter-js" target="_blank" rel="noopener">matter-js</a> web 物理引擎</p><p><a href="https://github.com/pshihn/rough" target="_blank" rel="noopener">rough</a> 基于 Canvas 的手绘风格图形库</p><p><a href="https://github.com/wiredjs/wired-elements" target="_blank" rel="noopener">wired-elements</a> 基于 rough.js 分装 button input raido 等组件 真正特别之处在于它的底层是 Web components</p><p><a href="https://github.com/transloadit/uppy" target="_blank" rel="noopener">uppy</a> 一个很好看的也很好用的 前端上传库</p><p><a href="http://ui.toast.com/tui-calendar/" target="_blank" rel="noopener">tui-calendar</a> 功能全面的日程安排日历控件，还支持拖拽。</p><p><a href="https://github.com/tabler/tabler" target="_blank" rel="noopener">tabler</a> 基于 Bootstrap 4 的 Dashboard UI Kit 和美观</p><p><a href="https://github.com/baianat/vee-validate" target="_blank" rel="noopener">vee-validate</a> 基于 vue 的验证，能验证的内容比较全</p><p><a href="https://yugasun.github.io/x-chart/#/" target="_blank" rel="noopener">x-chart</a> 我就是觉得颜色挺好看的</p><p><a href="https://github.com/lusaxweb/vuesax" target="_blank" rel="noopener">vuesax</a> 一个很漂亮的基于 vue 的 ui 框架</p><p><a href="https://github.com/Akryum/vue-virtual-scroller" target="_blank" rel="noopener">vue-virtual-scroller</a> 基于 vue 的虚拟列表无限滚动</p><p><a href="https://github.com/VincentGarreau/particles.js" target="_blank" rel="noopener">particles.js</a> 一个前端画颗粒 粒子的库</p><p><a href="https://github.com/BoxFactura/pulltorefresh.js" target="_blank" rel="noopener">pulltorefresh.js</a> 下个下拉刷新插件</p><p><a href="https://github.com/yued-fe/lulu" target="_blank" rel="noopener">lulu</a> 腾讯阅文基于 jQuery，针对 PC 网站 IE8+（peak 主题）的前端 UI 框架</p><p><a href="https://github.com/chancejs/chancejs" target="_blank" rel="noopener">chancejs</a> 生成随机数据的库</p><p><a href="https://github.com/spritejs/spritejs" target="_blank" rel="noopener">spritejs</a> 360 奇舞团出的跨平台绘图对象模型</p><p><a href="https://github.com/googlechrome/workbox" target="_blank" rel="noopener">workbox</a> 让你的网站更方便的变成 pwa</p><p><a href="https://github.com/nhnent/tui.image-editor" target="_blank" rel="noopener">tui.image-editor</a> 一个功能齐全的在线图片编辑，基于 canvas</p><p><a href="https://github.com/deepsweet/hocs" target="_blank" rel="noopener">hocs</a> react 相关 hoc 收集库</p><p><a href="https://github.com/ai/nanoid" target="_blank" rel="noopener">nanoid</a> 前端轻量 unique string ID 生成库</p><p><a href="https://github.com/pubkey/rxdb" target="_blank" rel="noopener">rxdb</a> 一款开源的快速、灵活的客户端数据库，支持各种浏览器以及 NodeJS，Electron、React 等等，是 PouthDB 之上的一个封装库</p><p><a href="https://github.com/MatteoGabriele/vue-analytics" target="_blank" rel="noopener">vue-analytics</a> 基于 vue 的 谷歌统计封装</p><p><a href="https://github.com/danburzo/percollate" target="_blank" rel="noopener">percollate</a> 命令行工具 能将网页转换成 pdf</p><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p><a href="https://github.com/paulmillr/chokidar" target="_blank" rel="noopener">chokidar</a> node 监听文件变化的库</p><p><a href="https://github.com/jprichardson/node-fs-extra" target="_blank" rel="noopener">fs-extra</a> fs-extra 模块是系统 fs 模块的扩展，提供了更多便利的 API，并继承了 fs 模块的 API</p><p><a href="https://github.com/sindresorhus/globby" target="_blank" rel="noopener">globby</a> 用于模式匹配目录文件</p><p><a href="https://github.com/npm/node-semver" target="_blank" rel="noopener">node-semver</a> node 版本验证库</p><p><a href="https://github.com/mysticatea/npm-run-all/blob/master/docs/node-api.md" target="_blank" rel="noopener">npm-run-all</a> 一个 CLI 工具可以并行或者串行执行 script</p><p><a href="https://github.com/tapio/live-server" target="_blank" rel="noopener">live-server</a> 一个简单的 http server 带有 reload 功能</p><p><a href="https://github.com/indexzero/node-portfinder" target="_blank" rel="noopener">node-portfinder</a> 一个端口嗅探工具</p><p><a href="https://github.com/yeoman/update-notifier" target="_blank" rel="noopener">update-notifier</a> Update notifications for your CLI app</p><p><a href="https://github.com/yargs/y18n" target="_blank" rel="noopener">y18n</a> yargs 基于 i18n 的一个包</p><p><a href="https://github.com/klauscfhq/signale" target="_blank" rel="noopener">signale</a> Hackable console logger</p><p><a href="https://github.com/sindresorhus/execa" target="_blank" rel="noopener">execa</a> A better <code>child_process</code></p><p><a href="https://github.com/SamVerschueren/listr" target="_blank" rel="noopener">listr</a> Terminal task</p><p><a href="https://github.com/tj/commander.js" target="_blank" rel="noopener">commander.js</a> 自动的解析命令和参数，合并多选项，处理短参，等等，功能强大，上手简单</p><p><a href="https://github.com/SBoudrias/Inquirer.js" target="_blank" rel="noopener">Inquirer.js</a> A collection of common interactive command line user interfaces. 命令行询问库</p><p><a href="https://github.com/sindresorhus/ora" target="_blank" rel="noopener">ora</a> Elegant terminal spinner 命令行 loaidng</p><p><a href="https://github.com/chalk/chalk" target="_blank" rel="noopener">chalk</a> 命令行着色美化库</p><p><a href="https://github.com/jondot/hygen" target="_blank" rel="noopener">hygen</a> 快速方便的创建代码 可以命令行创建预设的 template</p><p><a href="https://github.com/GoogleChromeLabs/ndb" target="_blank" rel="noopener">ndb</a> node 调试</p><p><a href="https://github.com/sindresorhus/got" target="_blank" rel="noopener">got</a> http 请求库 如果你觉得 request 太多的话 这是一个不错的选择</p><p><a href="https://github.com/zeeshanu/dumper.js" target="_blank" rel="noopener">dumper.js</a> 能让你的 node console 更加的规整，方便调试</p><p><a href="https://github.com/nswbmw/node-in-debugging" target="_blank" rel="noopener">node-in-debugging</a> node.js 调试指南</p><p><a href="https://github.com/i0natan/nodebestpractices" target="_blank" rel="noopener">nodebestpractices</a> node 最佳实践</p><p><a href="https://github.com/pyloque/fastscan" target="_blank" rel="noopener">fastscan</a> node 敏感词库</p><h2 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h2><p><a href="https://www.prisma.io/docs/" target="_blank" rel="noopener">prisma</a> 让前端也能快速的写出</p><p><a href="https://www.apollographql.com/" target="_blank" rel="noopener">Apollo GraphQL</a> 是基于 GraphQL 的全栈解决方案集合。从后端到前端提供了对应的 lib 使得开发使用 GraphQL 更加的方便</p><h2 id="有趣1"><a href="#有趣1" class="headerlink" title="有趣1"></a>有趣1</h2><p><a href="https://github.com/hendricius/the-bread-code" target="_blank" rel="noopener">the-bread-code</a> 使用程序员的思维制作面包 ，比如制作中使用 A/B test,<br>来比较那种做法更好。</p><p><a href="https://github.com/danistefanovic/build-your-own-x" target="_blank" rel="noopener">build-your-own-x</a> 教你用各种语言实现 Bot Database Neural Network</p><p><a href="https://github.com/trekhleb/javascript-algorithms" target="_blank" rel="noopener">javascript-algorithms </a> 教你用前端知识认识各种算法</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><a href="https://github.com/high-speed-downloader/high-speed-downloader" target="_blank" rel="noopener">high-speed-downloader</a> 百度网盘不限速下载 支持 Windows 和 Mac</p><p><a href="https://github.com/zeit/hyper" target="_blank" rel="noopener">hyper</a> 前端命令行</p><p><a href="https://github.com/ymfe/yapi" target="_blank" rel="noopener">yapi</a> 是一个可本地部署的、打通前后端及 QA 的、可视化的接口管理平台</p><p><a href="https://sway.com/" target="_blank" rel="noopener">sway</a> 一个微软自己出的在线 ppt 很强大</p><p><a href="http://bigjpg.com/" target="_blank" rel="noopener">bigjpg</a> 放大图片的神器 通过神经网络可以放大图片并能降噪</p><p><a href="https://asciiartgen.now.sh" target="_blank" rel="noopener">Ascii Art Generator</a> 在线生成 Ascii 图案</p><p><a href="https://github.com/GetStream/Winds" target="_blank" rel="noopener">Winds</a> 开源 RSS</p><p><a href="https://github.com/kitze/JSUI" target="_blank" rel="noopener">JSUI</a> 一个用来控制管理前端项目的客户端</p><p><a href="https://github.com/pedronauck/docz" target="_blank" rel="noopener">docz</a> 让你能快速写文档的一个库</p><p><a href="https://github.com/pod4g/hiper" target="_blank" rel="noopener">hiper</a> 性能统计分析工具</p><p><a href="https://github.com/verdaccio/verdaccio" target="_blank" rel="noopener">verdaccio</a> 私有 npm</p><p><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="noopener">git-guide</a> git 入门指南</p><p><a href="https://github.com/521xueweihan/git-tips" target="_blank" rel="noopener">git-tips</a> git 进阶</p><p><a href="https://github.com/teambit/bit" target="_blank" rel="noopener">bit</a> 实现了项目之间的代码共享 可以自建私有</p><p><a href="https://github.com/Kenshin/simpread" target="_blank" rel="noopener">simpread</a> 简悦 ( SimpRead ) - 让你瞬间进入沉浸式阅读的扩展</p><p><a href="https://github.com/FiloSottile/mkcert" target="_blank" rel="noopener">mkcert</a> 一键命令 让本地也支持 https</p><p><a href="https://github.com/nbedos/termtosvg" target="_blank" rel="noopener">termtosvg</a> 录制 命令操作转成 svg 基于 python</p><p><a href="https://github.com/apex/gh-polls" target="_blank" rel="noopener">gh-polls</a> 可以在 github issue 中添加投票</p><p><a href="https://github.com/liriliri/eruda" target="_blank" rel="noopener">eruda</a> 移动端调试工具</p><p><a href="https://github.com/Tencent/vConsole" target="_blank" rel="noopener">vConsole</a> 也是一个移动端调试工具 腾讯出品</p><p><a href="https://github.com/faressoft/terminalizer" target="_blank" rel="noopener">terminalizer</a> 命令行录制工具 基于 node</p><p><a href="https://github.com/amio/badgen-service" target="_blank" rel="noopener">badgen</a> 快速构建和 shields 一样的 svg badge 但速度更快</p><p><a href="https://github.com/luin/readability" target="_blank" rel="noopener">readability</a> 移除页面非正文部分 基于 jsdom</p><p><a href="https://github.com/TKkk-iOSer/WeChatPlugin-MacOS" target="_blank" rel="noopener">WeChatPlugin-MacOS</a> 一款功能强大的 macOS 版微信小助手</p><p><a href="https://github.com/checkly/puppeteer-recorder" target="_blank" rel="noopener">puppeteer-recorder</a> 一个 chrome 插件 能够根据你的操作 自动生成 puppeteer 相关代码</p><p><a href="https://github.com/jxnblk/mdx-deck" target="_blank" rel="noopener">mdx-deck</a> 用 markdown 编写演示文稿</p><p><a href="https://github.com/pomber/code-surfer" target="_blank" rel="noopener">code-surfer</a> 基于 mdx-deck 的一个插件<br>让你更好的在文稿中展示 code</p><p><a href="https://progressivetooling.com/" target="_blank" rel="noopener">Progressive Tooling</a> 前端性能优化工具集合</p><p><a href="https://github.com/artf/grapesjs" target="_blank" rel="noopener">https://github.com/artf/grapesjs</a> 可视化建站工具 不需要写代码就能写一个页面，前端再次再次要下岗了</p><p><a href="https://www.image-charts.com/" target="_blank" rel="noopener">image-charts</a> 该服务通过 URL 接受参数，然后生成图表，以图片形式返回</p><p><a href="https://github.com/Zulko/eagle.js" target="_blank" rel="noopener">eagle.js</a> 一个用 vue 来制作 PPT 的库</p><p><a href="https://www.optimizely.com/" target="_blank" rel="noopener">Optimizely</a> A/B Test</p><p><a href="http://www.appadhoc.com/" target="_blank" rel="noopener">appadhoc</a> 一个国内的 A/B Test 服务</p><h2 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h2><p><a href="https://itunes.apple.com/cn/app/get-plain-text/" target="_blank" rel="noopener">get-plain-text</a> 能清除剪贴板里的格式 很实用</p><p><a href="https://github.com/lhc70000/iina" target="_blank" rel="noopener">IINA</a> mac 平台感觉免费最好的播放器 强推</p><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p><a href="https://git.io" target="_blank" rel="noopener">github 短域名服务</a></p><p><a href="https://shields.io/" target="_blank" rel="noopener">shields</a> Github README 里面的装逼小图标</p><p><a href="https://www.webpagefx.com/tools/emoji-cheat-sheet/" target="_blank" rel="noopener">Emoji</a> 方便平时写查找 emoji</p><p><a href="http://emoji.muan.co/#" target="_blank" rel="noopener">emoji.muan</a> 同上 而且更全</p><p><a href="http://git-awards.com/users/search?login=panjiachen" target="_blank" rel="noopener">git-awards</a> github ranking 没事可以查着玩玩</p><p><a href="http://githubrank.com/" target="_blank" rel="noopener">http://githubrank.com/</a> github 按照 followers 排名</p><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><p><a href="https://app.zeplin.io/" target="_blank" rel="noopener">zeplin</a> 前端和设计师神器，有标注、Style Guide、版本管理、简单的团队协作，重点是前端不用写 css 了，复制就可以了。</p><p><a href="http://www.iconfont.cn/" target="_blank" rel="noopener">iconfont</a> 阿里出的图标库，非常实用，支持 svg、font、png 多种格式，基本现在所有图标都在上面找。</p><p><a href="http://cssicon.space/#/" target="_blank" rel="noopener">cssicon</a> 所有的 icon 都是纯 css 画的 缺点：icon 不够多</p><p><a href="http://zhitu.isux.us/" target="_blank" rel="noopener">智图</a> 腾讯出品 在线图片压缩 支持转成 webP 处理静态图片时候很好用</p><p><a href="https://www.picdiet.com/zh-cn" target="_blank" rel="noopener">picdiet</a> 另一个图片压缩网站</p><p><a href="http://apps.eky.hk/css-triangle-generator/" target="_blank" rel="noopener">CSS triangle generator</a> 帮你快速用 css 做出三角形</p><p><a href="http://www.cssarrowplease.com/" target="_blank" rel="noopener">cssarrowplease</a> 帮你做对话框三角的</p><p><a href="http://bennettfeely.com/clippy/" target="_blank" rel="noopener">clippy</a> 在线帮你使用 css clip-path 做出各种形状的图形</p><p><a href="https://regex101.com/" target="_blank" rel="noopener">Regular Expressions</a> 在线正则网站</p><p><a href="https://jex.im/regulex/" target="_blank" rel="noopener">jex</a> 正则可视化网站，配合上面的 Regular Expressions，写正则方便很多</p><p><a href="https://jsfiddle.net/" target="_blank" rel="noopener">jsfiddle</a> 在线运行代码网站 很不错，可惜要翻墙</p><p><a href="https://codepan.net/" target="_blank" rel="noopener">codepan</a> 在线运行代码网站 不用翻墙，可以自己部署</p><p><a href="https://fiddle.md/" target="_blank" rel="noopener">fiddle.md</a> 一个方便的在线共享 markdown 在线笔试题一般都用这个</p><p><a href="https://www.jsdelivr.com/" target="_blank" rel="noopener">jsdelivr</a> cdn 服务</p><p><a href="https://unpkg.com" target="_blank" rel="noopener">unpkg</a> cdn 服务</p><p><a href="https://coderpad.io/" target="_blank" rel="noopener">coderpad</a> 远程面试的神器，可以让面试者远程写代码 不过需要翻墙</p><p><a href="http://www.icode.live/" target="_blank" rel="noopener">icode</a> 有赞团队出品的 coderpad 可以互补，它不需要翻墙</p><p><a href="https://snipper.io" target="_blank" rel="noopener">snipper</a> 一个代码协同的网站。你新建一个代码片段，然后把网址分享给其他人，就可以看到他们的实时编辑。</p><p><a href="https://codesandbox.io/" target="_blank" rel="noopener">codesandbox</a> 一个可以在线编辑且提供在线 demo 的网站 支持 vue react angular 多种框架 神器</p><p><a href="https://tympanus.net/codrops/" target="_blank" rel="noopener">codrops</a> 上面的交互都非常酷炫</p><p><a href="http://www.aigei.com/bgremover" target="_blank" rel="noopener">bgremover</a> 在线图片去底工具</p><p><a href="https://www.photopea.com/" target="_blank" rel="noopener">photopea</a> 一个网页端 Photoshop 很变态</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p><a href="https://uimovement.com/" target="_blank" rel="noopener">uimovement</a> 能从这个网站找到不少动画交互的灵感</p><p><a href="https://www.awwwards.com/" target="_blank" rel="noopener">awwwards</a>是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站</p><p><a href="https://dribbble.com/" target="_blank" rel="noopener">dribbble</a> 经常能在上面找到很多有创意好看的 gif 或者图片，基本上我所有的图都是上面招的</p><p><a href="https://www.behance.net/" target="_blank" rel="noopener">Bēhance</a> dribbble 是设计师的微博，Bēhance 是设计师的博客</p><p><a href="https://logojoy.com/" target="_blank" rel="noopener">Logojoy</a> 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。</p><p><a href="http://brandmark.io/" target="_blank" rel="noopener">brandmark</a> 另一个在线制作 logo 网站(这个不打水印，很良心)</p><p><a href="https://instantlogodesign.com/" target="_blank" rel="noopener">instant</a> 有一个 logo 制作网站</p><p><a href="https://coolors.co/" target="_blank" rel="noopener">coolors</a> 帮你在线配色的网站 你能找到不少配色灵感</p><p><a href="http://colorhunt.co/" target="_blank" rel="noopener">colorhunt</a> 另一个配色网站</p><p><a href="https://uigradients.com/#SummerDog" target="_blank" rel="noopener">uigradients</a> 渐变色网站</p><h2 id="有趣"><a href="#有趣" class="headerlink" title="有趣"></a>有趣</h2><p><a href="http://www.baidu-x.com/" target="_blank" rel="noopener">帮你百度一下</a> 可以 <a href="http://www.baidu-x.com/?q=%E5%92%8C%E8%B0%90%E6%9C%89%E7%88%B1%E5%AF%8C%E5%BC%BA" target="_blank" rel="noopener">点我测试一下</a></p><p><a href="http://lmgtfy.com/" target="_blank" rel="noopener">国际版</a> 同<code>帮我百度一下</code> <a href="http://lmgtfy.com/?q=a" target="_blank" rel="noopener">点我测试一下</a></p><p><a href="https://alpha.wallhaven.cc/" target="_blank" rel="noopener">wallhaven</a> 壁纸网站</p><h2 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h2><p><a href="http://aliscued.lofter.com/" target="_blank" rel="noopener">微交互</a> 里面收集了市面上很多很好的微交互例子 值得学习</p><p><a href="http://littlebigdetails.com/" target="_blank" rel="noopener">Little Big Details</a> 同上，一个国外微交互汇集网站</p><p><a href="https://cruip.com/" target="_blank" rel="noopener">cruip</a> 登录页的各种页面设计，可以免费下载模板</p><h2 id="Css"><a href="#Css" class="headerlink" title="Css"></a>Css</h2><p><a href="https://css-tricks.com/" target="_blank" rel="noopener">css-tricks</a> 一个学习 css 不错的网站 有很多有意思的 demo</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p><a href="https://egghead.io/courses/execute-npm-package-binaries-with-the-npx-package-runner" target="_blank" rel="noopener">npx</a> 教你怎么合理的使用 npx</p><h2 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h2><p><a href="http://www.pmdaniu.com/" target="_blank" rel="noopener">产品大牛</a> 什么有很多完整的产品原型可以借鉴</p><p><a href="https://modao.cc/pricing" target="_blank" rel="noopener">磨刀</a> 快速出 ui 原型</p><h2 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h2><p>一键搭建shadowsocksR 登录VPS之后，复制以下代码，在xshell里右键选择粘贴，然后回车：<br>wget -N –no-check-certificate <a href="https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssrmu.sh" target="_blank" rel="noopener">https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssrmu.sh</a> &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash ssrmu.sh</p><p>加密选5 aes-128-ctr</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Collect </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Water </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 容器在 web 开发中的运用</title>
      <link href="/2018/10/22/Docker/Docker/"/>
      <url>/2018/10/22/Docker/Docker/</url>
      
        <content type="html"><![CDATA[<p>docker 容器技术学习笔记</p><p>docker是使用go语言开发的应用容器引擎，docker 的开发商是 Docker,Inc. 可以说现在还没对手（目前找不到可以代替的软件）。从各方面来说你都应该学习docker，对于开发你可以快速构建环境，运维同样如此。</p><a id="more"></a><h1 id="Docker-笔记"><a href="#Docker-笔记" class="headerlink" title="Docker 笔记"></a>Docker 笔记</h1><p><img src="/images/docker/docker.png" alt="image"></p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><pre><code>docker ps 列出容器列表docker container ls 管理容器</code></pre><p>两个命令都是查看正在运行的容器，加 -a 参数可以查看更多的信息<br>†<br>    docker run     docker container run   都是运行容器(但是本质还是不同的，可以深入研究下)<br>    Ctrl+P+Q  退出容器不关闭</p><pre><code>docker start goofy_almeida  启动容器在后台运行docker attach goofy_almeida 后台容器进入终端docker network create &lt;name&gt;docker network inspect &lt;name&gt;docker stats 容器ID  查看容器状态docker logs 把容器运行后产生的输入都打印出来，不要轻易尝试</code></pre><h3 id="多个终端访问容器"><a href="#多个终端访问容器" class="headerlink" title="多个终端访问容器"></a>多个终端访问容器</h3><p>有时候需要开启多个终端来访问容器，通过容器ID，执行命令 <code>docker exec -it 40c330755e61 /bin/bash</code> 就可以了，这个终端的退出不会影响到已经开启的终端</p><h3 id="创建容器的参数"><a href="#创建容器的参数" class="headerlink" title="创建容器的参数"></a>创建容器的参数</h3><ul><li>-d：后台运行容器，并返回容器ID</li><li>-i：以交互模式运行容器，通常与 -t 同时使用</li><li>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用</li></ul><h2 id="容器连接"><a href="#容器连接" class="headerlink" title="容器连接"></a>容器连接</h2><p>容器连接就是把容器接到一起，让它们可以相互通信，如果你使用一个容器运行一个软件的方式，容器连接就是很有必要的，比如你的服务和数据库进行通信，那么你的容器就要连接在一起。<br>使用到的命令有 <code>--link</code> ，不过新的特性推荐使用 <code>network</code> ，network把容器都加到一个网络中，实现之间的互相通信。</p><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><ol><li>创建网络，<code>my_network</code> 是网络的名称。创建完网络，把容器加入到网络就行了。<pre><code>docker network create my_network</code></pre></li></ol><p>tip 加入网络示例：</p><p><code>docker run -it --name=web_django --network web_network --network-alias django -v /root/py_web_vadmin/:/root/web_work -p 8080:8080 debian:v2 bash</code></p><p><code>docker run -it --name=web_nginx --network web_network --network-alias nginx -v /root/py_web_vadmin/:/root/web_work -p 80:80 nginx bash</code></p><p>把debian和nginx加入到一个已创建的网络中。</p><ol start="2"><li>查看网络<pre><code>docker network ls 查看已创建的网络，默认有服务自己创建的网络</code></pre>效果如下：<pre><code>NETWORK ID      NAME    DRIVER  SCOPE9872c9881f6e    bridge  bridge  local6fc119c0ceda    host    host    localc3fdf8d5c56e    none    null    local </code></pre></li></ol><ul><li>bridge：默认网络，所有容器默认连接到它</li><li>none：没有网络接口</li><li>host：连接到主机的网络栈，主机和容器间的网络没有隔离</li></ul><pre><code>Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]  -d, --detach=false         指定容器运行于前台还是后台，默认为false   -i, --interactive=false   打开STDIN，用于控制台交互  -t, --tty=false            分配tty设备，该可以支持终端登录，默认为false  -u, --user=""              指定容器的用户  -a, --attach=[]            登录容器（必须是以docker run -d启动的容器）-w, --workdir=""           指定容器的工作目录 -c, --cpu-shares=0        设置容器CPU权重，在CPU共享场景使用  -e, --env=[]               指定环境变量，容器中可以使用该环境变量  -m, --memory=""            指定容器的内存上限  -P, --publish-all=false    指定容器暴露的端口  -p, --publish=[]           指定容器暴露的端口 -h, --hostname=""          指定容器的主机名  -v, --volume=[]            给容器挂载存储卷，挂载到容器的某个目录  --volumes-from=[]          给容器挂载其他容器上的卷，挂载到容器的某个目录--cap-add=[]               添加权限，权限清单详见：http://linux.die.net/man/7/capabilities  --cap-drop=[]              删除权限，权限清单详见：http://linux.die.net/man/7/capabilities  --cidfile=""               运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法  --cpuset=""                设置容器可以使用哪些CPU，此参数可以用来容器独占CPU  --device=[]                添加主机设备给容器，相当于设备直通  --dns=[]                   指定容器的dns服务器  --dns-search=[]            指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件  --entrypoint=""            覆盖image的入口点  --env-file=[]              指定环境变量文件，文件格式为每行一个环境变量  --expose=[]                指定容器暴露的端口，即修改镜像的暴露端口  --link=[]                  指定容器间的关联，使用其他容器的IP、env等信息  --lxc-conf=[]              指定容器的配置文件，只有在指定--exec-driver=lxc时使用  --name=""                  指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字  --net="bridge"             容器网络设置:                            bridge 使用docker daemon指定的网桥                                 host     //容器使用主机的网络                              container:NAME_or_ID  &gt;//使用其他容器的网路，共享IP和PORT等网络资源                              none 容器使用自己的网络（类似--net=bridge），但是不进行配置 --privileged=false         指定容器是否为特权容器，特权容器拥有所有的capabilities  --restart="no"             指定容器停止后的重启策略:                            no：容器退出时不重启                              on-failure：容器故障退出（返回值非零）时重启                             always：容器退出时总是重启  --rm=false                 指定容器停止后自动删除容器(不支持以docker run -d启动的容器)  --sig-proxy=true           设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理 </code></pre><h2 id="重命名镜像"><a href="#重命名镜像" class="headerlink" title="重命名镜像"></a>重命名镜像</h2><p><code>docker tag 949cb00a91e8 python-web:v1</code> 把容器id为949cb00a91e8修改成REPOSITORY为python-web，tag为v1</p><p>修改后，原来的镜像还是存在的，和修改后的镜像共用一个ID，通过 <code>docker rmi REPOSITORY:tag</code> 的方式删除</p><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>数据卷用来做数据持久化，如果你的数据在容器中，比如数据库文件，日志文件等，这些文件是会不断生成的，当你关闭容器，再次启动容器，数据倒是不会丢失，如果你从镜像启动新的容器，数据就没了（出现这种情况是因为：通常使用run命令来启动容器，如果没有定义name，那么每次使用run命令都会从镜像创建新的容器，这样上次容器的操作都没了，应该养成定义容器name的习惯，创建同名的容器是不允许的）。数据要想保持，除非你不断的提交镜像，当然这种做法是不可取的，所以要用到数据卷技术。数据可以让容器和宿主主机共享一个目录，通常把程序，数据库文件等放在宿主机上，通过创建数据卷，让容器可以操作到宿主机文件，并把新的数据写到此。</p><pre><code>docker container run -v /root/data:/root/PythonProjects/GitTest -it -p 8080:8080 debian:v2 bash</code></pre><p>上面命令的含意是：本机目录/root/data映射到容器目录/root/PythonProjects/GitTest（在启动容器的时候就得使用-v 命令，容器和主机共用一个目录，关闭容器，在启动容器也得带-v命令）<br>一般会把程序放在宿主机上，更新修改都在这，不过修改了代码后，记得进入容器中去重启项目。</p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><pre><code>从主机复制到容器 sudo docker cp host_path containerID:container_path从容器复制到主机 sudo docker cp containerID:container_path host_path</code></pre><p>操作流程：先把容器运行起来，宿主主机执行 docker container 查询正在运行的container 的containerID 然后去执行上面的命令</p><p>保存容器修改：</p><ul><li>pull 了一个新的image后，或操作已有的容器，并对容器做了修改，退出容器后</li><li>执行 docker ps -l 得到 容器的ID</li><li>执行 docker commit 容器ID 镜像名称 该操作将覆盖现有进行为修改后的容器</li><li>docker commit 容器ID 镜像名称:v2 保存修改为tag为v2的镜像</li></ul><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>容器(container)是docker一个很重要的概念，通过镜像我们就可以创建容器。这里记录一些相关命令。</p><pre class="line-numbers language-vim"><code class="language-vim">查看docker container <span class="token keyword">ls</span> 等同于 docker <span class="token keyword">ps</span>  <span class="token operator">-</span>a 查看更多的信息删除docker rm  container iddocker rmi  image id杀死所有正在运行的容器docker kill $<span class="token punctuation">(</span>docker <span class="token keyword">ps</span> <span class="token operator">-</span>a <span class="token operator">-</span><span class="token keyword">q</span><span class="token punctuation">)</span>删除所有已经停止的容器<span class="token punctuation">(</span>容器不再使用了，可以使用此命令把它们都清空了<span class="token punctuation">)</span>docker rm $<span class="token punctuation">(</span>docker <span class="token keyword">ps</span> <span class="token operator">-</span>a <span class="token operator">-</span><span class="token keyword">q</span><span class="token punctuation">)</span>删除所有未打 dangling 标签的镜像docker rmi $<span class="token punctuation">(</span>docker images <span class="token operator">-</span><span class="token keyword">q</span> <span class="token operator">-</span><span class="token keyword">f</span> dangling<span class="token operator">=</span>true<span class="token punctuation">)</span>删除所有镜像docker rmi $<span class="token punctuation">(</span>docker images <span class="token operator">-</span><span class="token keyword">q</span><span class="token punctuation">)</span>强制删除镜像名称中包含“doss<span class="token operator">-</span>api”的镜像docker rmi <span class="token operator">-</span><span class="token operator">-</span>force $<span class="token punctuation">(</span>docker images | <span class="token keyword">grep</span> doss<span class="token operator">-</span>api | awk <span class="token string">'{print $3}'</span><span class="token punctuation">)</span>删除所有未使用数据docker system prune只删除未使用的volumesdocker volume prunedocker start goofy_almeida  启动容器在后台运行docker attach goofy_almeida 后台容器进入终端<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="docker-ps-–选项"><a href="#docker-ps-–选项" class="headerlink" title="docker ps –选项"></a>docker ps –选项</h3><table><thead><tr><th>Name, shorthand</th><th align="center">Default</th><th align="center">Description</th></tr></thead><tbody><tr><td>–all , -a</td><td align="center"></td><td align="center">Show all containers (default shows just running)</td></tr><tr><td>–filter , -f</td><td align="center"></td><td align="center">Filter output based on conditions provided</td></tr><tr><td>–format</td><td align="center"></td><td align="center">Pretty-print containers using a Go template</td></tr><tr><td>–last , -n</td><td align="center">-1</td><td align="center">Show n last created containers (includes all states)</td></tr><tr><td>–latest , -l</td><td align="center"></td><td align="center">Show the latest created container (includes all states)</td></tr><tr><td>–no-trunc</td><td align="center"></td><td align="center">Don’t truncate output</td></tr><tr><td>–quiet , -q</td><td align="center"></td><td align="center">Only display numeric IDs</td></tr><tr><td>–size , -s</td><td align="center"></td><td align="center">Display total file sizes</td></tr></tbody></table><p>使用 <code>docker attach</code> 命令进入container（容器）有一个缺点，那就是每次从container中退出到前台时，container也跟着退出了。<br>要想退出container时，让container仍然在后台运行着，可以使用 <code>docker exec -it</code> 命令。每次使用这个命令进入container，当退出container后，container仍然在后台运行，命令使用方法：</p><pre class="line-numbers language-sh"><code class="language-sh">docker exec -it goofy_almeida /bin/bashgoofy_almeida：要启动的container的名称/bin/bash：在container中启动一个bash shell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样输入“exit”或者按键“Ctrl + C”退出container时，这个container仍然在后台运行。</p><blockquote><p>关于容器的运行，我本人的做法会使用 <code>screen</code> (linux的一个软件)，一般没有做后台运行。</p></blockquote><h3 id="container总结"><a href="#container总结" class="headerlink" title="container总结"></a>container总结</h3><p>run 命令后从镜像创建container(容器)，此时的容器是新的，如果修改了内容，用exit退出，这个容器被关闭了（进入了Exited状态），如果想留着修改，最好是Ctrl+P+Q  退出容器不关闭  这样docker ps  可以查看容器还在，这样就可以通过start 容器name再次进入容器了。（这里我感觉容器的状态是有用的，具体就要看文档了，因为run新容器后，通过exit命令退出了，再次run，此时ps命令应该是创建了一次，然后关闭，又创建了一次，出现过两个name, 但是第二次run的容器是新的，上次修改的拿不到。 但是修改后，exit退出，通过docker ps -l，可以看到容器id,  这里可以进行提交。所以像保持容器的修改，最好用上面的流程，等理清楚了生命周期，就比较清楚整个流程了）经测试，docker ps -l列不出的容器，通过docker ps -a找到，即使状态不是update也可以去commit。</p><blockquote><p>One of created, restarting, running, removing, paused, exited, or dead</p></blockquote><h2 id="容器导入导出"><a href="#容器导入导出" class="headerlink" title="容器导入导出"></a>容器导入导出</h2><pre><code>docker save imageID &gt; filename.tar 最好不要用 imageID，使用镜像名称加tag，这样 load 恢复的时候，容器名称会自动命名，如果使用id来save，load后容器没有名称docker load &lt; filename.tardocker export imageID &gt; filename.tardocker import &lt; filename.tar</code></pre><p>镜像和容器导出和导入的区别</p><p>镜像导入和容器导入的区别：</p><ol><li>容器导入 是将当前容器 变成一个新的镜像</li><li>镜像导入 是复制的过程</li></ol><p>save 和 export区别：</p><ol><li>save 保存镜像所有的信息-包含历史</li><li>export 只导出当前的信息，这个就是当前层，无法直接使用的（列如启动命令会消失，需要自己启动的时候加入），如果是拷贝镜像用save</li></ol><h2 id="Dockerfile-使用"><a href="#Dockerfile-使用" class="headerlink" title="Dockerfile 使用"></a>Dockerfile 使用</h2><p>除了通过拉取官方镜像的方式外，使用Dockerfile可以定制镜像，使其更加灵活。<br>整个Dockerfile文件就是执行的脚本，由特定的命令组成，一个redis镜像Dockerfile文件大概是这样的。</p><pre class="line-numbers language-vim"><code class="language-vim">FROM centos<span class="token punctuation">:</span>latestRUN yum <span class="token operator">-</span><span class="token keyword">y</span> <span class="token keyword">update</span><span class="token punctuation">;</span> yum clean <span class="token keyword">all</span>RUN yum <span class="token operator">-</span><span class="token keyword">y</span> install epel<span class="token operator">-</span>release<span class="token punctuation">;</span> yum clean <span class="token keyword">all</span>RUN yum <span class="token operator">-</span><span class="token keyword">y</span> install redis<span class="token punctuation">;</span> yum clean <span class="token keyword">all</span># 设置挂载点VOLUME <span class="token punctuation">[</span><span class="token string">"/data/redis"</span><span class="token punctuation">]</span># Define working <span class="token builtin">directory</span><span class="token operator">.</span>WORKDIR <span class="token operator">/</span>dataEXPOSE <span class="token number">6379</span>CMD <span class="token punctuation">[</span><span class="token string">"redis-server"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述Dockerfile文件是基于基础镜像CentOS来制作Redis。</p><p><code>docker build -t centos:v2 .</code> 在文件所在目录下执行构建命令</p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>Dockerfile指令就是上述文件中开头的FROM，RUN等。Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像。</p><p>FROM scratch 如果你以 scratch 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p><pre class="line-numbers language-vim"><code class="language-vim">ADDCOPYENVEXPOSEFROMLABELSTOPSIGNALUSERVOLUMEWORKDIR<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><p>这个工具是用来做容器编排的，简单来说就是可以一次启动多个容器，包括了设置端口映射，数据卷，容器连接等。在使用docker部署项目时，还是应该一个软件对应一个容器，而不是基于一个容器安装多个软件（这样就搞成一个虚拟机了），你要依次启动4，5个容器，设置端口映射，容器连接等会很麻烦，使用docker-compose只需要编写一个 <code>docker-compose.yaml</code> 文件就可以了。</p><p>使用了docker-compose，最好再配合一下Dockerfile，这样很快速就可以搭建一个环境。</p><p>以Python语言为例，流程应该是编写Dockerfile，在Dockerfile中基于一个基本容器（ubuntu，或者是Python3等容器），设置一些参数，然后安装依赖 <code>RUN pip install -r requirements.txt</code>，这样语言环境就有了，下面就是各个服务，比如MySQL，Redis等，这些不是太复杂的情况，直接在Dockerfile中指定image就行了。</p><p><code>也可以通过 -f 指定配置文件，这样就可以在其它目录来执行了</code></p><p>总结：</p><ol><li>Dockerfile 定义应用的运行环境</li><li>docker-compose.yml 定义组成应用的各服务</li><li>docker-compose up 启动整个应用</li></ol><p><a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">官方配置文件讲解</a></p><h3 id="编写yaml文件"><a href="#编写yaml文件" class="headerlink" title="编写yaml文件"></a>编写yaml文件</h3><p>这个编写很简单，就是把各个容器怎么运行，参数配置组织在一起</p><p>来看一个简单的官方例子：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">web</span><span class="token punctuation">:</span>    <span class="token key atrule">build</span><span class="token punctuation">:</span> .    <span class="token key atrule">ports</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token string">"5000:5000"</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> .<span class="token punctuation">:</span>/code    <span class="token punctuation">-</span> logvolume01<span class="token punctuation">:</span>/var/log    <span class="token key atrule">links</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> redis  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis<span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token key atrule">logvolume01</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>官方文档总结：</p><p>一份标准配置文件应该包含 version、services、networks 三大部分，其中最关键的就是 services 和 networks 两个部分，官方这里的例子使用links，而没有使用新的networks特性。configs配置在3.3及以上版本使用，用于配置文件的访问权限。</p><ul><li><p>version：用来指定版本，依照官方的例子，现在可以使用3版本了，不同版本对一些配置的支持不同，比如配置参数从字符串到对象的变化，这里不再深入了</p></li><li><p>services：就是需要运行的容器，容器通过build或image指定，build就是使用Dockerfile文件，image就是使用镜像，本地有的使用本地的，否则下载仓库的。build后面还可以加参数，例如context，args，用来设置上下文，参数等，这属于Dockerfile相关的内容，一般情况，直接在build指定当前目录就行了。ports指定端口映射，volums指定数据卷（使用数据卷，修改代码不用重启容器），在这个官方例子中，在最外层也就是顶级定义了volumes，这是为服务定义的，使用一个单机开发环境在services中定义就行了。标签有两种情况，在服务上（部署集群的时候）deploy: labels: ’标签内容‘，在容器上只需要用labels。看到deploy，它下面的配置都是和部署有关的。depends_on依赖关系，依赖的容器会先启动。command命令，类似python3 manage.py runserver 0.0.0.0:8000。pid: “host” 将PID模式设置为主机PID模式，跟主机系统共享进程命名空间。容器使用这个标签将能够访问和操纵其他容器和宿主机的名称空间。extra_hosts 添加主机名的标签，就是往/etc/hosts文件中添加一些记录，与Docker client的–add-host类似。</p></li></ul><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><table><thead><tr><th>Command</th><th align="left">Description</th></tr></thead><tbody><tr><td>build</td><td align="left">构建或重建服务，这会把Dockerfile再执行一次</td></tr><tr><td>help</td><td align="left">命令帮助</td></tr><tr><td>kill</td><td align="left">杀掉容器</td></tr><tr><td>logs</td><td align="left">显示容器的输出内容</td></tr><tr><td>port</td><td align="left">打印绑定的开放端口</td></tr><tr><td>ps</td><td align="left">显示容器</td></tr><tr><td>pull</td><td align="left">拉取服务镜像</td></tr><tr><td>restart</td><td align="left">重启服务</td></tr><tr><td>rm</td><td align="left">删除停止的容器</td></tr><tr><td>run</td><td align="left">运行一个一次性命令，run web bash</td></tr><tr><td>exec</td><td align="left">Execute a command in a running container，感觉run差不多</td></tr><tr><td>scale</td><td align="left">设置服务的容器数目</td></tr><tr><td>start</td><td align="left">开启服务</td></tr><tr><td>stop</td><td align="left">停止服务</td></tr><tr><td>up</td><td align="left">创建并启动容器</td></tr><tr><td>version</td><td align="left">查看版本，如果你是2版本的，就不要在yaml里面使用3版本的写法了</td></tr></tbody></table><p>stop start 等命令，如果不指定server，就是全部server一起操作，需要注意的是即使指定单一server，如果存在依赖也会影响。</p><p>使用总结：</p><ul><li><p>个人心得，大致浏览了一下官方文档，docker-compose最大的用处应该是集群，它提供了很多功能，不过对于单机来说仍然有它的价值，省去了很多命令，同样作为单机来用，不需要学的很深入，很多配置都是用不到的</p></li><li><p>启动容器：使用up命令来启动容器，同时也会把build配置生成镜像，在我使用的版本中，给出了警告，对于需要使用Dockerfile构建的镜像，警告说应该先使用 <code>docker-compose up --build</code>，不过这对容器的启动到是没什么影响（不知道这里官方想表达什么）。build命令只会构建镜像，并不会去启动容器，up命令启动容器后，会把容器的输出打印到终端，要想在后台运行，应该 <code>up -d</code></p></li><li><p>name：使用image的，镜像名称就是指定的，使用build，镜像名称为当前目录加上在services中的配置，在容器中的name也是当前目录加上在services中的配置。使用docker-compose需要在yaml文件目录执行，这样在services中的配置，比如一个叫做web的配置，第一次使用镜像（或用build构建）是Python，生成的容器也是 <code>当前目录_web_1</code>，修改了web配置，image变成Redis，那么上次创建的容器会被删除，创建新的容器，容器的名称是一样的，因为修改的是image，而不是web。使用container_name可以自定义容器name，不过通过ps命令可以看到系统的缺省名称是web_1，如果自定义了，那么在集群上因为名称相同导致错误</p></li><li><p>exited with code 0：我用自定义的dockerfile启动容器，结果返回这么一个信息容器就停止了，我分析了官方例子做了一些测试后发现，如果你的容器启动后，什么都不做，那就会退出了，一些情况也是会退出的，比如你用 <code>command echo $HOME</code> 终端会打印这个信息，然后退出容器，我写了一个Python循环，用logging打印信息，终端一直在打印信息，没有退出。也就是说启动容器不能什么也不做</p></li><li><p>使用command，推荐绝对路径</p></li></ul><p>:sunny: docker-compose应该这么来理解，它把多个容器组织在一起，并默认加到一个网络中（如果你没有定义网络或把容器分到不同的网络），通过run命令可以向整个环境发送命令(<code>docker-compose run dev /bin/zsh</code> 进入交互环境)，同时也可以使用docker的命令。体现了一个整体的概念。</p><h3 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h3><p>通过docker-compose来启动服务后，默认加入都同一个网络中，网络名称根据yaml文件所处文件夹来命名，通过docker network ls来查看。</p><p>由于默认已经将多个服务加入到同一个网络中了，所以它们已经是互通的了，如果你要限制容器间的访问就要配置不同的网络。</p><p><strong>links</strong></p><p>使用links可以把一个容器和另外的容器连接</p><pre><code>servers:  nginx:    links:      nginx:nginx_server  app:</code></pre><p>这样nginx就能访问app了，另外links根据官方的描述在后面的版本中将会被弃用了，另外使用links也指明了依赖关系，类似depends_on<br>写法为SERVICE:ALIAS</p><p><strong>external_links</strong></p><p>和links类似，用于链接其它docker-compose启动的服务</p><p><strong>network</strong></p><p>用来建立网络，推荐是使用方案，配合aliases一起使用。</p><p>在访问其它容器的服务，理论是需要通过 ip + 端口名称的，但是ip变换导致不能写死，所以应该通过server名称或别名的形式来访问容器。</p><pre><code>services:  web:    networks:      - new  worker:    networks:      - legacy  db:    image: mysql    networks:      new:        aliases:          - database      legacy:        aliases:          - mysqlnetworks:  new:  legacy:</code></pre><p>这里的web，db在同一个网络new，worker和db在同一个网络legacy，在web的服务中，通过database:ports就可以访问db服务，或者db:ports，分别使用了别名和服务名的方式</p><p>顶层的配置</p><pre><code>networks:  app_net:    driver: bridge</code></pre><p>声名创建的网络，和网络使用的模式，默认是桥接模式，如果使用host模式，Docker 容器的网络会附属在主机上，两者是互通的。</p><blockquote><p>在官方的配置中有expose参数，和ports的区别是，expose不会将端口暴露给主机。但是实测是在同一个网络中，不是用expose也可以正常访问。</p><p>expose只是用来标记一下，没有任何实际的效果，官方文档上说给link用其实是种误导。<br>当用link的时候，解决了每次启动容器时IP变化的问题，用link名字就可解析到对应的IP了。但是，这和端口没有任何关系，因为没有link情况下，通过IP+端口也能从一个容器访问另一个容器的服务，有link的情况下，如果不知道端口，即使expose了，别的容器也不会知道link的那些容器上expose了什么端口。</p></blockquote><p><strong>:sunny: 总结：</strong><br>网络应该是比较重要的一部分，以前在没使用docker-compose的时候，我在服务内用0.0.0.0操作，想在再重新审视一下，这不是很好的做法。</p><p>docker的容器服务所处的网络相对主机来说，就是主机分配给的一个ip，在这个ip内又组建了自己的局域网，实现容器互连，但是局域网的ip在每次重启后，都可能会重新分配，所以在程序中你不应该写死，这就要涉及到hosts文件了，通过network，别名，或links会对当前容器服务的hosts添加对应的记录，即容器ip 加名称，这样就能通过名称唯一识别容器，可以用命令来查看：</p><pre><code>╰─$ docker-compose exec redis cat /etc/hosts127.0.0.1    localhost::1    localhost ip6-localhost ip6-loopbackfe00::0    ip6-localnetff00::0    ip6-mcastprefixff02::1    ip6-allnodesff02::2    ip6-allrouters172.29.0.2    e60841108724</code></pre><p>这里的名称被编码了，在程序中，通过名称来访问其它服务即可。</p><h2 id="修改参数解决拉取镜像超时问题"><a href="#修改参数解决拉取镜像超时问题" class="headerlink" title="修改参数解决拉取镜像超时问题"></a>修改参数解决拉取镜像超时问题</h2><p>vim /etc/profile</p><p>export DOCKER_CLIENT_TIMEOUT=500<br>export COMPOSE_HTTP_TIMEOUT=500</p><p>source /etc/profile</p><p>默认是60秒，可以改长一点</p><h2 id="config文件位置"><a href="#config文件位置" class="headerlink" title="config文件位置"></a>config文件位置</h2><p>docker inspect 命令可以查看容器在启动后传递的参数，具体配置文件在这里</p><p><code>/var/lib/docker/containers/container_id/config.json</code></p><h2 id="清理Docker占用的磁盘空间"><a href="#清理Docker占用的磁盘空间" class="headerlink" title="清理Docker占用的磁盘空间"></a>清理Docker占用的磁盘空间</h2><p>df -h 查看磁盘占用</p><p>docker system df 查看docker的资源占用</p><p><code>docker system prune</code> 命令可以用于清理磁盘，删除关闭的容器、无用的数据卷和网络，以及dangling镜像(即无tag的镜像)<br><code>docker system prune -a</code> 命令清理得更加彻底，可以将没有容器使用Docker镜像都删掉</p><p>这两个命令会把你<code>暂时关闭的容器</code>，以及暂时没有用到的Docker镜像都删掉了</p><h2 id="docker启动报错：standard-init-linux-go-211-exec-user-process-caused-“no-such-file-or-directory”"><a href="#docker启动报错：standard-init-linux-go-211-exec-user-process-caused-“no-such-file-or-directory”" class="headerlink" title="docker启动报错：standard_init_linux.go:211: exec user process caused “no such file or directory”"></a>docker启动报错：standard_init_linux.go:211: exec user process caused “no such file or directory”</h2><p>出现这个错误主要是两点：</p><ol><li>使用的镜像问题，但是一般都是基于alpine镜像构建，查到的资料说换其它镜像可以解决，未测试过</li><li>Dockerfile文件模式(fileformat)问题，一般文件是unix，但是在windows上编辑的可能是doc模式。在linux上用vim打开文件，如果是doc模式可以看出来，<br>改成unix即可 vim 执行命令 <code>set ff=unix</code></li></ol><p>这也是一个比较坑的问题</p><h2 id="Alpine-Linux构建镜像"><a href="#Alpine-Linux构建镜像" class="headerlink" title="Alpine Linux构建镜像"></a>Alpine Linux构建镜像</h2><p>一般生成用Alpine Linux来构建镜像</p><p>Alpine Linux，一个只有5M的Docker镜像。是一个面向安全的轻型Linux发行版。不同于通常Linux发行版，Alpine Linux采用了musl libc和busybox以减小系统的体积和运行时资源消耗。在保持瘦身的同时，Alpine Linux还提供了自己的包管理工具apk，可以在其网站上查询，或者直接通过apk命令查询和安装</p><p>示例：</p><p>换源，然后更新，使用apk add命令安装软件，默认是sh，所以我们可以安装一个bash</p><pre class="line-numbers language-sh"><code class="language-sh"># Build with:# docker build -t alpine-bash:3.8 .FROM alpine:3.8RUN \    echo "http://mirrors.aliyun.com/alpine/v3.8/main" > /etc/apk/repositories && \    echo "http://mirrors.aliyun.com/alpine/v3.8/community" >> /etc/apk/repositories  && \    apk update upgrade && \    apk add --no-cache procps curl bash && \    ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime && \    echo "Asia/Shanghai" > /etc/timezoneCMD ["bash"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Dockerfile-配置指令补充"><a href="#Dockerfile-配置指令补充" class="headerlink" title="Dockerfile 配置指令补充"></a>Dockerfile 配置指令补充</h2><p>有一些指令还在用到了才知道，这里做一下补充</p><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p>这个是挂载指令，<code>VOLUME /tmp</code> 可以在构建镜像的时候声明一个匿名挂载目录，当我们的应用往这个目录写数据的时候，不会把数据写到容器的存储层，这样容器实例大小不会增加</p><p>run命令的时候可以指定 /tmp 的映射，这样匿名数据卷就被覆盖了，使用我们定义的映射，如果不指定，默认会挂载到docker的安装目录 <code>/var/lib/docker/volumes</code> 下</p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>ENTRYPOINT 中的参数始终会被使用，而 CMD 的额外参数可以在容器启动时动态替换掉</p><p>比如 <code>CMD echo "hello world"</code>，直接docker run，会打印hello world，但是<code>docker run -it /bin/bash</code> 那么CMD的命令被覆盖</p><p>如果是 <code>ENTRYPOINT ["/bin/echo", "hello"]</code> ，则 docker run 打印 hello, docker run Van ，打印 hello Van，参数被加上了</p><p>同时使用</p><pre class="line-numbers language-sh"><code class="language-sh">ENTRYPOINT ["/bin/echo", "hello"]  CMD ["world"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>docker run 打印 hello world，docker run van 打印 hello van</p><p>记住<code>ENTRYPOINT 中的参数始终会被使用，而 CMD 的额外参数可以在容器启动时动态替换掉</code></p><p>两种写法格式：</p><p><code>ENTRYPOINT ["executable", "param1", "param2"] (exec格式，推荐使用此格式)</code><br><code>ENTRYPOINT command param1 param2 (shell 格式)</code></p><p>要注意，如果要使用环境变量，比如<code>$HOME</code>，那么<code>ENTRYPOINT ["echo", "$HOME"]</code>是不会替换环境变量的，只能使用shell模式<br><code>ENTRYPOINT echo $HOME</code></p><h2 id="查看容器内存"><a href="#查看容器内存" class="headerlink" title="查看容器内存"></a>查看容器内存</h2><pre class="line-numbers language-sh"><code class="language-sh">docker stats $(docker ps --format={{.Names}})<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="docekr-mysql-数据库从映射文件中恢复"><a href="#docekr-mysql-数据库从映射文件中恢复" class="headerlink" title="docekr mysql 数据库从映射文件中恢复"></a>docekr mysql 数据库从映射文件中恢复</h2><p>在使用docker部署mysql后，映射出data目录，如果容器销毁后，本地目录还在，如何把数据恢复？</p><p>如果直接启动一个新的容器实例，把映射目录指向原来的目录，会导致容器无法启动，正确的操作步骤应该是这样：</p><ol><li>启动一个新容器，data目录映射到一个空的目录</li><li>容器启动成功，相关文件被初始化到data目录中</li><li>把原来的data目录中，要恢复的数据库目录找到，以及一个 ibdata1 文件。假如数据库是DevConfigDB，<br>把数据库文件夹DevConfigDB 和 ibdata1 文件复制到新容器的data目录</li><li>重启新容器，数据库就恢复了</li></ol><h2 id="docker-查询远程仓库镜像标签"><a href="#docker-查询远程仓库镜像标签" class="headerlink" title="docker 查询远程仓库镜像标签"></a>docker 查询远程仓库镜像标签</h2><p>可以通过curl 请求，官方地址加镜像加tag</p><p>比如：<a href="https://registry.hub.docker.com/v1/repositories/nginx/tags" target="_blank" rel="noopener">https://registry.hub.docker.com/v1/repositories/nginx/tags</a></p><p>把这个请求后返回的数据处理一下，就得到了一个实用的脚本工具</p><pre class="line-numbers language-sh"><code class="language-sh">#!/bin/bashAPI="https://registry.hub.docker.com/v1/repositories"DEFAULT_NAME="nginx"DEFAULT_TIMEOUT=3function Usage(){cat << HELPUsage: docker-tags NAME[:TAG]docker-tags list all tags for docker image on a remote registry.Example:    docker-tags (default nginx)    docker-tags nginx    docker-tags nginx:1.15.8    docker search nginx | docker-tags    docker search nginx | docker-tags :1.15.8    echo nginx | docker-tags    echo nginx | docker-tags :1.15.8HELP}ARG=$1if [[ "$ARG" =~ "-h" ]];then    Usage    exit 0fifunction ParseJson(){    tr -d '[\[\]" ]' | tr '}' '\n' | awk -F: -v image=$1 '{if(NR!=NF && $3 != ""){printf("%s:%s\n",image,$3)}}'}function GetTags(){    image=$1    tag=$2    ret=`curl -s ${API}/${image}/tags`    tag_list=`echo $ret | ParseJson ${image}`    if [ -z "$tag" ];then        echo -e "$tag_list"    else        echo -e "$tag_list" | grep -w "$tag"    fi}if [ -z $ARG ] || [[ ${ARG:0:1} == ":" ]];then    if [ -x /usr/bin/timeout ];then        images=`timeout $DEFAULT_TIMEOUT` awk '{print $1}' | grep -v "NAME" || echo $DEFAULT_NAME    else        images=`awk '{print $1}' | grep -v "NAME"`    fielse    images=`echo $ARG | awk -F: '{print $1}'`fitag=`echo $ARG | awk -F: '{print $2}'`for i in ${images}do    tags=`GetTags $i $tag`    count=`echo $tags | wc -w`    if [[ $count -gt 0 ]];then        echo -e "IMAGE [$i:$tag]:"        echo -e "$tags"        echo    fidone<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="修改已启动容器的端口"><a href="#修改已启动容器的端口" class="headerlink" title="修改已启动容器的端口"></a>修改已启动容器的端口</h2><p>要实现这个操作，需要先把容器停止了，然后把docker服务停止了，去修改配置文件，再重启docker服务</p><ol><li>停止docker容器，两个命令都可以</li></ol><p><code>docker stop $(docker ps -a | awk '{ print $1}' | tail -n +2)</code><br><code>docker stop</code> <code>docker ps -aq</code></p><ol start="2"><li>停止docker服务</li></ol><p>service docker stop</p><ol start="3"><li>修改config.v2.json文件</li></ol><p>docker inspect 命令找到配置文件</p><p>如果是改端口映射，改这两个文件<br>hostconfig.json </p><pre class="line-numbers language-json"><code class="language-json"><span class="token property">"PortBindings"</span><span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token property">"6379/tcp"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>          <span class="token property">"HostIp"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>          <span class="token property">"HostPort"</span><span class="token operator">:</span> <span class="token string">"6388"</span>      <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>config.v2.json </p><pre class="line-numbers language-json"><code class="language-json"><span class="token property">"Ports"</span><span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token property">"6379/tcp"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>          <span class="token property">"HostIp"</span><span class="token operator">:</span> <span class="token string">"0.0.0.0"</span><span class="token punctuation">,</span>          <span class="token property">"HostPort"</span><span class="token operator">:</span> <span class="token string">"6388"</span>      <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果是改存储映射，改这两个文件<br>hostconfig.json Binds<br>config.v2.json MountPoints</p><p>如果是改环境变量，修改<br>config.v2.json 里面找到ENV</p><p>可以格式化文件后再修改</p><ol start="4"><li>启动docker服务</li></ol><p>service docker start</p><p>启动所有的容器<br><code>sudo docker start $(docker ps -a | awk '{ print $1}' | tail -n +2)</code></p><p>总结：多测试一下，大部分都能改，记得要把容器停止了，然后停止docker服务，再去修改配置，这样才能生效</p><h2 id="修改容器启动方式"><a href="#修改容器启动方式" class="headerlink" title="修改容器启动方式"></a>修改容器启动方式</h2><p>如果机器宕机重启后，由于docker服务一般是开机启动的，所以我们可以把容器也设置成随服务启动，这样机器宕机后再次启动，容器也会跟着启动</p><p><code>docker container update --restart=always mysql-5.7-docker</code></p><p>mysql-5.7-docker为容器名称</p><pre class="line-numbers language-s"><code class="language-s">docker  run \--name nacos -d \-p 8848:8848 \--privileged=true \--restart=always \-e JVM_XMS=256m \-e JVM_XMX=256m \-e MODE=standalone \-e PREFER_HOST_MODE=hostname \-v /data/nacos/logs:/home/nacos/logs \-v /data/nacos/init.d/custom.properties:/home/nacos/init.d/custom.properties \nacos/nacos-server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm 算法学习</title>
      <link href="/2018/10/22/Algorithm/base/"/>
      <url>/2018/10/22/Algorithm/base/</url>
      
        <content type="html"><![CDATA[<p>算法相关，对于非科班出身的人来说，只能慢慢学习和体会了</p><a id="more"></a><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ul><li>有穷性(Finiteness)<br>算法的有穷性是指算法必须能在执行有限个步骤之后终止；</li><li>确切性(Definiteness)<br>算法的每一步骤必须有确切的定义；</li><li>输入项(Input)<br>一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件；</li><li>输出项(Output)<br>一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的；</li><li>可行性(Effectiveness)<br>算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步，即每个计算步都可以在有限时间内完成（也称之为有效性）。</li></ul><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><ol><li>先准备一个dict</li><li>循环数据</li><li>准备唯一键</li><li>如果唯一键没在dict中，生成新的dict2</li><li>并且 <code>dict[key] = dict2</code></li><li>如果在，<code>dict2 = dict[key]</code></li><li>然后修改dict2</li></ol><p>利用字典在原引用修改的特性，把数据进行聚合分组，每次循环都会根据唯一键从临时数据字典dict处取出要聚合到这个key对应的字典中，然后对其进行操作。</p><h2 id="找出数组中，只出现一次的两个数字"><a href="#找出数组中，只出现一次的两个数字" class="headerlink" title="找出数组中，只出现一次的两个数字"></a>找出数组中，只出现一次的两个数字</h2><p>list = [2, 4, 3, 6, 3, 2, 5, 5]</p><p>核心思路：</p><p>1、数组中全部数据异或操作后，依次对数组中的每个元素进行异或（相同位为0，不同为1）操作，得到0000 0010。</p><p>2、倒数第二位是1，说明我们要找的那两个只出现一次的数字，倒数第二位是不同的。(会出现不同，是因为这两个数不同，所以至少有一位是不同的)</p><p>3、下面根据每个数二进制倒数第二位是不是1来分成两组，倒数第二位为1的是{2, 3, 6, 3, 2}，倒数第二位为0的是{4, 5, 5}。</p><p>4、接下来对这两个数组分别进行异或操作，剩下的数字就是只出现一次的数字。</p><p>为什么分组可以实现：因为4，6是不同的两个数，它们二进制的至少某一位是不同的（记为N位），所以把这位是1的分在一起，试想所有的数在N位不同的是4或6中的一个，加上其它的数，其它的数都是成对的，所有其它的数也只会分成两组（其它的数N位同样只会是1或0），一组包含4和多个重复的数，一组包含6和多个重复的数，重复的数是可以消去的。</p><h2 id="A-B-问题"><a href="#A-B-问题" class="headerlink" title="A + B 问题"></a>A + B 问题</h2><p>给出两个整数 aa 和 bb , 求他们的和。</p><ul><li><p>样例<br>如果 a=1 并且 b=2，返回3。</p></li><li><p>挑战<br>显然你可以直接 return a + b，但是你是否可以挑战一下不这样做？（不使用++等算数运算符）</p></li><li><p>说明<br>a和b都是 32位 整数么？</p><p>  是的</p></li><li><p>我可以使用位运算符么？</p><p>  当然可以</p></li></ul><p>思路：运用位运算模拟加法</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    @param a: An integer    @param b: An integer    @return: The sum of a and b     """</span>    <span class="token keyword">def</span> <span class="token function">aplusb</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># write your code here</span>        <span class="token keyword">if</span> a <span class="token operator">==</span> <span class="token operator">-</span>b<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> b <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>                a<span class="token punctuation">,</span> b <span class="token operator">=</span> a <span class="token operator">^</span> b<span class="token punctuation">,</span> <span class="token punctuation">(</span>a <span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span>                <span class="token comment" spellcheck="true"># 每次去算进位的地方，进位的和a一直相加</span>            <span class="token keyword">return</span> a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要利用异或运算来完成 </p><ul><li>异或运算有一个别名叫做：不进位加法</li><li>那么a ^ b就是a和b相加之后，该进位的地方不进位的结果</li><li>然后下面考虑哪些地方要进位，自然是a和b里都是1的地方</li><li>a &amp; b就是a和b里都是1的那些位置，a &amp; b &lt;&lt; 1 就是进位</li><li>之后的结果。所以：a + b = (a ^ b) + (a &amp; b &lt;&lt; 1)</li><li>令a’ = a ^ b, b’ = (a &amp; b) &lt;&lt; 1</li><li>可以知道，这个过程是在模拟加法的运算过程，进位不可能</li><li>一直持续，所以b最终会变为0。因此重复做上述操作就可以</li><li>求得a + b的值。</li></ul><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>relist<span class="token punctuation">)</span><span class="token punctuation">:</span>    len_ <span class="token operator">=</span> len<span class="token punctuation">(</span>relist<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len_<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len_ <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> relist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> relist<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                relist<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> relist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> relist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> relist<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> relist<span class="token comment" spellcheck="true"># print(bubbleSort([1, 5, 2, 6, 9, 3]))</span><span class="token keyword">def</span> <span class="token function">bubbleSort2</span><span class="token punctuation">(</span>inlist<span class="token punctuation">)</span><span class="token punctuation">:</span>    len_ <span class="token operator">=</span> len<span class="token punctuation">(</span>inlist<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len_<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len_ <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> inlist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> inlist<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                inlist<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> inlist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> inlist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> inlist<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> inlist<span class="token comment" spellcheck="true"># print(bubbleSort2([1, 5, 2, 6, 9, 3]))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> len<span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> array    <span class="token keyword">else</span><span class="token punctuation">:</span>        pivot <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        less <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token keyword">if</span> i <span class="token operator">&lt;</span> pivot<span class="token punctuation">]</span>        greater <span class="token operator">=</span> <span class="token punctuation">[</span>j <span class="token keyword">for</span> j <span class="token keyword">in</span> array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token keyword">if</span> j <span class="token operator">></span> pivot<span class="token punctuation">]</span>        <span class="token keyword">return</span> quickSort<span class="token punctuation">(</span>less<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">[</span>pivot<span class="token punctuation">]</span> <span class="token operator">+</span> quickSort<span class="token punctuation">(</span>greater<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>quickSort<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 快排 分片的思想+递归的思想，这是取了第一个为基准值，栈高为O(log(n)),栈长O(n),所以运行时间为栈高x栈长，也就是算法平均运算时间为O(nlog(n))</span><span class="token keyword">def</span> <span class="token function">quickSort2</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> len<span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> array    <span class="token keyword">else</span><span class="token punctuation">:</span>        piovt <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        less <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token keyword">if</span> i<span class="token operator">&lt;</span> piovt<span class="token punctuation">]</span>        greater <span class="token operator">=</span> <span class="token punctuation">[</span>j <span class="token keyword">for</span> j <span class="token keyword">in</span> array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token keyword">if</span> j<span class="token operator">></span>piovt<span class="token punctuation">]</span>        <span class="token keyword">return</span> quickSort2<span class="token punctuation">(</span>less<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">[</span>piovt<span class="token punctuation">]</span> <span class="token operator">+</span> quickSort2<span class="token punctuation">(</span>greater<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>quickSort2<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="范围内的质数"><a href="#范围内的质数" class="headerlink" title="范围内的质数"></a>范围内的质数</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> compute<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">pass</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token keyword">return</span> res<span class="token keyword">def</span> <span class="token function">compute</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span>    flag <span class="token operator">=</span> <span class="token boolean">False</span>    <span class="token keyword">if</span> value <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token boolean">False</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> value <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        r <span class="token operator">=</span> value <span class="token operator">%</span> i        <span class="token keyword">if</span> <span class="token operator">not</span> r<span class="token punctuation">:</span>            flag <span class="token operator">=</span> <span class="token boolean">True</span>    <span class="token keyword">return</span> flag<span class="token keyword">print</span><span class="token punctuation">(</span>func<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二叉数遍历"><a href="#二叉数遍历" class="headerlink" title="二叉数遍历"></a>二叉数遍历</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">BinaryTreeNode</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token operator">=</span>None<span class="token punctuation">,</span> left<span class="token operator">=</span>None<span class="token punctuation">,</span> right<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>data <span class="token operator">=</span> data        self<span class="token punctuation">.</span>left <span class="token operator">=</span> left        self<span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token keyword">class</span> <span class="token class-name">BinaryTree</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""docstring for BinaryTree"""</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>root <span class="token operator">=</span> root    <span class="token keyword">def</span> <span class="token function">is_empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>root <span class="token operator">==</span> None    <span class="token keyword">def</span> <span class="token function">preOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> this_Node<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> this_Node <span class="token operator">==</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>this_Node<span class="token punctuation">.</span>data<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>preOrder<span class="token punctuation">(</span>this_Node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>preOrder<span class="token punctuation">(</span>this_Node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">inOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> this_Node<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> this_Node <span class="token operator">==</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span>        self<span class="token punctuation">.</span>inOrder<span class="token punctuation">(</span>this_Node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>this_Node<span class="token punctuation">.</span>data<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>inOrder<span class="token punctuation">(</span>this_Node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">postOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> this_Node<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> this_Node <span class="token operator">==</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span>        self<span class="token punctuation">.</span>postOrder<span class="token punctuation">(</span>this_Node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>postOrder<span class="token punctuation">(</span>this_Node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>this_Node<span class="token punctuation">.</span>data<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> this_Node<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> this_Node <span class="token operator">==</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span>        _queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        _queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>this_Node<span class="token punctuation">)</span>        <span class="token keyword">while</span> _queue<span class="token punctuation">:</span>            node <span class="token operator">=</span> _queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>data<span class="token punctuation">)</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left <span class="token operator">!=</span> None<span class="token punctuation">:</span>                _queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right <span class="token operator">!=</span> None<span class="token punctuation">:</span>                _queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">deep</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>data<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>deep<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>deep<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">deepTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token operator">==</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        ld <span class="token operator">=</span> self<span class="token punctuation">.</span>deepTree<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        rd <span class="token operator">=</span> self<span class="token punctuation">.</span>deepTree<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>ld<span class="token punctuation">,</span> rd<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>n1 <span class="token operator">=</span> BinaryTreeNode<span class="token punctuation">(</span>data<span class="token operator">=</span><span class="token string">"D"</span><span class="token punctuation">)</span>n2 <span class="token operator">=</span> BinaryTreeNode<span class="token punctuation">(</span>data<span class="token operator">=</span><span class="token string">"E"</span><span class="token punctuation">)</span>n3 <span class="token operator">=</span> BinaryTreeNode<span class="token punctuation">(</span>data<span class="token operator">=</span><span class="token string">"F"</span><span class="token punctuation">)</span>n4 <span class="token operator">=</span> BinaryTreeNode<span class="token punctuation">(</span>data<span class="token operator">=</span><span class="token string">"B"</span><span class="token punctuation">,</span> left<span class="token operator">=</span>n1<span class="token punctuation">,</span> right<span class="token operator">=</span>n2<span class="token punctuation">)</span>n5 <span class="token operator">=</span> BinaryTreeNode<span class="token punctuation">(</span>data<span class="token operator">=</span><span class="token string">"C"</span><span class="token punctuation">,</span> left<span class="token operator">=</span>n3<span class="token punctuation">,</span> right<span class="token operator">=</span>None<span class="token punctuation">)</span>root <span class="token operator">=</span> BinaryTreeNode<span class="token punctuation">(</span>data<span class="token operator">=</span><span class="token string">"A"</span><span class="token punctuation">,</span> left<span class="token operator">=</span>n4<span class="token punctuation">,</span> right<span class="token operator">=</span>n5<span class="token punctuation">)</span>bt <span class="token operator">=</span> BinaryTree<span class="token punctuation">(</span>root<span class="token punctuation">)</span>bt <span class="token operator">=</span> BinaryTree<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># print('先序遍历')</span><span class="token comment" spellcheck="true"># bt.preOrder(bt.root)</span><span class="token comment" spellcheck="true"># print('中序遍历')</span><span class="token comment" spellcheck="true"># bt.inOrder(bt.root)</span><span class="token comment" spellcheck="true"># print('后序遍历')</span><span class="token comment" spellcheck="true"># bt.postOrder(bt.root)</span>bt<span class="token punctuation">.</span>levelOrder<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># print bt.deepTree(bt.root)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">flb</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> None    n<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>    <span class="token keyword">while</span> n <span class="token operator">&lt;</span> num<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>        result <span class="token operator">=</span> b        a<span class="token punctuation">,</span> b <span class="token operator">=</span> b<span class="token punctuation">,</span> a <span class="token operator">+</span> b        n <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> resulta <span class="token operator">=</span> flb<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># def jump_floor(number):</span><span class="token comment" spellcheck="true">#     if number &lt;= 2:</span><span class="token comment" spellcheck="true">#         return number</span><span class="token comment" spellcheck="true">#     prev, curr = 1, 2</span><span class="token comment" spellcheck="true">#     for _ in range(3, number + 1):</span><span class="token comment" spellcheck="true">#         prev, curr = curr, prev + curr</span><span class="token comment" spellcheck="true">#         print(curr)</span><span class="token comment" spellcheck="true">#     return curr</span><span class="token comment" spellcheck="true"># print(jump_floor(5))</span><span class="token keyword">def</span> <span class="token function">jump</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> time <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> time    a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> time <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        a<span class="token punctuation">,</span> b <span class="token operator">=</span> b<span class="token punctuation">,</span> a <span class="token operator">+</span> b    <span class="token keyword">return</span> b<span class="token comment" spellcheck="true"># print(jump(6))</span><span class="token comment" spellcheck="true"># def jumpm(time):</span><span class="token comment" spellcheck="true">#     if time == 0:</span><span class="token comment" spellcheck="true">#         return 0</span><span class="token comment" spellcheck="true">#     return 2 ** (time - 1)</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># fff = lambda a: a if a &lt;= 2 else (fff(a - 1) + fff(a - 2))</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># print(fff(6))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Algorithm算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css 在 web 开发中常见操作与学习总结</title>
      <link href="/2018/10/22/HTML/css/"/>
      <url>/2018/10/22/HTML/css/</url>
      
        <content type="html"><![CDATA[<p>css总结笔记，不属于ECMAScript的知识点一般整理到此，可能包括浏览器对象模型，DOM等</p><a id="more"></a><h2 id="自动换行"><a href="#自动换行" class="headerlink" title="自动换行"></a>自动换行</h2><p>style=’word-wrap:break-word; word-break:break-all;display:block;width:100%;’</p><h2 id="不换行"><a href="#不换行" class="headerlink" title="不换行"></a>不换行</h2><p>white-space:nowrap</p><h2 id="input"><a href="#input" class="headerlink" title="input"></a>input</h2><p>style=”-webkit-appearance:checkbox”   复选相关样式</p><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><ul><li>使用 &amp;nbsp; </li><li>使用样式，输出1 &nbsp; 2 &nbsp; 3 &nbsp;</li></ul><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">white-space</span><span class="token punctuation">:</span>pre</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>1  2  3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><pre class="line-numbers language-s"><code class="language-s"><tr> - 定义表行<th> - 定义表头<td> - 定义表元(表格的具体数据)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="width"><a href="#width" class="headerlink" title="width"></a>width</h2><p>width  100%   auto</p><ol><li><p>某div不显示设置宽度，那么width为auto</p></li><li><p>某div的width在默认情况设置的是盒子模型中content的值</p></li><li><p>某div的width为100%表示的是此div盒子内容部分的宽度为其父元素的宽度</p></li><li><p>某个div的width不设置，或者设置为auto，那么表示的这个div的所有部分（内容、边框、内边距等的距离加起来）为父元素宽度</p></li></ol><h2 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h2><p>关于滚动条：overflow 决定了溢出的操作，设置溢出用滚动条，那么这个容器必须有固定高度，才有溢出的概念。</p><h2 id="scoped"><a href="#scoped" class="headerlink" title="scoped"></a>scoped</h2><p>scoped 属性是一个布尔属性。<br>如果使用该属性，则样式仅仅应用到 style 元素的父元素及其子元素。（在style type=”text/css” scoped  这里使用）</p><h2 id="css3-选择器"><a href="#css3-选择器" class="headerlink" title="css3 选择器"></a>css3 选择器</h2><ul><li>:nth-child(n)    —-&gt;选中某个元素，该元素必须是某个父元素下的第n个子元素</li><li>p:nth-child(n)   —-&gt;选中p元素，且该p元素必须是某个父元素下的第n个子元素</li></ul><p>如果n是数字，比如2，那么第2个作用样式，如果是n+2 那么从第2个开始，后面的都作用样式</p><h2 id="默认行为"><a href="#默认行为" class="headerlink" title="默认行为"></a>默认行为</h2><p>body 默认会有 margin 8px 这是浏览器决定的，不同浏览器不一样，所以初始创建一个项目，我们可以修改body 的css就可以0px 了</p><h2 id="内联和块级元素"><a href="#内联和块级元素" class="headerlink" title="内联和块级元素"></a>内联和块级元素</h2><p>块级元素特点：</p><p>1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。（真霸道，一个块级元素独占一行）</p><p>2、元素的高度、宽度、行高以及顶和底边距都可设置。</p><p>3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。</p><p>内联元素(行内元素  inline)特点：</p><p>1、和其他元素都在一行上；</p><p>2、元素的高度、宽度及顶部和底部边距不可设置；</p><p>3、元素的宽度就是它包含的文字或图片的宽度，不可改变。</p><p>内联块级inline-block 元素特点：</p><p>1、和其他元素都在一行上；</p><p>2、元素的高度、宽度、行高以及顶和底边距都可设置。</p><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p>CSS 盒子模型(Box Model)</p><p>所有HTML元素可以看作盒子，在CSS中，”box model”这一术语是用来设计和布局时使用。</p><p>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。</p><p>盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。</p><p>盒子模型居中显示，设置内联元素时 text-align:center;  这句话就可以让内联元素居中设置块状元素时定宽：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css"><span class="token selector">div</span><span class="token punctuation">{</span>    <span class="token property">border</span><span class="token punctuation">:</span><span class="token number">1</span>px solid red<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*为了显示居中效果明显为 div 设置了边框*/</span>    <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">200</span>px<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*定宽*/</span>    <span class="token property">margin</span><span class="token punctuation">:</span><span class="token number">20</span>px auto<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* margin-left 与 margin-right 设置为 auto */</span><span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定宽就是width值固定，此时设置margin左或右为自动即可，注意两个设置缺一不可。</p><p>不定宽：</p><p>加table，或者将其改为内联</p><p>在实际工作中我们会遇到需要为“不定宽度的块状元素”设置居中，比如网页上的分页导航，因为分页的数量是不确定的，所以我们不能通过设置宽度来限制它的弹性。(不定宽块状元素：块状元素的宽度width不固定。)不定宽度的块状元素有三种方法居中（这三种方法目前使用的都很多）：</p><ul><li>加入 table 标签</li><li>设置 display: inline 方法：与第一种类似，显示类型设为 行内元素，进行不定宽元素的属性设置</li><li>设置 position:relative 和 left:50%：利用 相对定位 的方式，将元素向左偏移 50% ，即达到居中的目的<br>第一种方法：<br>为什么选择方法一加入table标签? 是利用table标签的长度自适应性—即不定义其长度也不默认父元素body的长度（table其长度根据其内文本长度决定），因此可以看做一个定宽度块元素，然后再利用定宽度块状居中的margin的方法，使其水平居中。</li></ul><p>第一步：为需要设置的居中的元素外面加入一个 table 标签 ( 包括 &lt;tbody&gt;、&lt;tr&gt;、&lt;td&gt; )。</p><p>第二步：为这个 table 设置“左右 margin 居中”（这个和定宽块状元素的方法一样）。</p><p>举例如下：</p><p>html代码：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tbody</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>我是第一行文本<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>我是第二行文本<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>我是第三行文本<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tbody</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>css代码：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css"><span class="token selector">table</span><span class="token punctuation">{</span>    <span class="token property">border</span><span class="token punctuation">:</span><span class="token number">1</span>px solid<span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span><span class="token number">0</span> auto<span class="token punctuation">;</span><span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>隐形改变display类型</p><ol><li>position : absolute </li><li>float : left 或 float:right 加入这两句话中任意一句，就可以将元素变化inline-block</li></ol><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.container</span> a</span><span class="token punctuation">{</span>    <span class="token property">position</span><span class="token punctuation">:</span>absolute<span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token property">background</span><span class="token punctuation">:</span><span class="token hexcode">#ccc</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>a原来是内联的，不能改变width，加入绝对定位后变为内联块就可以了。</p><p>width   height是改变盒子的背景background,    font-size才是改变文字大小</p><h2 id="权值"><a href="#权值" class="headerlink" title="权值"></a>权值</h2><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">p</span><span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/*权值为1*/</span><span class="token selector">p span</span><span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span>green<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/*权值为1+1=2*/</span><span class="token selector"><span class="token class">.warning</span></span><span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span>white<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/*权值为10*/</span><span class="token selector">p span<span class="token class">.warning</span></span><span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span>purple<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/*权值为1+1+10=12*/</span><span class="token selector"><span class="token id">#footer</span> <span class="token class">.note</span> p</span><span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span>yellow<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/*权值为100+10+1=111*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>浏览器默认的样式 &lt; 网页制作者样式 &lt; 用户自己设置的样式</p><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>层模型有三种形式：</p><p>1、绝对定位(position: absolute)</p><p>2、相对定位(position: relative)</p><p>3、固定定位(position: fixed)</p><p>Relative与Absolute组合使用</p><p>在三种形式中，1是相对于浏览器，2是移动后原来位置有保留，3是固定盒子 <code>利用2，1可以实现相对与某一个的移动（不用相对于浏览器）</code></p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token id">#box1</span></span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token property">position</span><span class="token punctuation">:</span>relative<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token selector"><span class="token id">#box2</span></span><span class="token punctuation">{</span>    <span class="token property">position</span><span class="token punctuation">:</span>absolute<span class="token punctuation">;</span>    <span class="token property">top</span><span class="token punctuation">:</span><span class="token number">20</span>px<span class="token punctuation">;</span>    <span class="token property">left</span><span class="token punctuation">:</span><span class="token number">30</span>px<span class="token punctuation">;</span>         <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样一来，box2就是相对于box1来移动的</p><p>注意这样做的前提</p><p>参照定位的元素box1必须是相对定位元素box2的前辈元素</p><p>即：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>box1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>box2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>相对参照元素进行定位<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>关于代码编写时移动的问题</p><p>绝对定位中，比如实现div元素相对于浏览器右移100px</p><p>此时代码写为  left:100px；</p><p>注意理解绝对定位，先把我的盒子定位好，来移动浏览器，这样为了让我在浏览器的右边，浏览器应该左移，绝对定位。</p><p>另一个理解方法</p><p>有四个参数来设置   left  right  top  bottom</p><p>比如设置left=50px   可以理解为此时盒子与浏览器左边相距50px，也就是盒子右移动50px</p><p>补充：</p><ol><li>static（静态定位）：默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</li><li>relative（相对定位）：生成相对定位的元素，通过top,bottom,left,right的设置相对于其正常（原先本身）位置进行定位。可通过z-index进行层次分级。　　</li><li>absolute（绝对定位）：生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。可通过z-index进行层次分级。</li><li>fixed（固定定位）：生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。可通过z-index进行层次分级。</li></ol><p>css 相对固定位置 处理方案：</p><p>需要固定位置的时候，常使用 <code>position：fixed</code> 这种方式往往达不到理想的效果，我们经常需要的是容器在某个位置固定，这样你需要花时间去调整左右上下参数。可以让fixed定位的容器处在一个父容器内，父容器是relative定位的，这样我们固定定位的容器就不用调整位置了，以父容器为基准</p><p>举例：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rich_text_class<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">position</span><span class="token punctuation">:</span>fixed<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span> <span class="token attr-name">v-html</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>menu<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="index-z"><a href="#index-z" class="headerlink" title="index-z"></a>index-z</h2><p>z序决定了dom的层级关系，数值越大的在最上层。关于宽度，父容器的宽度受到子dom的影响，可以调整让子dom的宽度不超过父容器，在设置width属性的时候，是块的宽加上内边距，可以改属性，让这个width只有块的宽决定。理解外边距和内边距和元素自己。块级元素才是占一行。</p><h2 id="hover"><a href="#hover" class="headerlink" title=":hover"></a>:hover</h2><p><code>:hover { }</code> css选择器中对被选中对象做操作，效果为鼠标指向时代码作用。例子鼠标指向时修改文字颜色（注意不能直接在便签中加style=color  先设置颜色，class设置的颜色就会失效，应该是遵循了就近原则）</p><h2 id="超出显示文字省略"><a href="#超出显示文字省略" class="headerlink" title="超出显示文字省略"></a>超出显示文字省略</h2><p>css3 超出显示文字省略 <code>text-overflow: ellipsis; white-space: nowrap; overflow: hidden;</code></p><p>设置行数，超出行数省略</p><pre><code>overflow: hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 3;-webkit-box-orient: vertical;</code></pre><p>把该样式作用于p标签上</p><h2 id="控制锚点"><a href="#控制锚点" class="headerlink" title="控制锚点"></a>控制锚点</h2><ol><li>js控制锚点跳转<pre><code>&lt;a name="anchor"&gt;&lt;/a&gt;</code></pre></li></ol><p>location.hash=”anchor”;</p><p>不只有a其他元素也可以，比如在报表中：</p>...location.hash="tr1"<p>或者用jQuery的动画滚动效果：<br>var id=”tr1”;<br>$(‘html,body’).animate({scrollTop: $(“tr#”+id).offset().top}, 500);</p><pre><code>2. html控制锚点跳转</code></pre><p><a href="#btn">跳转到点击位置</a><br><a name="btn" id="btn">点击</a></p><pre><code>3. 跨页面锚点跳转</code></pre><p>代码如下:<br><a href="123.html#btn">跳到btn</a><br><a name="btn" id="btn"></a></p><pre><code>4. js控制锚点跳转在HTML中实现方式</code></pre><!-- 假设一个需要跳转到的节点 --><div id="divNode"><!-- contents --></div><p><a href="#" onclick="    document.getElemetnById('divNode').scrollIntoView(true);    return false;"><br>    通过scrollIntoView实现锚点效果<br></a>  </p><pre><code>## box-sizingbox-sizing属性用于更改用于计算元素宽度和高度的默认的 CSS 盒子模型。可以使用此属性来模拟不正确支持CSS盒子模型规范的浏览器的行为。简单来说就是改变盒子模型的计算方式，默认盒子模型，容器的width等于容器设置的width。如果box-sizing 设置为border-box 容器的宽度等于除外边距外的其它属性和。## cursor: pointer  `cursor: pointer` 运用了该属性，鼠标指上元素时变成“小手”## 其它给元素添加背景，做一个图标按钮，需要设置padding 扩充元素大小，不然图片没法显示## 滚动条控制与计算相关属性理解可视区域；div整体高度，包括因为滚动条看不见的部分scrollTop：可视区域滚动的时候，顶部和div整体高度的顶部之间的距离clientHeight：可视区域高度scrollHeight：div整体高度element.scrollHeight - element.scrollTop === element.clientHeight // 判断是否到底element.scrollTop = 0 // 返回顶部注意，滚动条的scrollTop等属性是设置div超过当前高度滚动时才会有的，如果设置div高度2000px，此时出现的滚动条是浏览器的机制，该属性scrollTop为0## calc 计算函数`:style="{ display: 'inline-block', width: 'calc(50% - 12px)' }"` 可以实现动态的高度，比如一个dom1要使用剩余的20%的高度，但是已经存在了一个固定高度为20px的dom2，其它元素已经使用了剩下的80%，通过计算`calc(20% - 12px)`保证dom1加上dom2有20%## event 事件事件的回调函数是有参数的，默认有这个参数event，这个参数对象包含了事件的很多属性event.preventDefault(); 取消事件的默认行为，因为有些事件它就是有默认行为的，可以用这个取消## pre 标签原样展示文本内容，前提是字体设置为等宽字体`font-family: monospace;``&lt;pre style='word-wrap: break-word;white-space: pre-wrap;'&gt;` 自动换行## a标签补充&lt;a href='javascript:void(0);'&gt; 很多时候我们这样写，让a标签不跳转，增加onclick可以去执行方法，并且保持一个超链接的样式```html&lt;a href='javascript:void(0);' onclick='deposit_volume(this)' class='deposit_volume'&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Css </tag>
            
            <tag> Html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 版本控制工具</title>
      <link href="/2018/10/22/Git/git-command/"/>
      <url>/2018/10/22/Git/git-command/</url>
      
        <content type="html"><![CDATA[<p>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。</p><a id="more"></a><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>使用GitHub，给出的地址我们一般用ssh。使用ssh需要https，如果不支持只能使用http，但是每次都要输口令。</p><h2 id="用法总结"><a href="#用法总结" class="headerlink" title="用法总结"></a>用法总结</h2><p>在idea工具盛行的时代，使用idea工具能高效快速的使用Git。如果你纯命令，那么解决冲突和合并分支都是要用类似vim的工具，其效率可想而知</p><p>推荐用idea</p><p>另外，大部分情况我们操作本地仓库就足够了，本地仓库也创建分支，打标签，然后开发到一定程度也可以合并，这些都是本地仓库操作的。真正要提交到远程仓库的，一定是开发完成的了</p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>工作区<br>暂存区<br>本地仓库<br>远程仓库</p><h2 id="标签-tag"><a href="#标签-tag" class="headerlink" title="标签 tag"></a>标签 tag</h2><p>Git的 tag 和 branch 是比较容易混淆的概念</p><p>标签分为轻量标签和附注标签，简单说就是附注标签会加上一些描述信息，轻量就没有了。然后标签是指向某个提交对象，也就是说你可以把本次提交打个标签，这样可以很方便的回到这个提交</p><p>常见用法: 选一个commit对象，把它打上标签，一个commit对象可以打多个</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>Git鼓励大量使用分支：</p><ul><li>查看分支：git branch</li><li>创建分支：git branch &lt;name&gt;</li><li>切换分支：git checkout &lt;name&gt;</li><li>创建+切换分支：git checkout -b &lt;name&gt;</li><li>合并某分支到当前分支：git merge &lt;name&gt;</li><li>删除分支：git branch -d &lt;name&gt;</li></ul><p>主要理解分支，克隆远程仓库，将本地和远程仓库关联，搭建git服务器</p><h2 id="git-pull-命令"><a href="#git-pull-命令" class="headerlink" title="git pull 命令"></a>git pull 命令</h2><p>作用：取回远程主机某个分支的更新，再与本地的指定分支合并</p><p>格式：git pull  &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</p><ol><li>如果与当前分支合并，则可省略本地分支名git pull &lt;远程主机名&gt; &lt;远程分支名&gt; 相当于：git fetch &lt;远程主机名&gt; &lt;远分支名&gt; git merge &lt;远程主机名&gt;/&lt;远程分支名&gt;</li><li>如果当前分支与远程分支存在追踪关系 git pull &lt;远程主机名&gt;</li><li>如果当前分支只有一个追踪关系 git pull</li><li>手动建立追踪关系 git branch –set-upstream master origin/next</li><li>清理远程已删除本地还存在的分支 git fetch –prune origin 或者 git fetch -p 或者 git pull -p</li></ol><h2 id="如何上传GitHub"><a href="#如何上传GitHub" class="headerlink" title="如何上传GitHub"></a>如何上传GitHub</h2><ol><li>在用户目录下 .ssh</li><li>ssh-keygen -t rsa -C “<a href="mailto:1441765847@qq.com" target="_blank" rel="noopener">1441765847@qq.com</a>“ </li><li>把 id_rsa.pub  添加到GitHub的ssh上</li><li>git init  把当前目录变为仓库</li><li>git add  把文件添加进仓库  git commit 把文件提交到仓库  </li><li>git add –all 当我们在一个不是空目录下init需要把所有文件添加到仓库的时候使用</li></ol><h2 id="文件的标记解释："><a href="#文件的标记解释：" class="headerlink" title="文件的标记解释："></a>文件的标记解释：</h2><pre class="line-numbers language-s"><code class="language-s">A: 你本地新增的文件（服务器上没有）.C: 文件的一个新拷贝.D: 你本地删除的文件（服务器上还在）.M: 文件的内容或者mode被修改了.R: 文件名被修改了。T: 文件的类型被修改了。U: 文件没有被合并(你需要完成合并才能进行提交)。X: 未知状态(很可能是遇到git的bug了，你可以向git提交bug report)。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-s"><code class="language-s">git pullgit pull origin mastergit pull origin master --allow-unrelated-histories<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="git的hook-钩子"><a href="#git的hook-钩子" class="headerlink" title="git的hook(钩子)"></a>git的hook(钩子)</h2><p>为了防止一些不规范的代码 <code>commit</code> 并 <code>push</code> 到远端，我们可以在  <code>git</code> 命令执行前用一些钩子来检测并阻止。<br>在node中，安装需要的模块：<code>husky</code>, <code>pre-commit</code> 配置package.json在提交代码前执行自定义的脚本。</p><pre class="line-numbers language-sh"><code class="language-sh">cd .git/hooksls -l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该目录提供了git的各个钩子的脚步案例。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Web </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECMAScript6 学习笔记</title>
      <link href="/2018/10/22/JavaScript/ECMAScript/"/>
      <url>/2018/10/22/JavaScript/ECMAScript/</url>
      
        <content type="html"><![CDATA[<p>ECMAScript6 是 JavaScript 的第六版本，是一个标准，主要增加了面向对象的支持和一些新特性。</p><a id="more"></a><h2 id="扩展运算符（-spread-）"><a href="#扩展运算符（-spread-）" class="headerlink" title="扩展运算符（ spread ）"></a>扩展运算符（ spread ）</h2><p>是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p><pre class="line-numbers language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 1 2 3</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 1 2 3 4 5</span><span class="token punctuation">[</span><span class="token operator">...</span>document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><pre class="line-numbers language-js"><code class="language-js">  <span class="token keyword">const</span> Person <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">'name'</span><span class="token punctuation">:</span> <span class="token string">'little bear'</span><span class="token punctuation">,</span>    <span class="token string">'age'</span><span class="token punctuation">:</span> <span class="token number">18</span><span class="token punctuation">,</span>    <span class="token string">'sayHello'</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我叫'</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>Person <span class="token operator">+</span> <span class="token string">'我今年'</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">+</span> <span class="token string">'岁!'</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  Person<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基础语法</p><ul><li>(参数1, 参数2, …, 参数N) =&gt; {函数声明}</li><li>(参数1, 参数2, …, 参数N) =&gt; 表达式（单一）</li></ul><p>相当于：(参数1, 参数2, …, 参数N) =&gt;{ return表达式}</p><ol><li>当只有一个参数时，圆括号是可选的：</li></ol><ul><li>(单一参数) =&gt; {函数声明}</li><li>单一参数 =&gt; {函数声明}</li></ul><ol start="2"><li>没有参数的函数应该写成一对圆括号。</li></ol><ul><li>() =&gt; {函数声明}</li></ul><p>在上面的代码里面，谁调用，this指向谁，所以this指向的是setInterval, 就是window（因为setInterval）是window就注入的函数。 所以在setInterval 上一行，我们可以var self = this此时的this是sayHello 由Person来调用，这样才能得到我们想要的结果。</p><p>箭头函数最大特点： 不绑定this  不绑定arguments</p><p>es6箭头函数，这个是原来定义函数的缩写。let 和原来的 var 类似，var是声明变量，它所处的位置决定了变量的作用域，比如在函数里面就是函数的作用于，在外部就是全局作用域。let也是这样，但是它的位置决定的是最接近的块的作用域，作用域比var更细，除了函数全局外，如果你用在for，if里面，那么在整个函数里面是不可见的。所以可以用let声明作用域更细的变量。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>理解继承的机制</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">DOG</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个函数我们称为构造函数，js通过对构造函数使用new 关键字创建实例（构造函数相当于Class），这样我们就从原型对象生产了一个实例对象。</p><ol><li>共有属性：</li></ol><ul><li>这样创建的实例没有共有属性，于是通过为构造函数设置prototype属性，来让从这个构造函数创建的实例都有共有属性。</li><li>这个属性包含一个对象（以下简称”prototype对象”），所有实例对象需要共享的属性和方法，都放在这个对象里面；那些不需要共享的属性和方法，就放在构造函数里面。</li></ul><p>实例对象一旦创建，将自动引用prototype对象的属性和方法。也就是说，实例对象的属性和方法，分成两种，一种是本地的，另一种是引用的。</p><p>这个prototype是大家共同引用的，修改它会影响实例。</p><ol start="2"><li>constructor：</li></ol><p>通过构造函数创建的实例，访问这个属性就可以知道实例的构造函数是谁。</p><p><code>cat1 instanceof Cat</code> 判断实例cat1是否是通过构造函数Cat来的，类似python的isinstance。</p><pre><code>6.1 isPrototypeOf()这个方法用来判断，某个proptotype对象和某个实例之间的关系。　　alert(Cat.prototype.isPrototypeOf(cat1)); //true　　alert(Cat.prototype.isPrototypeOf(cat2)); //true6.2 hasOwnProperty()每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。　　alert(cat1.hasOwnProperty("name")); // true　　alert(cat1.hasOwnProperty("type")); // false</code></pre><pre><code>prototype constructor__proto__</code></pre><ol start="3"><li>普通对象</li></ol><ul><li>最普通的对象：有<strong>proto</strong>属性（指向其原型链），没有prototype属性。</li><li>原型对象(person.prototype 原型对象还有constructor属性（指向构造函数对象）)。</li></ul><ol start="4"><li>函数对象：</li></ol><ul><li>凡是通过new Function()创建的都是函数对象。</li><li>拥有<strong>proto</strong>、prototype属性（指向原型对象）。</li><li>Function、Object、Array、Date、String、自定义函数。</li></ul><p>特例： Function.prototype(是原型对象，却是函数对象，下面会有解释)</p><ol start="4"><li>如何判断是什么对象 typeof 对象</li></ol><p>其实原型对象就是构造函数的一个实例对象。person.prototype就是person的一个实例对象。相当于在person创建的时候，自动创建了一个它的实例，并且把这个实例赋值给了prototype。</p><h2 id="早绑定和晚绑定"><a href="#早绑定和晚绑定" class="headerlink" title="早绑定和晚绑定"></a>早绑定和晚绑定</h2><p>所谓绑定（binding），即把对象的接口与对象实例结合在一起的方法。</p><p>早绑定（early binding）是指在实例化对象之前定义它的属性和方法，这样编译器或解释程序就能够提前转换机器代码。在 Java 和 Visual Basic 这样的语言中，有了早绑定，就可以在开发环境中使用 IntelliSense（即给开发者提供对象中属性和方法列表的功能）。ECMAScript 不是强类型语言，所以不支持早绑定。</p><p>另一方面，晚绑定（late binding）指的是编译器或解释程序在运行前，不知道对象的类型。使用晚绑定，无需检查对象的类型，只需检查对象是否支持属性和方法即可。ECMAScript 中的所有变量都采用晚绑定方法。这样就允许执行大量的对象操作，而无任何惩罚。</p><h2 id="文件导入"><a href="#文件导入" class="headerlink" title="文件导入"></a>文件导入</h2><p>export default 和 export 区别：</p><ol><li><p>export与export default均可用于导出常量、函数、文件、模块等</p></li><li><p>你可以在其它文件或模块中通过import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用</p></li><li><p>在一个文件或模块中，export、import可以有多个，export default仅有一个</p></li><li><p>通过export方式导出，在导入时要加{ }，export default则不需要</p></li><li><p>export</p></li></ol><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//a.js</span><span class="token keyword">export</span> <span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">"blablabla~"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span>sth<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> sth<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应的导入方式：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//b.js</span><span class="token keyword">import</span> <span class="token punctuation">{</span> str<span class="token punctuation">,</span> log <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'a'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//也可以分开写两次，导入的时候带花括号</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>export default</li></ol><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//a.js</span><span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">"blablabla~"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> str<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对应的导入方式：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//b.js</span><span class="token keyword">import</span> str <span class="token keyword">from</span> <span class="token string">'a'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//导入的时候没有花括号</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h2><p><code>Object.assign({}, row)</code> 拷贝对象</p><h2 id="import和require的区别"><a href="#import和require的区别" class="headerlink" title="import和require的区别"></a>import和require的区别</h2><p>node编程中最重要的思想就是模块化，import和require都是被模块化所使用。</p><ol><li>遵循规范</li></ol><ul><li>require 是 AMD规范引入方式</li><li>import是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法</li></ul><ol start="2"><li>调用时间</li></ol><ul><li>require是运行时调用，所以require理论上可以运用在代码的任何地方</li><li>import是编译时调用，所以必须放在文件开头</li></ul><ol start="3"><li>本质</li></ol><ul><li>require是赋值过程，其实require的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量</li><li>import是解构过程，但是目前所有的引擎都还没有实现import，我们在node中使用babel支持ES6，也仅仅是将ES6转码为ES5再执行，import语法会被转码为require</li></ul><p>引用同级文件 <code>a.js</code>，<code>b.js</code> 都在一起，应该 <code>import  ./b</code> 不要直接 <code>import b</code></p><p>1，给vue组件绑定事件时候，必须加上native ，不然不会生效（监听根元素的原生事件，使用 .native 修饰符）<br>2，等同于在自组件中：<br>   子组件内部处理click事件然后向外发送click事件：$emit(“click”.fn)</p><h2 id="Object-keys-object"><a href="#Object-keys-object" class="headerlink" title="Object.keys(object)"></a>Object.keys(object)</h2><p>Object.keys(object) 对一个对象使用，返回对象键值组成的数组，对象为{}，返回空数组[]，可以Object.keys(object).length的方式判断对象是否为空</p><h2 id="forEach-跳出迭代和终止迭代"><a href="#forEach-跳出迭代和终止迭代" class="headerlink" title="forEach 跳出迭代和终止迭代"></a>forEach 跳出迭代和终止迭代</h2><p>总的来说continue和break是for循环才有的，forEach是迭代数组，不应该有这个功能，但有时又需要<br>continue可以通过return true来实现<br>break通过try语句来实现，在需要终止的地方，通过throw new Error(“EndIterative”)手动触发异常来结束后续的循环</p><h2 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a>hasOwnProperty</h2><p>判断对象是否拥有这个属性 data.hasOwnProperty(‘name’) 在for循环一个对象中，可能需要这个检测，规范问题</p><h2 id="slice-字符串数组切片"><a href="#slice-字符串数组切片" class="headerlink" title="slice 字符串数组切片"></a>slice 字符串数组切片</h2><p>“name”.slice(0, -1) 从开始切片到倒数第一个，name变成nam，该方法数组也拥有</p><h2 id="in-语法"><a href="#in-语法" class="headerlink" title="in 语法"></a>in 语法</h2><p>和Python类似，判断属性是否在对象或原型中</p><h2 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h2><p>使用示例，async封装一个Promise对象，await等待执行结果返回，下列的searchModule方法被改造成一个Promise对象，<br>await等待一个ajax请求返回，通过then的形式拿到结果(注意这里只是一个简单情况，Promise还可以返回错误情况)</p><p>使用场景，把接口请求改成阻塞式的，虽然是异步的，但是阻塞了，等待请求结果。<br>针对需要先拿到请求结果再去做操作的情况，这部分逻辑不用写在接口里面了，可以在调用接口的时候写在then里面</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">async</span> <span class="token function">searchModule</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">await</span> <span class="token function">searchModule</span><span class="token punctuation">(</span><span class="token punctuation">{</span>keyName<span class="token punctuation">:</span> params<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> code <span class="token operator">=</span> res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>code<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>code <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>restaurants <span class="token operator">=</span> res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>data <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      that<span class="token punctuation">.</span><span class="token function">$message</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        message<span class="token punctuation">:</span> res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>msg<span class="token punctuation">,</span>        type<span class="token punctuation">:</span> <span class="token string">"warning"</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">searchModule</span><span class="token punctuation">(</span>queryString<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> restaurants <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>restaurants<span class="token punctuation">;</span>  <span class="token function">cb</span><span class="token punctuation">(</span>restaurants<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery 学习笔记</title>
      <link href="/2018/10/22/JavaScript/jQuery/"/>
      <url>/2018/10/22/JavaScript/jQuery/</url>
      
        <content type="html"><![CDATA[<p>javascript封装，快速编写前端代码，不过在MVVM框架的势头下，jQuery慢慢的不再需要了</p><a id="more"></a><h2 id="jQuery-方法"><a href="#jQuery-方法" class="headerlink" title="jQuery 方法"></a>jQuery 方法</h2><p>javascript封装，快速编写前端代码，不过在MVVM框架的势头下，jQuery慢慢的不再需要了</p><h2 id="each"><a href="#each" class="headerlink" title="each( )"></a>each( )</h2><p>如果是去迭代数组 类似 Inpute标签组成的 a:1,b:2：</p><p>使用 <code>$.each(对象，function（index,value）{   });</code> 这样可以拿到数组的键和值</p><p>如果是迭代元素 类似p标签的集合：</p><p>使用 <code>$("p").eache(function(index){  });</code> 在函数中，使用this得到当前迭代的元素  </p><h2 id="is"><a href="#is" class="headerlink" title="is()"></a>is()</h2><p>is() 根据选择器、元素或 jQuery 对象来检测匹配元素集合，如果这些元素中至少有一个元素匹配给定的参数，则返回 true。</p><h2 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h2><p>解析一个字符串，并返回一个浮点数，参数必须且是一个字符</p><p>该函数先去判断第一个字符串是否是数字，不是，函数返回 NaN，是，继续执行。如果在解析过程中遇到了正负号（+ 或 -）、数字 (0-9)、小数点，或者科学记数法中的指数（e 或 E）以外的字符，则它会忽略该字符以及之后的所有字符，返回当前已经解析到的浮点数。同时参数字符串首位的空白符会被忽略。</p><p>NaN 属性是JS的Number对象，代表非数字值的特殊值。该属性用于指示某个值不是数字。可以把 Number 对象设置为该值，来指示其不是数字值。比如月份用数字5代表5月份，var number=5; number.NaN,number现在就不是数字了。</p><ul><li>isNaN()  该一个要检测的参数（必须）看是不是NaN，是就返回True 其它值返回False。</li><li>parseInt() 函数可解析一个字符串，并返回一个整数。</li><li>indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。即索引值。</li><li>match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。</li></ul><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><p>text（）用来设置或返回值，val()返回value的值</p><p>attr() 方法设置或返回被选元素的属性值。该方法不同的参数会有不同的效果</p><p>attr(“id”,123)   选择器得到的JQuery对象的attr方法，将对象的id 改变为 “123”（没有id直接添加一个id）</p><p>appendto() append()</p><p>append() 方法在被选元素的结尾（仍然在内部）插入指定内容。<br>提示：append() 和 appendTo() 方法执行的任务相同。不同之处在于：内容的位置和选择器。<br>例子：  </p><pre><code>p标签原来的内容 &lt;p&gt;This is a paragraph.&lt;/p&gt;$("p").append(" &lt;b&gt;Hello world!&lt;/b&gt;");   执行方法后  This is a paragraph. Hello world!$("&lt;b&gt; Hello World!&lt;/b&gt;").appendTo("p");p标签原内容和执行结果同上。</code></pre><p>find（）方法 由给定表达式去匹配满足条件的后代元素，返回jquery对象。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> b<span class="token operator">=</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#id"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">'[name=id]'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>window.location.href=”url”  当前页面打开URL</p><p>当点击元素时，会发生 click 事件。</p><p>当鼠标指针停留在元素上方，然后按下并松开鼠标左键时，就会发生一次 click。</p><p>click() 方法触发 click 事件，或规定当发生 click 事件时运行的函数。</p><p>on 为元素绑定事件，比如click事件，然后加个函数，这个元素点击后就会去执行这个函数。</p><h2 id="html"><a href="#html" class="headerlink" title="html()"></a>html()</h2><p>jquery渲染页面方法，<code>$.html()</code> 对dom执行html方法，会将dom的内容给替换了，比如 <code>&lt;div class=123&gt;&lt;/div&gt;</code>  对这个dom执行方法<code>html(&lt;p&gt;123&lt;/p&gt;)</code> 结果是<code>&lt;div class=123&gt;&lt;p&gt;123&lt;/p&gt;&lt;/div&gt;</code></p><h2 id="元素切换"><a href="#元素切换" class="headerlink" title="元素切换"></a>元素切换</h2><p>sildeup sildedown，show hide 元素切换隐藏</p><h2 id="jQuery遍历"><a href="#jQuery遍历" class="headerlink" title="jQuery遍历"></a>jQuery遍历</h2><ul><li>siblings：<code>dom.siblings(.class).addClass()</code> 对选择对象执行遍历，找到所有class类，并给他们添加样式。</li></ul><h2 id="scroll"><a href="#scroll" class="headerlink" title="scroll()"></a>scroll()</h2><p>dom调用，可以在滚动条滚动的时候触发，只要有滚动就触发。这里注意如果逻辑涉及到滚动的数值判断，使用比较不要使用相等，因为滚动很快，相关的判断不一定每次执行到。</p><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><p>直接写在dom上，相当于 <code>style : dom.css('color', 'red')</code></p><p>hasClass()   addClass()   removClass()   对dom类的控制</p><h2 id="js拼接字符串，传递对象"><a href="#js拼接字符串，传递对象" class="headerlink" title="js拼接字符串，传递对象"></a>js拼接字符串，传递对象</h2><p>在JS中拼接html字符串，遇到的坑往往是由书写格式引起的。<br>注意以下几点：</p><p>单双引号需嵌套使用；<br>传入 JSON 对象需要使用 JSON.stringify() 序列化为一个 JSON 字符串，并且更需要注意单双引号嵌套问题。<br>示例：</p><pre class="line-numbers language-html"><code class="language-html">let html = "";for(var i=0;i&lt;data.length;i++){    html += '<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>'+            '<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>'+ data[i].appName +'<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>'+            '<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>'+ '&lt;button type="button" onclick="edit('+JSON.stringify(data[i]).replace(/\"/g,"'")+')">按钮1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>'+'<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>'+            '<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>'+ "<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>button<span class="token punctuation">'</span></span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>del(<span class="token punctuation">"</span>+JSON.stringify(data[i])+<span class="token punctuation">"</span>)<span class="token punctuation">'</span></span><span class="token punctuation">></span></span>按钮2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>"+'<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>'+            +'<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>'}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码中，使用了两种不同的引号嵌套格式。按钮1外层使用单引号，因此需要将JSON字符串中所有双引号转化成单引号，比较繁琐。从语法角度考虑，JavaScript 字符串与 JSON 字符串的最大区别在于，JSON 字符串必须使用双引号（单引号会导致语法错误），因此不推荐此写法。</p><p>推荐第二种写法，直接在外层嵌套双引号，无需进行额外操作</p><pre class="line-numbers language-js"><code class="language-js">htmlstr <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">"&lt;a class='opt ib upd' href="</span> <span class="token operator">+</span> <span class="token string">'javascript:void(0);'</span> <span class="token operator">+</span> <span class="token string">" onclick='updateGetData("</span> <span class="token operator">+</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>useData<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">")'>修改&lt;/a>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>element-UI 前端 Vue UI 组件</title>
      <link href="/2018/10/22/JavaScript/element-UI/"/>
      <url>/2018/10/22/JavaScript/element-UI/</url>
      
        <content type="html"><![CDATA[<p>饿了么前端团队出品的Vue UI框架</p><a id="more"></a><h2 id="from-rules"><a href="#from-rules" class="headerlink" title="from rules"></a>from rules</h2><p>from rules 是表单组件中用于在表单验证规则的属性，把rules绑定给一个对象，对象的属性即为需要做验证的字段，属性值为验证规则</p><pre class="line-numbers language-js"><code class="language-js">rules<span class="token punctuation">:</span> <span class="token punctuation">{</span>type<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> required<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> message<span class="token punctuation">:</span> <span class="token string">'type is required'</span><span class="token punctuation">,</span> trigger<span class="token punctuation">:</span> <span class="token string">'change'</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>timestamp<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> type<span class="token punctuation">:</span> <span class="token string">'date'</span><span class="token punctuation">,</span> required<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> message<span class="token punctuation">:</span> <span class="token string">'timestamp is required'</span><span class="token punctuation">,</span> trigger<span class="token punctuation">:</span> <span class="token string">'change'</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对表单的type字段做规则验证，该字段是必须的。</p><h2 id="Loading"><a href="#Loading" class="headerlink" title="Loading"></a>Loading</h2><p>关于 Loading  拥有指令调用，服务调用（在需要的地方手动触发），指令的话就是 v-loading=’true’<br>即可。可以通过修饰符把效果的遮蔽罩覆盖到DOM的body上。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> JavaScript </tag>
            
            <tag> Framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 渐进式前端框架</title>
      <link href="/2018/10/22/JavaScript/Vue/"/>
      <url>/2018/10/22/JavaScript/Vue/</url>
      
        <content type="html"><![CDATA[<p>Vue是MVVM框架，一个构建数据驱动的 web 界面的渐进式框架。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。它不仅易于上手，还便于与第三方库或既有项目整合。</p><a id="more"></a><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p><a href="https://www.jianshu.com/p/dc5057e7ad0d" target="_blank" rel="noopener">一个不错的“简书”入门</a></p><p><img src="/images/JavaScript/vue-1.png" alt="image"></p><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><ul><li><p>在通过ajax获取到数据需要赋值到data里面的时候，如果是不可变变量，可以直接赋值，但是如果是arrey，需要迭代每个值，加到data中。<code>Ajax.data.forEach(function(val, index){  vue.data.push(val) })</code>。</p></li><li><p>vue:在html中传递 this  ，在vue中this都是指向vue的组件，如果我们想使用原本的this指向这个dom,需要这样使用<code>dofunc($event)</code>。在函数里面 <code>dofunc(v){ v.target }</code>。如果转换为 jQuery 对象 <code>$(v.target)</code>  </p></li><li><p>vue:由于dom是由js去渲染的，所以你在渲染的时候去操作dom，是选不到的。这里涉及到了vue的生命周期的问题，实例创建完毕(挂载)，再去渲染dom。</p></li><li><p>vue:template不会渲染成元素，用div的话会被渲染成元素。把if,show,for等语句抽取出来放在template上面，把绑定的事件放在temlpate里面的元，可以使html结构更加清晰，还可以改善一个标签过长的情况。</p></li><li><p>注册指令：全局注册，在new vue同块写Vue.directive局部注册，当前组件使用，作为vue实例的一个属性  directives  多了个 S<br>注册组件也是如此，和指令类似</p></li><li><p>在vue实例中的选择基本都是可以在组件里面使用的（vue实例怎么写组件就怎么写），但是data必须是函数，如果是一般的对象，你在组件里面使用这个对象会报错</p></li><li><p>单页面的VUE实例只有一个，组件化开了，要想从实例拿到data，只能是组件props向下传递，记得绑定想要的数据在你的模板上。向上使用events</p></li><li><p>props  data  是驼峰命名，绑定数据的写法 <code>&lt;child :msg-a="msgA"&gt;&lt;/child&gt;  v-bind=" a "</code> 使用绑定，外部的引号不是想表达这个是个字符串，它应该当成一个变量，这也是在绑定url的时候，我们可以使用变量加上字符串，其中的字符串就用单引号。</p></li><li><p>props: 单项流数据，从父组件流向子组件，子组件试图修改它会报错，如果你要用它，应该把这个值给data，定义局部变量的方法。如果data是可变类型的，在子组件中修改了是会影响到父组件的。</p></li><li><p>props:验证，可以验证流进来的数据。验证在这个组件实例创建之前，所以你不能把这个组件里面的 option 诸如 data methods用在验证里面。</p></li><li><p>插槽：组件嵌套的时候使用，定义了如何进行内容分发</p></li><li><p>组件实例的作用域是孤立的</p></li><li><p>vue:自定义组件命名不要命名常见的（怕和框架冲突）</p></li><li><p>给vue组件绑定事件时候，必须加上native ，不然不会生效（监听根元素的原生事件，使用 .native 修饰符）。等同于在自组件中：子组件内部处理click事件然后向外发送click事件：<code>$emit("click".fn)</code></p></li></ul><h2 id="字符串模板和非字符串模板"><a href="#字符串模板和非字符串模板" class="headerlink" title="字符串模板和非字符串模板"></a>字符串模板和非字符串模板</h2><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>component1<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>x-template<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在实例中option使用 template 会把挂载元素的内容替换掉，在组件中 option 使用 template是HTML元素扩展被替换的内容，很像，都是替换。  </p><p>实例的模板字符串，执行元素的时候，此时元素应该是template标签或者 <code>script type=x-template</code> 都是把这两个的内容替换到实例挂载的元素上。</p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>vue指令类似 v-model 可以自定义指令，在创建实例的时候声明即可</p><p>目前的vue架构，对于一个vue文件来说，在里面使用其它组件（就是引用的各种组件），那么这些组件对于当前vue文件来说就是子组件，当前vue文件是父组件。这在理解一些概念的时候会有用，比如子组件 <code>双向绑定值</code> 使用 <code>sync</code> 来修饰，把子组件的某个属性绑定到父组件上，做到双向绑定。</p><table><thead><tr><th>Command</th><th align="center">Description</th></tr></thead><tbody><tr><td>v-bind</td><td align="center">动态绑定数据。简写为“:” =&gt; 以后的:class=”{red:boolean}”</td></tr><tr><td>v-on</td><td align="center">绑定时间监听器。简写为“@”，例：@click=”xxx”</td></tr><tr><td>v-text</td><td align="center">更新数据，会覆盖已有结构。类似 <code>{ {msg} }</code></td></tr><tr><td>v-show</td><td align="center">根据值的真假，切换元素的display属性</td></tr><tr><td>v-if</td><td align="center">根据值的真假，切换元素会被销毁、重建；=&gt; 在dom中已消失</td></tr><tr><td>v-else-if</td><td align="center">多条件判断，为真则渲染</td></tr><tr><td>v-else</td><td align="center">条件都不符合时渲染</td></tr><tr><td>v-for</td><td align="center">基于源数据多次渲染元素或模块</td></tr><tr><td>v-model</td><td align="center">在表单控件元素（input等）上创建双向数据绑定（数据源）</td></tr><tr><td>v-pre</td><td align="center">跳过元素和子元素的编译过程</td></tr><tr><td>v-once</td><td align="center">只渲染一次，随后数据更新也不重新渲染</td></tr><tr><td>v-cloak</td><td align="center">隐藏未编译的Mustache语法，在css中设置[v-cloak]{display:none;}</td></tr></tbody></table><h2 id="交互命令"><a href="#交互命令" class="headerlink" title="交互命令"></a>交互命令</h2><table><thead><tr><th>Command</th><th align="center">Description</th></tr></thead><tbody><tr><td>vue cli</td><td align="center">主要功能就是创建vue工程</td></tr><tr><td>vue init webpack myproject</td><td align="center">构建vue项目</td></tr></tbody></table><h2 id="ref-和-refs"><a href="#ref-和-refs" class="headerlink" title="ref 和 $refs"></a>ref 和 $refs</h2><p>ref 这个通常在元素上使用（组件自定义的元素也可以），比如现在有个组件 </p><ul><li><code>&lt;my-component&gt;&lt;/my-component&gt;</code></li><li>使用ref <code>&lt;my-component ref='new-name' attr-a='hello'&gt;&lt;/my-component&gt;</code></li><li>在 js  中 <code>this.$refs['new-name'].attr  // res hello</code> 就可以通过别名获取到元素，并且拿到元素对应的属性。</li></ul><p>补充：</p><p>利用ref属性可以获取到dom元素或者是子组件，从而可以调用子组件的方法（注意2.0版本用ref取代了el）</p><ol><li>当ref直接定义在dom元素上时，则通过this.$refs.name可以获取到dom对dom进行原生的操作</li></ol><ul><li><code>&lt;div class="foods-wrapper" ref="foods-wrapper"&gt;</code></li><li>通过 <code>this.$refs</code> 获取到dom进行操作（注意ref属性的命名不能用驼峰，同时获取的时候也是）</li><li><code>let menuList=this.$refs['menu-wrapper'].getElementsByClassName('menu-list-hook');</code> 此处如果用 <code>this.$refs["menuWrapper"]</code> 将获取不到元素</li></ul><ol start="2"><li>通过在引用的子组件上使用ref属性实现父组件调用子组件的方法以及属性</li></ol><ul><li>在父组件中引用子组件并定义ref</li><li><code>&lt;v-food  ref="selectfood"&gt;&lt;/v-food&gt;</code></li><li>调用定义在子组件中的方法show</li><li><code>this.$refs.selectfood.show();</code> 同时也可以调用子组件中的属性</li></ul><p>声明下上面说的是vue 2.0的</p><h2 id="template"><a href="#template" class="headerlink" title="template"></a>template</h2><p>template是html5的一个新元素，主要用于保存客户端中的内容，表现为浏览器解析该内容但不渲染出来，可以将一个模板视为正在被存储以供随后在文档中使用的一个内容片段。</p><h2 id="slot-插槽模板和非插槽模板"><a href="#slot-插槽模板和非插槽模板" class="headerlink" title="slot 插槽模板和非插槽模板"></a>slot 插槽模板和非插槽模板</h2><p>非插槽模板指的是html模板，比如 <code>div、span、ul、table</code> 这些，非插槽模板的显示与隐藏以及怎样显示由组件自身控制。</p><p>插槽模板是slot，它是一个空壳子，因为它的显示与隐藏以及最后用什么样的html模板显示由父组件控制。但是插槽显示的位置确由子组件自身决定，slot写在组件template的什么位置，父组件传过来的模板将来就显示在什么位置。</p><p>一般的用法就是在子组件里面：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 子组件名称：<span class="token operator">&lt;</span>children<span class="token operator">></span> <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>template<span class="token operator">></span>    <span class="token operator">&lt;</span>div<span class="token operator">></span>        <span class="token operator">&lt;</span>solt<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>solt<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 父组件是这样的 <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>template<span class="token operator">></span>    <span class="token operator">&lt;</span>children<span class="token operator">></span>        <span class="token operator">&lt;</span>span<span class="token operator">></span>被插入的内容，这整个span便签都会替换子组件中的solt<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span>    <span class="token operator">&lt;</span>children<span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就是匿名插槽或叫做具名插槽，就是 <code>&lt;span solt='name'&gt; &lt;/span&gt;</code> 在父组件上为要插入的内容取个名字，子组件<code>&lt;solt name='name'&gt;&lt;/solt&gt;</code> 这样来和父组件对应起来。</p><p>作用域插槽：这个概念比较难理解，先看怎么用:</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 父组件： <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>template<span class="token operator">></span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"father"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>h3<span class="token operator">></span>这里是父组件<span class="token operator">&lt;</span><span class="token operator">/</span>h3<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>第一次使用：用flex展示数据<span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>child<span class="token operator">></span>        <span class="token operator">&lt;</span>template slot<span class="token operator">-</span>scope<span class="token operator">=</span><span class="token string">"user"</span><span class="token operator">></span>            <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"tmpl"</span><span class="token operator">></span>            <span class="token operator">&lt;</span>span v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"item in user.data"</span><span class="token operator">></span><span class="token punctuation">{</span> <span class="token punctuation">{</span>item<span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>child<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>第二次使用：用列表展示数据<span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>child<span class="token operator">></span>        <span class="token operator">&lt;</span>template slot<span class="token operator">-</span>scope<span class="token operator">=</span><span class="token string">"user"</span><span class="token operator">></span>            <span class="token operator">&lt;</span>ul<span class="token operator">></span>            <span class="token operator">&lt;</span>li v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"item in user.data"</span><span class="token operator">></span><span class="token punctuation">{</span> <span class="token punctuation">{</span>item<span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>child<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>第三次使用：直接显示数据<span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>child<span class="token operator">></span>        <span class="token operator">&lt;</span>template slot<span class="token operator">-</span>scope<span class="token operator">=</span><span class="token string">"user"</span><span class="token operator">></span>        <span class="token punctuation">{</span> <span class="token punctuation">{</span>user<span class="token punctuation">.</span>data<span class="token punctuation">}</span> <span class="token punctuation">}</span>        <span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>child<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>第四次使用：不使用其提供的数据<span class="token punctuation">,</span> 作用域插槽退变成匿名插槽<span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>child<span class="token operator">></span>    我就是模板    <span class="token operator">&lt;</span><span class="token operator">/</span>child<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 子组件： <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>template<span class="token operator">></span>    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"child"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>h3<span class="token operator">></span>这里是子组件<span class="token operator">&lt;</span><span class="token operator">/</span>h3<span class="token operator">></span>        <span class="token comment" spellcheck="true">// 作用域插槽</span>        <span class="token operator">&lt;</span>slot <span class="token punctuation">:</span>data<span class="token operator">=</span><span class="token string">"data"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>slot<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    data<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>        data<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'zhangsan'</span><span class="token punctuation">,</span><span class="token string">'lisi'</span><span class="token punctuation">,</span><span class="token string">'wanwu'</span><span class="token punctuation">,</span><span class="token string">'zhaoliu'</span><span class="token punctuation">,</span><span class="token string">'tianqi'</span><span class="token punctuation">,</span><span class="token string">'xiaoba'</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，子组件写法是 <code>&lt;slot :data="data"&gt;&lt;/slot&gt;</code> 把数据绑定给data属性，而且数据的来源是子组件，这点就很重要了。 在父组件会这么写：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">slot-scope</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>scope<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>{ {scope.row.id} }<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>此时通过scope就可以拿到子组件绑定的data了，这个scope可以随便写。</p><p>在什么时候会用到呢？由于做研发比较少，但是用框架的时候你就要知道这种写法，通常会对子组件绑定父组件的数据，子组件拿到父组件的时候后，做了处理，得到自己的 data 就是上面插槽绑定的 data 这个时候你就可以去这个里面拿一些你像要的数据了。</p><p>像element UI 的table组件，通过给组件list数据，在 el-table-column 组件里面用作用域插槽就可以拿到赋值给list也就是表格的数据。</p><h2 id="this-nextTick"><a href="#this-nextTick" class="headerlink" title="this.$nextTick"></a>this.$nextTick</h2><p>在vue中，当页面加载完成以后，dom还没有加载，是无法获取进行操作的，但是在vue2.0中提供了一个方法 <code>this.$nextTick</code>，在这个回调函数里面写dom操作即可，如下代码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//do somthing</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实这里还有一个小技巧，就是用settimeout(fn,20),来取代this.$nextTick,（20 ms 是一个经验值，每一个 Tick 约为 17 ms），对用户体验而言都是无感知的。</p><p>现在vue都快要到3.o了，不要使用settimeout了，在使用 <code>this.$nextTick</code> 如果失败了，很可能是生命周期相关问题没处理好。</p><h2 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h2><p>当我们需要跳转一个页面的时候，既然是单页面应用，可以使用路由会很方便，比如带很多的参数过去。如果是普通的url跳转只能在url里面带参数，限制较大</p><p>比如我们的跳转由方法来处理 <code>@click="getDescribe(article.id)"</code></p><p>方法内容(三种情况)：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 情况<span class="token number">1</span><span class="token punctuation">.</span>基本使用 <span class="token operator">--</span><span class="token operator">></span><span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    path<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`/describe/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>id<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 路由配置 <span class="token operator">--</span><span class="token operator">></span><span class="token punctuation">{</span>    path<span class="token punctuation">:</span> <span class="token string">'/describe/:id'</span><span class="token punctuation">,</span>    name<span class="token punctuation">:</span> <span class="token string">'Describe'</span><span class="token punctuation">,</span>    component<span class="token punctuation">:</span> Describe<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 情况<span class="token number">2</span><span class="token punctuation">.</span>通过路由配置的name来匹配 <span class="token operator">--</span><span class="token operator">></span><span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">'Describe'</span><span class="token punctuation">,</span>    params<span class="token punctuation">:</span> <span class="token punctuation">{</span>    id<span class="token punctuation">:</span> id    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 情况<span class="token number">3</span><span class="token punctuation">.</span>通过path来匹配 <span class="token operator">--</span><span class="token operator">></span><span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    path<span class="token punctuation">:</span> <span class="token string">'/describe'</span><span class="token punctuation">,</span>    query<span class="token punctuation">:</span> <span class="token punctuation">{</span>    id<span class="token punctuation">:</span> id    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方案2要优雅的多，可以在params中传递参数，这里的id用来做路由传参了。 </p><p>在子组件中通过 <code>$route.params</code> 获取到参数。方案3为 <code>$route.query</code> 就是获取 <code>$route</code> 对象的属性了。</p><p>运用：通过方法查询接口，返回数据由路由来响应，把参数都传给子组件，子组件通过在created生命周期中 <code>this.$route</code> 获取传递给子组件的参数。</p><h2 id="v-html-与-深度作用选择器"><a href="#v-html-与-深度作用选择器" class="headerlink" title="v-html 与 深度作用选择器"></a>v-html 与 深度作用选择器</h2><p>vue 使用v-html指令渲染的页面样式处理问题</p><p>由于是动态加载的页面，在style中写的class不会作用于v-html渲染的内容，作者给出的解决方案是给外层容器加个类名, 然后用后代选择器，css的选择器可以是类选到类 <code>.classA .classB</code>， 选择元素的 <code>.classA a</code> (选择a标签)</p><p><code>.classA &gt; a</code> 只对一代a标签作用。直接这样写还不行，需要深度作用选择器 <code>.classA &gt;&gt;&gt; a</code>。 有些像 <code>Sass</code> 之类的预处理器无法正确解析 <code>&gt;&gt;&gt;</code>。这种情况下你可以使用 <code>/deep/</code> 操作符取而代之——这是一个 <code>&gt;&gt;&gt;</code> 的别名，同样可以正常工作。</p><p>总结：在使用指令的便签上加个类，用这个类选择后代（注意要用深度作用选择器）这样就可以解决问题了。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>myclass<span class="token punctuation">'</span></span> <span class="token attr-name">v-html</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>content<span class="token punctuation">'</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css">    <span class="token selector"><span class="token class">.myclass</span> /deep/ a</span><span class="token punctuation">{</span>    <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">10</span>px    <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者在被渲染的Html里面加style（没有测试过，感觉是可行的）</p><h2 id="子组件向父组件传递事件"><a href="#子组件向父组件传递事件" class="headerlink" title="子组件向父组件传递事件"></a>子组件向父组件传递事件</h2><p>子组件向父组件传递事件，通常用来实现子组件向父组件传递值，然后调用父组件的方法</p><ul><li>在子组件中对某个标签绑定点击事件 <code>v-on:click="$emit('click_event', data.guid)"</code></li><li>这样在父组件中我们可以监听这个事件，<code>&lt;article-classify v-on:click_event="classifyHandler"&gt;&lt;/article-classify&gt;</code> 方法 <code>classifyHandler</code> 会接受传递的参数，也就是 <code>data.guid</code>，这样我们就拿到子组件传递来的参数了，然后后面的逻辑也就可以去跟着执行方法</li></ul><h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><p>全局状态管理，修改store不要直接修改对象，应该通过调用mutations的方法来修改。 <code>store.commit("CHANGE_NAME")</code> 调用了CHANGE_NAME方法修改name属性</p><h3 id="mutations-和-actions"><a href="#mutations-和-actions" class="headerlink" title="mutations 和 actions"></a>mutations 和 actions</h3><p>通过 module 分割模块，每个模块都可以包含 state、mutation、action、getter 属性，以减轻store对象的臃肿程度，记住，包含这些属性的就是一个store，通过module可以把多个store组织在一起成为全局的store</p><ol><li><p>state: 就是属性存储的地方，类似组件的data</p></li><li><p>getter: 类似计算属性，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。<br>this.$store.getters.doneTodosCount 访问getter设置的属性<br>通过函数的形式 store.getters.getTodoById(2) 此时不再缓存属性，每次都计算</p></li><li><p>mutation: 用于修改属性，里面定义修改属性的方法</p></li></ol><pre class="line-numbers language-js"><code class="language-js">store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  type<span class="token punctuation">:</span> <span class="token string">'increment'</span><span class="token punctuation">,</span>  amount<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>对象风格的调用方式：</p><ul><li><p>添加新的属性：<code>state.obj = { ...state.obj, newProp: 123 }</code>，利用对象展开运算符加上新对象，组织成一个全新的对象重新赋值<br>使用this.$store.commit()提交即可</p></li><li><p>actions: store.dispatch(‘increment’) 的方式触发</p></li></ul><pre><code>默认情况下,模块内的getter, mutation, action是注册在全局空间的, state只注册在局部命名空间的要想使模块内的getter,mutation,action注册在模块命名空间,必须在模块内加上 namespaced: true, 比如访问 store.getters['publish/useComponent']</code></pre><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p>mapState 计算属性中使用，就是需要获取store的属性并映射到计算属性的时候可以用它简化代码</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">userNameTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>user<span class="token punctuation">.</span>name    <span class="token punctuation">}</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通常你的计算属性需要通过this才能访问store，如果使用辅助函数<br><code>userName: state =&gt; state.user.name,</code><br>如果是同名的直接写字符串<br><code>'login'</code><br>总之就是少些一点代码</p><p>mapGetters 和上面的 mapState类似了 通过字符的形式就行了，或者通过对象的形式重命名<br>mapMutations 是 mutation 相关的辅助函数，可以在组件的methods中使用，把mutation映射成方法</p><h3 id="和表单相关"><a href="#和表单相关" class="headerlink" title="和表单相关"></a>和表单相关</h3><p>由于修改属性需要提交，你不能直接使用v-model来绑定store的属性了，一个比较精简的用法</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>input v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">"message"</span><span class="token operator">></span>computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>  message<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token keyword">get</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>obj<span class="token punctuation">.</span>message    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token keyword">set</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'updateMessage'</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="报错处理"><a href="#报错处理" class="headerlink" title="报错处理"></a>报错处理</h2><p>运行vue项目的时候，出现了[Vue warn]: Duplicate keys detected: ‘0’. This may cause an update error（错误，检测到重复的key值：”0“，这可能会导致更新错误）</p><p>错误原因：<br>我们在使用v-for的时候，都要必须加上一个唯一的key值，但是这里写了两个for循环，尽管都加上了key值,然而又将key的值写成一样的了。所以就导致了警告。</p><p>解决办法：<br>可以将其中一个的key修改一下即可。不行就两个都修改。</p><p>出错的地方：<br>写了两个一样的for循环，绑定的key相同。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>info<span class="token punctuation">"</span></span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(item, index) in itemList<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>index<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>info<span class="token punctuation">"</span></span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(item, index) in itemList<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>index<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="数组对象做绑定，关于响应式原理"><a href="#数组对象做绑定，关于响应式原理" class="headerlink" title="数组对象做绑定，关于响应式原理"></a>数组对象做绑定，关于响应式原理</h2><p><code>https://cn.vuejs.org/v2/guide/reactivity.html</code> 官方参考</p><p>场景问题，通过后端来的数据需要迭代，迭代出来的数据无法进行双向绑定</p><p>原因: <code>受现代 JavaScript 的限制 (而且 Object.observe 也已经被废弃)，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的</code></p><p>这句话的意思是，假如数组一开始就有了，那么初始化的时候就会对各个属性进行响应式转换，使得我们在对迭代出来的数据进行v-model的时候可以生效，但是当数据是在初始化后加载来的，就不行了。</p><p><code>解决方法</code>: 对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式属性，也就是新属性都通过Vue.set的方式添加，或<code>this.$set(el, 'isFold', false)</code></p><p>假如通过el.isFold = false的方法加入的属性，是没有响应式支持的</p><ul><li>多属性添加(没有测试过，详情看官网): </li></ul><p>有时你可能需要为已有对象赋值多个新属性，比如使用 Object.assign() 或 _.extend()。但是，这样添加到对象上的新属性不会触发更新。在这种情况下，你应该用原对象与要混合进去的对象的属性一起创建一个新的对象。</p><ul><li>疑问</li></ul><p>另外，还留有一点疑惑的地方，如果后端直接返回的数组，好像是可以响应式的，但是对这个数组添加的属性却不行</p><p>问题解决了，就是赋值给vue对象后，再添加属性不在具有响应式，需要用$set方法来添加，或者先添加完，再赋值</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// DataList为vue实例数据，data为借口返回数据</span><span class="token comment" spellcheck="true">// 情况1，可以有响应式，通过this.$set赋值</span>that<span class="token punctuation">.</span>DataList <span class="token operator">=</span> data<span class="token punctuation">;</span>that<span class="token punctuation">.</span>DataList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>el <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>$<span class="token keyword">set</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> <span class="token string">'isFold'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>$<span class="token keyword">set</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> <span class="token string">'checked'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 情况2，可以有响应式，因为data被修改后才赋值给vue属性DataList</span>data<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>el <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    el<span class="token punctuation">.</span>isFold <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    el<span class="token punctuation">.</span>checked <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>that<span class="token punctuation">.</span>DataList <span class="token operator">=</span> data<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 情况3，新增的属性不具有响应式，因为data先赋值给vue属性DataList，然后再去添加属性</span>that<span class="token punctuation">.</span>DataList <span class="token operator">=</span> data<span class="token punctuation">;</span>that<span class="token punctuation">.</span>DataList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>el <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    el<span class="token punctuation">.</span>isFold <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    el<span class="token punctuation">.</span>checked <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="virtual-Scroller"><a href="#virtual-Scroller" class="headerlink" title="virtual Scroller"></a>virtual Scroller</h2><p>众所周知，渲染性能主要取决于渲染量， 过多的 DOM 会使你的网站速度变得很慢，即使在本地，也会出现相同的问题，但若通过虚拟滚动的方式，也就是在用户滚动时用足够的内容填充屏幕并不断更新，就能让网站保持高速运行，这也是 virtual-scroller 的基本原理。</p><h2 id="缓存组件"><a href="#缓存组件" class="headerlink" title="缓存组件"></a>缓存组件</h2><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>keep-alive</span> <span class="token attr-name">include</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>list<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>keep-alive</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>另外路由有生命周期，可以在进入路由，跳去下一个路由的时候做处理，比如改变路由meta数据，然后关联keep-alive实现动态缓存组件</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> JavaScript </tag>
            
            <tag> Framework </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js 服务端的JavaScript</title>
      <link href="/2018/10/22/JavaScript/node/"/>
      <url>/2018/10/22/JavaScript/node/</url>
      
        <content type="html"><![CDATA[<p>服务端的javascript，Nodejs是一个Javascript运行环境(runtime environment)，让js可以运行在服务端</p><a id="more"></a><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>webpack把多种静态资源转换成一个静态文件</p><h3 id="的含义"><a href="#的含义" class="headerlink" title="@ 的含义"></a>@ 的含义</h3><p>在webpack的配置中</p><pre class="line-numbers language-js"><code class="language-js">resolve<span class="token punctuation">:</span> <span class="token punctuation">{</span>  extensions<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'.js'</span><span class="token punctuation">,</span> <span class="token string">'.vue'</span><span class="token punctuation">,</span> <span class="token string">'.json'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  alias<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">'@'</span><span class="token punctuation">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'src'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样在需要导入组件的时候使用 <code>import A from '@/components/a.vue'</code> 就是给复杂了引用路径做个别名。</p><h3 id="修改编译路径"><a href="#修改编译路径" class="headerlink" title="修改编译路径"></a>修改编译路径</h3><p>编译路径修改（由于存在编译出来的文件相互依赖的，而你只导入其中几个，依赖就出问题了，为了不修改后端代码，修改通用编译路径是不错的解决方案）</p><pre class="line-numbers language-js"><code class="language-js">assetsRoot<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'../static/dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>assetsSubDirectory<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>assetsPublicPath<span class="token punctuation">:</span> <span class="token string">'/static/dist/'</span><span class="token punctuation">,</span>productionSourceMap<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p>一个转码器，将es6转es5，这个东西何用？node.js直接执行es6代码还存在问题，听说最新版本可以了。所以用es6来写js，这样可以利用它的新特性，然后转码，这样node.js就可以运行了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> JavaScript </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nvm 环境管理工具</title>
      <link href="/2018/10/22/JavaScript/nvm/"/>
      <url>/2018/10/22/JavaScript/nvm/</url>
      
        <content type="html"><![CDATA[<p>nvm 是 node的环境管理工具，可以同时安装多个node版本，具体实现是通过修改环境变量切换到对应的node上，不同的node版本拥有独立的包文件。</p><a id="more"></a><h1 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h1><p>nvm 是 node的环境管理工具，可以同时安装多个node版本，具体实现是通过修改环境变量切换到对应的node上，不同的node版本拥有独立的包文件。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Mac 下安装使用github提供的脚本安装，安装完成添加对应shell的配置</p><p>nvm 使用brew安装会有一些小问题 <a href="https://www.imooc.com/article/14617" target="_blank" rel="noopener">正确的安装和使用nvm(mac)</a></p><pre class="line-numbers language-sh"><code class="language-sh">export NVM_DIR="$HOME/.nvm"[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"# This loads nvm bash_completion<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>github 地址 <a href="https://github.com/creationix/nvm/blob/master/README.md" target="_blank" rel="noopener">https://github.com/creationix/nvm/blob/master/README.md</a></p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><table><thead><tr><th>Command</th><th align="center">Description</th></tr></thead><tbody><tr><td>nvm install stable</td><td align="center">安装最新稳定版</td></tr><tr><td>nvm install &lt;version&gt;</td><td align="center">安装指定版本，可模糊安。如：安装v4.4.0，既可nvm install v4.4.0，又可nvm install 4.4</td></tr><tr><td>nvm uninstall &lt;version&gt;</td><td align="center">删除已安装的指定版本，语法与install类似</td></tr><tr><td>nvm ls</td><td align="center">列出所有安装的版本</td></tr><tr><td>nvm ls-remote</td><td align="center">列出所有远程服务器的版本（官方node version list）</td></tr><tr><td>nvm current</td><td align="center">显示当前的版本</td></tr><tr><td>nvm alias &lt;name&gt; &lt;version&gt;</td><td align="center">给不同的版本号添加别名</td></tr><tr><td>nvm unalias &lt;name&gt;</td><td align="center">删除已定义的别名</td></tr><tr><td>nvm reinstall-packages &lt;version&gt;</td><td align="center">在当前版本 node 环境下，重新全局安装指定版本号的 npm 包</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 学习笔记</title>
      <link href="/2018/10/22/JavaScript/javascript/"/>
      <url>/2018/10/22/JavaScript/javascript/</url>
      
        <content type="html"><![CDATA[<p>javascript学习笔记</p><a id="more"></a><h2 id="DOM对象"><a href="#DOM对象" class="headerlink" title="DOM对象"></a>DOM对象</h2><p>DOM对象，即是我们用传统的方法(javascript)获得的对象，jQuery对象即是用jQuery类库的选择器获得的对象;<br>复制代码 代码如下:</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> domObj <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//DOM对象</span><span class="token keyword">var</span> $obj <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//jQuery对象;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>jQuery对象就是通过jQuery包装DOM对象后产生的对象，它是jQuery独有的。如果一个对象是jQuery对象，那么就可以使用jQuery里的方法，例:</p><p>$(“#foo”).html(); //获取id为foo的元素内的html代码，html()是jQuery特有的方法;</p><p>上面的那段代码等同于:</p><p>document.getElementById(“foo”).innerHTML;<br>$(“#foo”).innerHTML  是错误的</p><p>可以将jquery 和 dom  对象互相转换，这样dom对象就可以使用jquery的方法了，jquery对象亦如此。</p><h2 id="Json-方法"><a href="#Json-方法" class="headerlink" title="Json 方法"></a>Json 方法</h2><p>JSON.stringify(a) stringify()用于从一个对象解析出字符串</p><p>JSON.parse(str)  parse用于从一个字符串中解析出json对象</p><h2 id="取得url中get请求的参数"><a href="#取得url中get请求的参数" class="headerlink" title="取得url中get请求的参数"></a>取得url中get请求的参数</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">getUrlParam</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">"(^|&amp;)"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"=([^&amp;]*)(&amp;|$)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> r <span class="token operator">=</span> window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>search<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">decodeURI</span><span class="token punctuation">(</span>r<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ready-和-onload事件"><a href="#ready-和-onload事件" class="headerlink" title="ready 和 onload事件"></a>ready 和 onload事件</h2><p>页面加载完成有两种事件，一是ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件），二是onload，指示页 面包含图片等文件在内的所有元素都加载完成。(可以说：ready 在onload 前加载！！！) 一般样式控制的，比如图片大小控制放在onload 里面加载。 </p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>JavaScript 关键字必须以字母、下划线（_）或美元符（$）开始。</p><p>后续的字符可以是字母、数字、下划线或美元符（数字是不允许作为首字符出现的，以便 JavaScript 可以轻易区分开关键字和数字）。</p><p><img src="/images/JavaScript/keyword.png" alt="image"></p><h2 id="BOM-amp-DOM"><a href="#BOM-amp-DOM" class="headerlink" title="BOM &amp; DOM"></a>BOM &amp; DOM</h2><ul><li>BOM是浏览器对象模型，用来获取或设置浏览器的属性、行为，例如：新建窗口、获取屏幕分辨率、浏览器版本号等。</li><li>DOM是文档对象模型，用来获取或设置文档中标签的属性，例如获取或者设置input表单的value值。</li><li>BOM的内容不多，主要还是DOM。</li></ul><h2 id="字面量，变量"><a href="#字面量，变量" class="headerlink" title="字面量，变量"></a>字面量，变量</h2><p>有时候会遇到字面量的概念，它和变量对应，字面量就是固定值的表示法。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>js也有异常，不过很少见人使用。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>菜鸟教程(runoob.com)<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    <span class="token keyword">function</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//错误判断</span>        <span class="token keyword">var</span> x <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"demo"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token string">"值为空"</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token string">"不是数字"</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">></span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token string">"太大"</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token string">"太小"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//发生错误时在此执行，err为自定义错误 throw 对应的值，</span>        <span class="token keyword">var</span> y <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"mess"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        y<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">"错误："</span> <span class="token operator">+</span> err <span class="token operator">+</span> <span class="token string">"。"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>我的第一个 JavaScript<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>请输出一个 5 到 10 之间的数字:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>demo<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>myFunction()<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>测试输入<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mess<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数的定义方式大体有以下两种，浏览器对于不同的方式有不同的解析顺序。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//“定义式”函数定义</span><span class="token keyword">function</span> <span class="token function">Fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//“赋值式”函数定义</span><span class="token keyword">var</span> Fn2 <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Hello wild!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="快速测试一段代码的执行时间"><a href="#快速测试一段代码的执行时间" class="headerlink" title="快速测试一段代码的执行时间"></a>快速测试一段代码的执行时间</h2><pre class="line-numbers language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">/* 这里运行待测代码 */</span>console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="对象总结"><a href="#对象总结" class="headerlink" title="对象总结"></a>对象总结</h2><p>对象</p><ol><li>javascript 对象</li></ol><pre><code>JS Array     JS Boolean   JS Date  JS Number    JS String    JS RegExp JS Functions JS Events    JS Math</code></pre><p>其它对象</p><pre><code>Browser  Window  Navigator Screen   History Location</code></pre><p>Window 对象表示一个浏览器窗口或一个框架。在客户端 JavaScript 中，Window 对象是全局对象，所有的表达式都在当前的环境中计算。也就是说，要引用当前窗口根本不需要特殊的语法，可以把那个窗口的属性作为全局变量来使用。</p><ol start="2"><li>HTML DOM 对象</li></ol><ul><li>每个载入浏览器的 HTML 文档都会成为 Document 对象。</li><li>Document 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问。</li></ul><p>Element 节点，文本节点，元素节点等。</p><p>Attribute 属性； Event 事件； HTML 对象；</p><p>标签即是HTML对象，标签和元素的区别，属性的定义：</p><pre><code>比如&lt;p&gt;这就是一个标签； &lt;p&gt;这里是内容&lt;/p&gt;这就是一个元素，也就是说元素由一个开始的标签和结束的标签组成，用来包含某些内容。</code></pre><p>属性：</p><p>为HTML元素提供各种附加信息的就是HTML属性，它总是以”属性名=属性值”这种名值对的形式出现，而且属性总是在HTML元素的开始标签中进行定义。</p><p>节点的作用：</p><p>在有了标签，元素，属性后，引申出节点的概念，标签的元素中可能会有更多的元素，将多个或一个元素看作节点，节点就是为了去操作元素的。</p><h2 id="virtual-DOM"><a href="#virtual-DOM" class="headerlink" title="virtual DOM"></a>virtual DOM</h2><p>一些理解：</p><p>虚拟DOM，是一个模拟DOM数的js对象。 就是当我们需要更改DOM的时候，如果用原始方法比较慢，这在多节点的页面中体现就更明显了，原因是dom设计的复杂，所以我们用一个虚拟的DOM，虚拟的DOM记录了要更改的DOM，它通常不是立刻执行的，等到需要的时候，计算最小的执行，把执行更新到DOM上。这里为什么会有最小的DOM执行，是应为不是所有的地方都需要变更。</p><p>总结：virtual DOM 通过计算最小的DOM执行，能更快的渲染DOM。</p><p>别人的讲解：</p><ul><li>Virtual DOM 是一个模拟 DOM 树的 JavaScript 对象。 React 使用 Virtual DOM 来渲染 UI，当组件状态 state 有更改的时候，React 会自动调用组件的 render 方法重新渲染整个组件的 UI。</li><li>React 主要的目标是提供一套不同的, 高效的方案来更新 DOM.不是通过直接把 DOM 变成可变的数据, 而是通过构建 “Virtual DOM”, 虚拟的 DOM, 随后 React 处- 理真实的 DOM 上的更新来进行模拟相应的更新。</li></ul><p>引入额外的一个层怎么就更快了呢?</p><ul><li>那不是意味着浏览器的 DOM 操作不是最优的, 如果在上边加上一层能让整体变快的话?是有这个意思, 只不过 virtual DOM 在语义上和真实的 DOM 有所差别.最主要的是, virtual DOM 的操作, 不保证马上就会产生真实的效果.这样就使得 React 能够等到事件循环的结尾, 而在之前完全不用操作真实的 DOM。在这基础上, React 计算出几乎最小的 diff, 以最小的步骤将 diff 作用到真实的 DOM 上。批量处理 DOM 操作和作用最少的 diff 是应用自身都能做到的.任何应用做了这个, 都能变得跟 React 一样地高效。但人工处理出来非常繁琐, 而且容易出错. React 可以替你做到。</li><li>前面提到 virtual DOM 和真实的 DOM 有着不用的语义, 但同时也有明显不同的 API。</li><li>DOM 树上的节点被称为元素, 而 virtual DOM 是完全不同的抽象, 叫做 components。</li><li>component 的使用在 React 里极为重要, 因为 components 的存在让计算 DOM diff 更高效。</li></ul><p>简单的说就是：</p><p>当然如果真的这样大面积的操作 DOM，性能会是一个很大的问题，所以 React 实现了一个虚拟 DOM，组件 DOM 结构就是映射到这个虚拟 DOM 上，React 在这个虚拟 DOM 上实现了一个 diff 算法，当要更新组件的时候，会通过 diff 寻找到要变更的 DOM 节点，再把这个修改更新到浏览器实际的 DOM 节点上，所以实际上不是真的渲染整个 DOM 树。这个虚拟 DOM 是一个纯粹的 JS 数据结构，所以性能会比原生 DOM 快很多。</p><p>React的核心机制之一就是可以在内存中创建虚拟的DOM元素。React利用虚拟DOM来减少对实际DOM的操作从而提升性能。 </p><h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h2><p>数组过滤。indexOf作用是返回字符串第一次出现在给定字符串的index，可以用来处理某个字符串有没有在给定字符串中。  给定 <code>str.indexOf(某个字符串) = 0</code> 说明第一个就匹配到，这个给定字符串。如果是空格分隔的，如几个单词，那么结果就不一定是0了，因为会在后面的位置。记住是给定来调用这个方法就行了</p><p>补充：</p><p>js array indexOf 参数是对象的时候，不一定能返回对应位置的index(有的时候可以，我查了资料，有人是这么说的：让数组去判断<code>一个新创建的对象</code>，所以会得到 -1。我在vue中，把循环出来的元素做为参数去在原数组中判断，是可以的，不是循环出来的对象，虽然对象和数组元素字面看起来一摸一样，但是不行，猜测这和底层有关) 所以这个东西的使用，要很小心<br>推荐使用 <code>Array.findIndex()</code></p><p>findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> array1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">130</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">findFirstLargeNumber</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> element <span class="token operator">></span> <span class="token number">13</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>array1<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span>findFirstLargeNumber<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// expected output: 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> array1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">130</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> found <span class="token operator">=</span> array1<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> element <span class="token operator">></span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>found<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// expected output: 12</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过find，findIndex可以完成很多的事情，少用通过各种方法获取索引，然后再去 <code>array[index]</code>。find就可以了</p><p>更详细的使用查看文档。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/find" target="_blank" rel="noopener">文档地址</a></p><p>我发现这个从列表中给出来的数据，你不段的引用，其中一个引用改了，也会影响到原数组。</p><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token template-string"><span class="token string">`a</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">var</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果var是1，result 为 a1。注意两边的符号为tab键上面的</p><h2 id="bject-keys-obj"><a href="#bject-keys-obj" class="headerlink" title="bject.keys(obj)"></a>bject.keys(obj)</h2><p>返回值: 一个表示给定对象的所有可枚举属性的字符串数组</p><ol><li><p>传入字符串，返回索引</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// console: ['0', '1', '2']</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>传入对象，返回属性名</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token string">'alive'</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token string">'bike'</span><span class="token punctuation">,</span> c<span class="token punctuation">:</span> <span class="token string">'color'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// console: ['a', 'b', 'c']</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h2 id="length"><a href="#length" class="headerlink" title="length"></a>length</h2><p>只对字符串和数组有用，整形数字和对象返回未定义undefined</p><h2 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h2><p>数组调用，监测数组是否包含给定的元素 <code>array.include(0)</code> 返回boolean</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>箭头函数与普通函数中的this指向不一样，前者基于定义时的上下文环境，后者则只是基于调用者。</p><h2 id="typeof-cb-“function”-amp-amp-cb"><a href="#typeof-cb-“function”-amp-amp-cb" class="headerlink" title="typeof cb == “function” &amp;&amp; cb()"></a>typeof cb == “function” &amp;&amp; cb()</h2><p>强大的js总有一些没见过的用法</p><p><code>function delay(time, cb) { typeof cb == "function" &amp;&amp; cb(time) }</code></p><p><code>cb&amp;&amp;cb(value)</code> 的意思是：</p><ul><li>如果cb为真（有值），那么执行cb(value)；</li><li>如果cb为假，&amp;&amp;短路，那么不执行cb(value)。</li></ul><h2 id="Date-日期对象"><a href="#Date-日期对象" class="headerlink" title="Date 日期对象"></a>Date 日期对象</h2><p>字符串转化为日期对象，将字符串作为参数实例化即可，new Date(2019 10 10)，传递时间戳也可以</p><p>时间对象格式化，建议使用扩展包，官方原生好像没有支持</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm JavaScript 包管理工具</title>
      <link href="/2018/10/22/JavaScript/npm/"/>
      <url>/2018/10/22/JavaScript/npm/</url>
      
        <content type="html"><![CDATA[<p>npm是node的包管理工具，不建议使用任何第三方的工具，也不建议换源，这些操作解决一时问题也带来其它问题。关于网络问题，是在不行用手机热点，如果你们公司的网络都下不了，那公司不用待了。第三方工具也是，开始npm确实比不上第三方工具，不过现在渐渐好多了，官方也意识到这些问题了。</p><a id="more"></a><h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><p>npm是node的包管理工具，不建议使用任何第三方的工具，也不建议换源，这些操作解决一时问题也带来其它问题。关于网络问题，实在不行用手机热点，如果你们公司的网络都下不了，那公司不用待了。第三方工具也是，开始npm确实比不上第三方工具，不过现在渐渐好多了，官方也意识到这些问题了。</p><h2 id="全局和局部"><a href="#全局和局部" class="headerlink" title="全局和局部"></a>全局和局部</h2><p>一般在全局安装的是工具，比如webpack，这样这些工具在构建项目或者执行项目的命令的时候由于是全局任何地方都能使用，而局部就是装模块的，这些模块可能因为依赖关系，你最好不要在全局装模块，如果你的项目引用全局模块，多个项目的时候，可能依赖不一样，这样你去更新全局模块的时候就可能由于依赖的问题影响其它项目了。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><table><thead><tr><th>Command</th><th align="center">Description</th></tr></thead><tbody><tr><td>npm list -g –depth 0</td><td align="center">查看全局安装包</td></tr><tr><td>npm install packagename -g</td><td align="center">全局安装</td></tr><tr><td>npm uninstall package -g</td><td align="center">全局卸载</td></tr><tr><td>npm install pg –save</td><td align="center">项目依赖安装</td></tr><tr><td>npm install pg –save-dev</td><td align="center">项目非依赖安装</td></tr><tr><td>npm view jquery versions</td><td align="center">查看模块版本号，这里举例的是jQuery</td></tr></tbody></table><p>要更新某个包到最新版本，直接安装即可 npm install element-ui 直接把当前包安装到最新版本</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-base 基础概念</title>
      <link href="/2018/10/22/Linux/linux-base/"/>
      <url>/2018/10/22/Linux/linux-base/</url>
      
        <content type="html"><![CDATA[<p>Linux学习笔记</p><a id="more"></a><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p>/etc<br>存放系统管理和配置文件</p><p>/usr  (Unix System Resource)<br>用于存放系统应用程序，比较重要的目录/usr/local本地系统管理员软件安装目录（安装系统级的应用）。这是最庞大的目录，要用到的应用程序和文件几乎都在这个目录。</p><p>/usr/bin众多的应用程序<br>/usr/sbin超级用户的一些管理程序</p><p>/usr/src源代码，linux内核的源代码就放在/usr/src/linux里</p><p>/usr/local/bin本地增加的命令<br>/usr/local/lib本地增加的库</p><p>/proc<br>虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息。</p><p>/sbin<br>存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等</p><p>一般，系统带的应用在/usr/bin   自己安装的在/usr/local/bin，/usr/sbin 也会有应用</p><p>如果你是编译安装的，最好用ln -s 源命令 /usr/local/bin，把编译安装的启动程序在通用安装目录下创建符号链接，这样就能直接在任何地方从命令行运行程序</p><h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><p>目录（d）   文件（-）  字符型文件（c ）  块设备（b） l 链接文件   p 管道文件</p><p>创建文件  touch</p><p>复制文件  cp -i  (覆盖提醒) cp -i file newfile</p><p>链接文件（new）    命令  ln</p><p>有硬链接和符号链接（软链接）</p><p>重命名  命令 mv</p><p>mv  a  b   操作上称为移动文件，a在当前目录移动成b，实现了修改名字的作用</p><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><p>权限 r  w  x  文件的权限如下图所示，开始指文件类型</p><pre><code>-rw-r--r-- 1 root root  664 Apr 12 22:46 uwsgi_params-rw-r--r-- 1 root root 3610 Apr 12 22:46 win-utf</code></pre><p>除去类型，开始三个 rw-  描述的是文件所有者的权限，r–  文件所属组 ，最后是其他用户。</p><p>关于所属组，比如system组，可以执行系统相关命令，当某个用户被临时加入到系统组，则该用户将拥有对应权限，比如：</p><pre><code>-r-xr-sr-x（- 类型， r-x 文件所有者权限  r-s  文件所属组权限  r-x 文件其它用户权限 </code></pre><p>如某个用户像执行它，只要加入系统组即可。</p><p>文件特殊权限  <code>SUID</code>   <code>SGID</code></p><p>目录给予SGID权限，该目录下创建的文件都将是这个组的。</p><p>目录设置SBIT位，只能自己修改目录下的文件，该目录可能创建多个文件（不同用户），防止别人来修改自己的文件。</p><p>文件权限可以隐藏，此时ls -l 看不到，用lsattr查看隐藏权限。  </p><p>更进一步，对某个命令设置特定用户才能执行，对某个用户做设置。</p><p>权限后面是链接数，然后是文件所属用户名，之后是所属组名，然后文件大小，日期时间，文件名。</p><p>记住，一个文件被创建的时候，它拥有inode和block，每个文件占用一个独立的inode table，记录文件的权限和属性，包括数据地址。block数据存放的实际内容。ls -il  这个i参数可以查看inode。</p><p>知道该文件的einode，使用find-inum 可以找到所有指向inode的文件。</p><p>补充：</p><p>符号链接，可以对文件和目录创建符合链接。符号链接可以理解为快捷方式，它和原文件是两个不同的文件，所有他们的inode不一样，而且他数据很小，因为只做指向。在ls命令下，可以看到文件类型是 <code>l</code>，并且后面会有 <code>fileA -&gt; fileB</code>，意为A是B的符号链接。原始文件被删除后，符号链接也失效。可以跨文件系统创建符号链接。不要创建符号链接的符号链接。</p><p>硬链接，会创建独立的虚拟文件，但是共享原文件的inode，使用ls命令查看，会发现它们完全一样（链接数都是2），除了名字外。引用硬链接等于引用原文件。不能对目录创建硬链接（目录下的所有数据都会被创建硬链接），不能跨文件系统。</p><h2 id="挂载与分区"><a href="#挂载与分区" class="headerlink" title="挂载与分区"></a>挂载与分区</h2><p>linux 硬盘第一扇区512byte，记录着主引导记录和分区信息。主引导占了446byte，后面的空间一般分配3个主分区，1个扩展分区。每个占16byte。如果全是主分区，只能有4个，所以主分区不能超过4个。</p><p>挂载，/etc/fstab记载着挂载信息，SWAP称为交换分区，类似虚拟内存。</p><h2 id="磁盘冗余阵列"><a href="#磁盘冗余阵列" class="headerlink" title="磁盘冗余阵列"></a>磁盘冗余阵列</h2><p><strong>RAID</strong></p><p>RAID 0～RAID 50等数个规范</p><p>RAID 0是组建磁盘阵列中最简单的一种形式，只需要2块以上的硬盘即可，成本低，可以提高整个磁盘的性能和吞吐量。RAID 0没有提供冗余或错误修复能力，但实现成本是最低的。最大的缺点在于任何一块硬盘出现故障，整个系统将会受到破坏，可靠性仅为单独一块硬盘的1/N。</p><p><strong>RAID1</strong></p><p>称为磁盘镜像，原理是把一个磁盘的数据镜像到另一个磁盘上，也就是说数据在写入一块磁盘的同时，会在另一块闲置的磁盘上生成镜像文件，在不影响性能情况下最大限度的保证系统的可靠性和可修复性上，只要系统中任何一对镜像盘中至少有一块磁盘可以使用，甚至可以在一半数量的硬盘出现问题时系统都可以正常运行,当一块硬盘失效时，系统会忽略该硬盘，转而使用剩余的镜像盘读写数据，具备很好的磁盘冗余能力。缺点磁盘利用率不高。</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>这是linux的模块，python 的 torado会对其进行封装，提供接口，是实现高并发的关键。BSD系统的是kqueue，大概概念应该是类似的，BSD接触的较少了。</p><p>epoll是整个框架实现高性能的基础，所以为了发挥性能，你需要把程序部署在linux上，使用linux的epoll。 </p><p>要理解这个模块是做什么的，先说任务阻塞，多个任务阻塞了，一般的操作系统机制是使用轮询的方法，循环所有阻塞任务，看是否有被唤醒的，这样太浪费时间了，如果当前循环任务没有被唤醒的，CPU白白浪费了一次循环，所以有了epoll 这是一个代理，在操作系统设计的代码大概是这样的，原来的思路是循环任务列表，现在使用epoll，被循环的任务列表将由epoll提供，如果没有，那么CPU就不用浪费时间了，那么什么情况下会有呢？就是当有任务被唤醒的时候，比如任务因为别人的事件被唤醒，比如A给被阻塞的任务B一个事件“缓冲区非空”，B得到这个事件，B不用被阻塞了，它需要去缓冲区读取数据，这个时候就通知epoll，我可以被调度了。epoll的好处就是可以告诉内核那个任务可以调度，传统的轮询要一个一个任务的查看谁能被调度，如此，加入一个代理加快了CPU处理任务的速度。</p><h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><p>nohup 是后台作业的意思， nohup运行的进程将会忽略终端信号运行。即后台运行一个命令。 </p><p>nohup COMMAND &amp; 用nohup运行命令可以使命令永久的执行下去，和用户终端没有关系，例如我们断开SSH连接都不会影响它的运行。</p><h2 id="supervisor"><a href="#supervisor" class="headerlink" title="supervisor"></a>supervisor</h2><p>supervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。</p><p>安装 <code>apt-get install -y supervisor</code></p><p>注意：终止进程后重启电脑，进程将会重启。所以要移除某个进程，要把对应的配置删除。</p><h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>什么是守护进程？其实感觉守护进程并没有什么明确的定义，只是守护进程有一些特征，这是它需要遵循的。</p><p>守护进程的第一个特征是长时间在后台运行的程序，并且主要是为了提供某种服务，而为了能够让服务尽可能随时都可用，就要求这个服务是一直运行的，于是守护进程就守护着这个服务不挂掉。linux里面常见的守护进程一般都是以d结尾的，比如apache的httpd,samba的smbd,ssh的sshd。</p><p>它的第二个特征是与启动它的进程的环境隔离，包括关闭它打开的所有文件描述符，终端，会话，进程组，某些环境变量（如工作目录），文件掩码。</p><ol><li>为什么要脱离终端？</li></ol><p>如果它不脱离终端，那么就有可能收到来自终端的信号，比如SIGINT(Ctrl+c,会被发往所有前台进程组的进程，它的默认行为就是结束进程),SIGHUP（会被发往会话首进程）</p><ol start="2"><li>为什么要关闭它打开的所有文件描述符？</li></ol><p>如果创建它的进程之前打开了某个文件，然后创建这个守护进程，这样子进程就继承了fd,如果守护进程不关闭这个fd,一个是会占用资源，二个我猜测和改变工作目录一样，如果这个文件是位于挂载目录，那么就无法umount了</p><ol start="3"><li>为什么要清掩码？</li></ol><p>这是因为假设它的父进程之前对掩码做过特殊设置，守护进程作为子进程会继承这个，那么它创建文件时，因为掩码的缘故，文件的权限就可能和实际设置的不一致。</p><p>第三个特征，守护进程通常由启动脚本启动</p><h1 id="apt-utils"><a href="#apt-utils" class="headerlink" title="apt-utils"></a>apt-utils</h1><p>apt-utils是Linux系统的兼容程序，在安装系统时有提示推荐安装apt-utils，如果未安装会无法安装第三方提供的Linux软件，只能使用官方推出的软件。比如wget是第三方软件，如果没有apt-utils会导致安装不上</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScriptUtil 常用实现</title>
      <link href="/2018/10/22/JavaScriptUtil/JavaScriptUtil/"/>
      <url>/2018/10/22/JavaScriptUtil/JavaScriptUtil/</url>
      
        <content type="html"><![CDATA[<p>常见的JavaScript 相关设计</p><a id="more"></a><h2 id="自定义遮蔽罩"><a href="#自定义遮蔽罩" class="headerlink" title="自定义遮蔽罩"></a>自定义遮蔽罩</h2><p>使用了jQuery-WeUI，需要根据情况做调整</p><pre class="line-numbers language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!--自定义遮罩层--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>bg<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>weui-mask weui-mask--visible<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name">    <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span><span class="token property">opacity</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token property">visibility</span><span class="token punctuation">:</span> visible<span class="token punctuation">;</span><span class="token property">z-index</span><span class="token punctuation">:</span> <span class="token number">100</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 简单示例 --></span><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Content-Type<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/html; charset<span class="token punctuation">=</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>html 最简遮罩层<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">        <span class="token keyword">function</span> <span class="token function">showDiv</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'popDiv'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">'block'</span><span class="token punctuation">;</span>            document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'bg'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">'block'</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">function</span> <span class="token function">closeDiv</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'popDiv'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">'none'</span><span class="token punctuation">;</span>            document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'bg'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">'none'</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>popDiv<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name">    <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">z-index</span><span class="token punctuation">:</span><span class="token number">99</span><span class="token punctuation">;</span><span class="token property">display</span><span class="token punctuation">:</span>none<span class="token punctuation">;</span><span class="token property">position</span><span class="token punctuation">:</span>absolute<span class="token punctuation">;</span><span class="token property">margin-top</span><span class="token punctuation">:</span> <span class="token number">20%</span><span class="token punctuation">;</span><span class="token property">margin-left</span><span class="token punctuation">:</span> <span class="token number">40%</span><span class="token punctuation">;</span><span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token hexcode">#FFF</span><span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>html    最简遮罩层<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span>html 最简遮罩层<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>javascript:closeDiv()<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>关闭遮罩层<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>bg<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name">    <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">display</span><span class="token punctuation">:</span>none<span class="token punctuation">;</span><span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token hexcode">#ccc</span><span class="token punctuation">;</span><span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span><span class="token property">position</span><span class="token punctuation">:</span>absolute<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span><span class="token property">opacity</span><span class="token punctuation">:</span> <span class="token number">0.5</span><span class="token punctuation">;</span><span class="token property">z-index</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">padding-top</span><span class="token punctuation">:</span> <span class="token number">10%</span><span class="token punctuation">;</span><span class="token property">padding-left</span><span class="token punctuation">:</span><span class="token number">40%</span><span class="token punctuation">;</span><span class="token property">z-index</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Submit<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>打开遮罩层<span class="token punctuation">"</span></span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>javascript:showDiv()<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Util </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Util </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-command 常用命令</title>
      <link href="/2018/10/22/Linux/linux-command/"/>
      <url>/2018/10/22/Linux/linux-command/</url>
      
        <content type="html"><![CDATA[<p>Linux 命令与工具</p><a id="more"></a><h2 id="chsh-修改用户使用的shell"><a href="#chsh-修改用户使用的shell" class="headerlink" title="chsh 修改用户使用的shell"></a>chsh 修改用户使用的shell</h2><p>查看 <code>cat /etc/shells</code> 文件，显示当前系统支持的shell，使用 <code>chsh -s /bin/zsh</code> 修改。该命令最终的效果会修改 <code>/etc/passwd</code> 文件。</p><h2 id="env-printenv-查看环境变量"><a href="#env-printenv-查看环境变量" class="headerlink" title="env printenv 查看环境变量"></a>env printenv 查看环境变量</h2><p>理解全局环境变量和局部环境变量，全局变量包括系统设置的和用户自己添加的，系统变量一般是全大写字母，通过printenv命令可以查看变量值 <code>printenv HOME</code>。</p><h2 id="scp-拷贝命令"><a href="#scp-拷贝命令" class="headerlink" title="scp 拷贝命令"></a>scp 拷贝命令</h2><p>scp命令 （主机和服务器相互拷贝数据，该命令要求开启scp服务。</p><p>从服务器到本地 <code>scp root@ip:拷贝路径 本地路径</code></p><p>从本地到服务器 <code>scp 本地路径 root@ip:拷贝路径</code></p><p>拷贝文件夹下的数据 scp -r /test/ root@ip:/root/target<br>记得拷贝文件夹要加 -r 斜杆遵照上面的格式，效果为把本地test文件夹拷贝到服务器，服务器在/root/target/test下得到文件夹下的文件</p><p>覆盖问题:</p><p>差不多都是这个套路，cp也是</p><p>本地weixin_ip，服务器没有weixin_ip，不过这种情况，第二次拷贝是不会覆盖原来的<br>scp -r /Users/liuzhi/PycharmProjects/weixin_ip root@ :/root/app/weixin_ip<br>覆盖服务器文件夹<br>scp -r /Users/liuzhi/PycharmProjects/weixin_ip <a href="mailto:root@1.1.1.1" target="_blank" rel="noopener">root@1.1.1.1</a>:/root/app/</p><p>scp -r /Users/liuzhi/Downloads/DBUtils-1.3.tar.gz zdhadmin@:/app</p><h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><ol><li>复制指定目录下的全部文件到另一个目录中<br>如果dir2目录不存在，则可以直接使用<br>cp -r dir1 dir2</li></ol><p>如果dir2目录已存在，则需要使用<br>cp -r dir1/. dir2</p><ol start="2"><li>复制文件<br>cp a.py /app/</li></ol><h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><p>删除当前目录下文件</p><p>在终端输入命令：rm ./*<br>解释：删除文件用rm命令，.点号代表当前目录，*星号是匹配符代表所有文件</p><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>内容查找命令，配合其它命令一起使用</p><h2 id="find-查找命令"><a href="#find-查找命令" class="headerlink" title="find 查找命令"></a>find 查找命令</h2><p>查找命令，列出符合条件的文件路径。 find / -name *</p><h2 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h2><p>查看系统运行情况，启动时间，登陆时间等。最后的三个数字代表系统最近1分钟，5分钟，15分钟负载情况。</p><pre><code>liuzhi@localhost  ~  uptime23:03  up 13:47, 3 users, load averages: 1.04 1.25 1.37</code></pre><p>/app/mysql/5.7.18/bin/mysql –socket=/app/mysql/5.7.18/dirstats/mysqld.sock -uroot -hlocalhost  -p</p><h2 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h2><p>lsof 是 linux 下的一个非常实用的系统级的监控、诊断工具。<br>它的意思是 <code>List Open Files</code>，很容易你就记住了它是 <code>“ls + of”</code> 的组合。<br>它可以用来列出被各种进程打开的文件信息，记住：linux 下 “一切皆文件”，<br>包括但不限于 pipes, sockets, directories, devices, 等等。<br>因此，使用 lsof，你可以获取任何被打开文件的各种信息。</p><p>监控进程：<code>lsof -p 2854</code> 查看指定进程打开的文件。</p><p>监控网络：<code>lsof -i:8080</code> 查看端口被哪些进程使用。</p><h2 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h2><p>wget url 下载文件</p><h2 id="tar-解压"><a href="#tar-解压" class="headerlink" title="tar 解压"></a>tar 解压</h2><p>关于解压，如果是网络的包，文件后缀tar.gz</p><p>解压命令 tar -zxvf filename</p><p>tar -zxvf filename -C /tmp/ 解压到指定目录</p><p>zip类型，需要安装解压工具 unzip</p><p>unzip filename 先创建好目标目录，在里面解压，或者指定目录</p><h2 id="zip压缩文件夹"><a href="#zip压缩文件夹" class="headerlink" title="zip压缩文件夹"></a>zip压缩文件夹</h2><p>zip -r fileName.zip 文件夹名</p><h2 id="screen-工具"><a href="#screen-工具" class="headerlink" title="screen 工具"></a>screen 工具</h2><p>需要下载</p><p>screen -r name</p><p>screen -S name  最好用大写的S</p><p>screen C d  关闭当前会话并结束进程</p><p>screen -ls</p><p>会话会有状态，dead 状态利用screen -wipe 清除</p><p>Detached 为没有人登陆，Attached为有人，有时候没有人也会是这个状态，一般是出问题了screen -D  -r ＜session-id&gt; 先踢掉前一用户，再登陆。</p><p>screen -X -S session_id quit</p><h2 id="tmux-工具"><a href="#tmux-工具" class="headerlink" title="tmux 工具"></a>tmux 工具</h2><p>需要下载，类似screen的分屏工具</p><p>创建新的会话 tmux new -s web，此时会进入新的会话web中，在下面可以看到会话名称，在tmux会话中，ctrl + b 后，才能执行对应的命令。</p><p>使用 Ctrl + b 按下 d 脱离当前会话，然后使用tmux attach 连接 web会话，这个命令用于连接刚才退出的会话，使用tmux a -t web 根据名字连接对应的会话。</p><h2 id="查看发行版本信息"><a href="#查看发行版本信息" class="headerlink" title="查看发行版本信息"></a>查看发行版本信息</h2><p><code>cat /etc/issue</code> 或 <code>cat /etc/redhat-release</code>（Linux查看版本当前操作系统发行版信息）</p><h2 id="查看内核信息"><a href="#查看内核信息" class="headerlink" title="查看内核信息"></a>查看内核信息</h2><p><code>uname -a</code>（Linux查看版本当前操作系统内核信息）</p><h2 id="查看操作系统版本信息"><a href="#查看操作系统版本信息" class="headerlink" title="查看操作系统版本信息"></a>查看操作系统版本信息</h2><p><code>cat /proc/version</code>（Linux查看当前操作系统版本信息）</p><h2 id="mkdir-p"><a href="#mkdir-p" class="headerlink" title="mkdir -p"></a>mkdir -p</h2><p>mkdir 用于创建文件夹，如果包含子目录，需要使用 -p ，这样就可以创建多层级的目录</p><p>例子：mkdir -p ~/web-develop/projects/data</p><h2 id="mv-移动、重命名"><a href="#mv-移动、重命名" class="headerlink" title="mv 移动、重命名"></a>mv 移动、重命名</h2><p>mv [options] 源文件或目录 目标文件或目录</p><h2 id="Debian-删除软件"><a href="#Debian-删除软件" class="headerlink" title="Debian 删除软件"></a>Debian 删除软件</h2><p>基于Debian的Linux发行版使用apt-get管理软件包</p><ul><li>apt-get remove 会删除软件包而保留软件的配置文件</li><li>apt-get purge 会同时清除软件包和软件的配置文件</li></ul><h2 id="查看端口"><a href="#查看端口" class="headerlink" title="查看端口"></a>查看端口</h2><p>使用到的命令为 netstat 配合参数和 grep 命令一起使用<br><code>netstat -an | grep 3306</code></p><p>-a (all)显示所有选项，netstat默认不显示LISTEN相关<br>-t (tcp)仅显示tcp相关选项<br>-u (udp)仅显示udp相关选项<br>-n 拒绝显示别名，能显示数字的全部转化成数字。(重要)<br>-l 仅列出有在 Listen (监听) 的服務状态</p><p>-p 显示建立相关链接的程序名(macOS中表示协议 -p protocol)<br>-r 显示路由信息，路由表<br>-e 显示扩展信息，例如uid等<br>-s 按各个协议进行统计 (重要)<br>-c 每隔一个固定时间，执行该netstat命令。</p><p>提示：LISTEN和LISTENING的状态只有用-a或者-l才能看到 </p><h2 id="chmod-修改权限"><a href="#chmod-修改权限" class="headerlink" title="chmod 修改权限"></a>chmod 修改权限</h2><p>chmod 664 file_name</p><p>可以通过 - 添加参数，一般是当前用户没有权限，才需要这个命令，权限列表分别为 所属用户，用户组，其它用户。你没有权限肯定不是所属用户，可以看看是不是这个分组的，使用 groups 命令，groups user_name 查看对应用户所属分组。whoami 查看当前用户名。</p><p>最好就是在分组里面对其分组添加权限即可，否则就要添加其它用户的权限</p><h2 id="pkill-终止进程"><a href="#pkill-终止进程" class="headerlink" title="pkill 终止进程"></a>pkill 终止进程</h2><p>pkill -signal 进程PID或进程名称，要知道有什么信号，使用kill -l</p><h2 id="crontab-定时任务"><a href="#crontab-定时任务" class="headerlink" title="crontab 定时任务"></a>crontab 定时任务</h2><p>没有该服务的需要安装</p><p>执行命令 <code>cat /etc/crontab</code></p><pre class="line-numbers language-s"><code class="language-s">[root@123 ~]# cat /etc/crontab SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# |  .------------- hour (0 - 23)# |  |  .---------- day of month (1 - 31)# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# |  |  |  |  |# *  *  *  *  * user-name  command to be executed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数含义：<br>第一行SHELL变量指定了系统要使用哪个shell，这里是bash<br>第二行PATH变量指定了系统执行 命令的路径<br>第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户，如果MAILTO变量的值为空，则表示不发送任务 执行信息给用户<br>第四行的HOME变量指定了在执行命令或者脚本时使用的主目录（这里未定义）</p><p>命令格式：<br>星号（<em>）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。<br>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”<br>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”<br>正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如</em>/10，如果用在minute字段，表示每十分钟执行一次。</p><p>命令 <code>crontab -e</code> 调用系统的vim来进行编辑定时器任务</p><h2 id="PRM包安装"><a href="#PRM包安装" class="headerlink" title="PRM包安装"></a>PRM包安装</h2><p>网络下载包，一般用于离线安装</p><p>包全名：操作的包是没有安装的软件包时，使用包全名。而且要注意路径。</p><p>包名：操作已经安装的软件包时，使用包名，是搜索/var/lib/rpm/中的数据库。</p><pre class="line-numbers language-s"><code class="language-s">rpm -ivh  包全名选项：　　-i (install)  安装　　-v (verbose) 显示详细信息　　-h (hash) 显示进度　　--nodeps 不检测依赖性（绝不允许使用）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装信息会有两个百分比，看到第二个一般就是成功了</p><p>升级：rpm  -Uvh  包全名<br>卸载：rpm  -e  包名<br>查询包是否安装：rpm  -q  包名  rpm  -qa 列出已安装的包<br>查询包中文件安装位置：rpm  -ql  包名<br>查询详细信息：rpm  -qi  包名　　-i　查询软件信息（information）　　-p　查询未安装包信息（package</p><h2 id="supervisorctl工具"><a href="#supervisorctl工具" class="headerlink" title="supervisorctl工具"></a>supervisorctl工具</h2><p>Supervisord 是用 Python 实现的一款的进程管理工具，supervisord 要求管理的程序是非 daemon 程序，supervisord 会帮你把它转成 daemon 程序，因此如果用 supervisord 来管理进程，进程需要以非daemon的方式启动。<br>例如：管理nginx 的话，必须在 nginx 的配置文件里添加一行设置 daemon off 让 nginx 以非 daemon 方式启动</p><p>命令分为supervisord和supervisorctl两种类型，supervisord用于初始化和启动服务，然后基本都是用supervisorctl来管理进程</p><pre class="line-numbers language-s"><code class="language-s">supervisord -c ./conf/supervisor.conf  启动服务supervisorctl -c ./conf/supervisor.conf reloadsupervisorctl -c ./conf/supervisor.conf restart 进程名称supervisorctl -c ./conf/supervisor.conf status 查看状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>以上的命令都是显示的指定配置文件的形式</p><h2 id="sed-流编辑器工具"><a href="#sed-流编辑器工具" class="headerlink" title="sed 流编辑器工具"></a>sed 流编辑器工具</h2><p>一个非常强大的文本处理工具</p><p>sed -n ‘3,9p’ filename 获取3到9行的内容</p><p>sed -i ‘s#${user.home}#/app/svr/rocketmq#g’ *.xml</p><p>替换文本，<code>'s/原字符串/新字符串/g'</code> 格式是这样，g代表全部符号的都替换，比如 <code>'s/d/123'</code> 作用于文本 ddd，结果是 123ddd，加了g后就是123123123，其中<code>/</code>可以换成其它符号，比如<code>#</code>，这样就和文本内容区别开了。<code>*.xml</code>是作用的文件，整个功能就是把当前目录xml后缀的文件进行文本替换，<code>${user.home}</code>环境变量取值换成固定的<code>/app/svr/rocketmq</code></p><h2 id="journalctl-日志管理"><a href="#journalctl-日志管理" class="headerlink" title="journalctl 日志管理"></a>journalctl 日志管理</h2><p>和systemctl类似的很强大的日志查看命令</p><pre class="line-numbers language-s"><code class="language-s"># followjournalctl -f# 显示最近10条journalctl -n# 显示最近20条journal -n 20 # 显示磁盘占用情况journal --disk-usage# 查看一段时间内的journalctl --since "2015-01-10" --until "2015-01-11 03:00"# 过滤journalctl -u 服务名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>journalctl -f -u kubelet</code> 让系统一直打印kubelet服务产生的日志</p><h2 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h2><p>如果没有这个包，通过yum search ifconfig，查看这个命令是在哪个包里面，<code>yum install net-tools.x86_64</code>安装后就可以使用ifconfig了</p><h2 id="du-sh-查看当前目录大小"><a href="#du-sh-查看当前目录大小" class="headerlink" title="du -sh 查看当前目录大小"></a>du -sh 查看当前目录大小</h2><p>用于查看当前目录下所有文件合计大小</p><h2 id="saltstack"><a href="#saltstack" class="headerlink" title="saltstack"></a>saltstack</h2><p>saltstack是由python编写的采用c/s架构的自动化运维工具，由master和minion组成，使用ZeroMQ消息队列pub/sub方式通信，使用SSL证书签发的方式进行认证管理<br>本身是支持多master的。saltstack除了可以通过在节点安装客户端进行管理还支持直接通过ssh进行管理<br>运行模式为master端下发指令，客户端接收指令执行<br>采用yaml格式编写配置文件，支持api及自定义python模块，能轻松实现功能扩展</p><p>saltstack有一个saltstack master，而很多saltstack minon在初始化时会连接到该master上<br>初始化时，minion会交换一个秘钥建立握手，然后建立一个持久的加密的TCP连接<br>通常，命令起始于master的命令行中，master将命令分发minion上<br>saltstack master可以同时连接很多minion而无需担心过载，这都归功于ZeroMQ<br>由于minion和master之间建立了持久化连接，所以master上的命令能很快的到达minion上。minion也可以缓存多种数据，以便加速执行</p><p>salt ‘192.168.10.1’ cmd.run ‘pwd’</p><p>关于salt-key，minion端新启动后，会向master注册salt-key，后面就不会再注册了，有重复注册了也不会自动解决，所以应该minion停止服务，salt-key -d 删除认证，然后再重启minion，进行重新注册</p><p>salt-key -d 10.0.007 把已经认证的key删除<br>salt-key</p><h2 id="tail-查看文件"><a href="#tail-查看文件" class="headerlink" title="tail 查看文件"></a>tail 查看文件</h2><p>tail -f 实时查看日志文件 tail -f 日志文件log<br>tail - 100f 实时查看日志文件 后一百行<br>tail -f -n 100 catalina.out linux查看日志后100行<br>搜寻字符串<br>grep ‘搜寻字符串’ filename<br>按ctrl+c 退出</p><h2 id="修改用户和用户组"><a href="#修改用户和用户组" class="headerlink" title="修改用户和用户组"></a>修改用户和用户组</h2><p>chown www lifang 改用户  chown 用户 要修改的文件<br>chgrp www lifang 改用户组  chgrp 用户组 要修改的文件<br>chgrp -R vagrant open-falcon    -R    参数修改文件及子文件</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>yumdownloader systemd-python –resolve –destdir=/data/mydepot/</p><p>把systemd-python依赖的东西下到指定目录，可以在有外网的机器上下载依赖，去服务器安装依赖</p><h2 id="sysstat"><a href="#sysstat" class="headerlink" title="sysstat"></a>sysstat</h2><p>pidstat 是sysstat软件套件的一部分，sysstat包含很多监控linux系统状态的工具，它能够从大多数linux发行版的软件源中获得</p><p>可以用相关命令查看内存，进程，cpu等占比</p><p>yum install sysstat</p><p><a href="https://www.jianshu.com/p/3991c0dba094" target="_blank" rel="noopener">https://www.jianshu.com/p/3991c0dba094</a></p><h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><p>一个程序执行后，系统会生成三个句柄，分别是:</p><ul><li>0=stdin（标准输入）</li><li>1=stdout（标准输出）</li><li>2=stderr（错误输出）</li></ul><p>默认情况下，三个句柄都指向当前会话的命令行控制台。命令转到后台执行后，stdin关闭，stdout和stderr还是指向控制台<br>通过在命令后使用输出重定向符 &gt; 实现对输出的重定向</p><p><code>./test.py &gt; log.log 2&gt;&amp;1 &amp;</code></p><p>通过重定向符把stdout输出到log.log中，后面的 2&gt;&amp;1表示把stderr重定向到stdout，上面合起来的作用就是把stdout和stderr都输出到log.log中</p><h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><p>nohup介绍 用途：不挂断地运行命令</p><p>一般情况，执行脚本  sh 脚本  ./脚本  但是这种执行只会在前台，不能挂到后台</p><p>语法：nohup Command [Arg …] [　&amp; ]</p><p>通过 &amp; 虽然可以把命令以后台进程的方式执行，但是如果SSH会话中断退出，和此会话相关的所有进程都会终止。<br>如果我们是登录服务器去启动一个服务程序，总不能启动后一直把SSH会话开着，而且会话到期会自动终止</p><p>这是，我们可以使用 nohup（no hung up）来执行进程，此命令确保会话挂断后，命令可以继续运行。以nohup运行的命令，系统默认自动把stdout和stderr重定向到当前目录的nohup.out文件</p><p><code>nohup ./run.py &amp;</code></p><p>无论是否将 nohup 命令的输出重定向到终端，输出都将附加到当前目录的 nohup.out 文件中。<br>如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。<br>如果没有文件能创建或打开以用于追加，那么 Command 参数指定的命令不可调用。</p><h3 id="nohup和-amp-的区别"><a href="#nohup和-amp-的区别" class="headerlink" title="nohup和&amp;的区别"></a>nohup和&amp;的区别</h3><ul><li><p>&amp;：已后台进程执行命令，但是会话关闭后，进程会结束</p></li><li><p>nohup：确保进程不挂断的执行，但是没有后台执行的功能，所以一般nohup和&amp;需要配合一起使用</p></li><li><p>使用 nohup 运行程序:</p></li></ul><p>输出重定向，默认重定向到当前目录下 nohup.out 文件<br>使用 Ctrl + C 发送 SIGINT 信号，程序关闭<br>关闭 Shell Session 发送 SIGHUP 信号，程序免疫</p><ul><li>使用 &amp; 运行程序：</li></ul><p>程序转入后台运行<br>结果会输出到终端<br>使用 Ctrl + C 发送 SIGINT 信号，程序免疫<br>关闭 Shell session 发送 SIGHUP 信号，程序关闭</p><h2 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h2><p>yum install telnet –y</p><p>telnet 192.168.100.101 8080</p><h2 id="centos6-关闭防火墙"><a href="#centos6-关闭防火墙" class="headerlink" title="centos6 关闭防火墙"></a>centos6 关闭防火墙</h2><p>1.service命令</p><p>关闭防火墙：service iptables stop<br>开启防火墙：service iptables start<br>重启防火墙：service iptables restart<br>查看防火墙状态：service iptables status</p><h2 id="查看进程数和线程数"><a href="#查看进程数和线程数" class="headerlink" title="查看进程数和线程数"></a>查看进程数和线程数</h2><p>ps -ef| wc -l</p><p>ps -ef| grep httpd | wc -l</p><p>1。 使用top命令，具体用法是 top -H<br>加上这个选项，top的每一行就不是显示一个进程，而是一个线程。<br>2。 使用ps命令，具体用法是 ps -xH<br>这样可以查看所有存在的线程，也可以使用grep作进一步的过滤。<br>3。 使用ps命令，具体用法是 ps -mq PID</p><h2 id="性能排查"><a href="#性能排查" class="headerlink" title="性能排查"></a>性能排查</h2><p>echo “内存使用情况”<br>echo “———————————-“<br>free -m<br>echo<br>echo “磁盘使用情况”<br>echo “———————————-“<br>df -h<br>echo<br>echo “网络连接情况”<br>echo “———————————-“<br>#过滤了127.0.0.1<br>netstat -n |grep -v ‘127.0.0.1’| awk ‘/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}’<br>echo<br>echo “网络监听情况”<br>echo “———————————-“<br>netstat -tnpl | awk ‘NR&gt;2 {printf “%-20s %-15s \n”,$4,$7}’<br>echo<br>echo “内存占用Top 10”<br>echo “———————————-“<br>ps -eo rss,pmem,pcpu,vsize,args |body sort -k 1 -r -n | head -n 10<br>echo<br>echo “CPU占用Top 10”<br>echo “———————————-“<br>ps -eo rss,pmem,pcpu,vsize,args |body sort -k 3 -r -n | head -n 10<br>echo<br>echo “最近1小时网络流量统计”<br>echo “———————————-“<br>sar -n DEV -s <code>date -d "1 hour ago" +%H:%M:%S</code><br>echo<br>echo “最近1小时cpu使用统计”<br>echo “———————————-“<br>sar -u -s <code>date -d "1 hour ago" +%H:%M:%S</code><br>echo<br>echo “最近1小时磁盘IO统计”<br>echo “———————————-“<br>sar -b -s <code>date -d "1 hour ago" +%H:%M:%S</code><br>echo<br>echo “最近1小时进程队列和平均负载统计”<br>echo “———————————-“<br>sar -q -s <code>date -d "1 hour ago" +%H:%M:%S</code><br>echo<br>echo “最近1小时内存和交换空间的统计统计”<br>echo “———————————-“<br>sar -r -s <code>date -d "1 hour ago" +%H:%M:%S</code><br>echo </p><h2 id="sftp"><a href="#sftp" class="headerlink" title="sftp"></a>sftp</h2><p>cd 路径                        更改远程目录到“路径”<br>lcd 路径                       更改本地目录到“路径”<br>ls [选项] [路径]               显示远程目录列表<br>lls [选项] [路径]              显示本地目录列表<br>put 本地路径                   上传文件<br>get 远程路径                   下载文件</p><p>下载服务器文件夹，上传也是类似</p><p>get -r logstash/.<br>put -r logstash/.</p><p>rz</p><h2 id="sh-c"><a href="#sh-c" class="headerlink" title="sh -c"></a>sh -c</h2><p>把数据写入文件</p><p>echo “信息” &gt; test.asc</p><p>但是如果test.asc是root才能执行的，这个时候 sudo echo “信息” &gt; test.asc 就报错了</p><p>原因是sudo只是将echo有了root权限，但是重定向符号 “&gt;” 和 “&gt;&gt;” 也是 bash 的命令，还是没有权限</p><p>解决办法：</p><p>利用 “sh -c” 命令，它可以让 bash 将一个字串作为完整的命令来执行，这样就可以将 sudo 的影响范围扩展到整条命令。具体用法如下：<br>$ sudo sh -c ‘echo “又一行信息” &gt;&gt; test.asc’</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim 编辑器操作</title>
      <link href="/2018/10/22/Linux/vim/"/>
      <url>/2018/10/22/Linux/vim/</url>
      
        <content type="html"><![CDATA[<p>vim的使用</p><a id="more"></a><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><ul><li>导航(navigation)模式： 这时候，字母就是上下左右键。</li><li>输入模式：你按字母键，才会输入字母。</li><li>命令模式：需要先输入”:” 冒号，才会进入。例如，你输入 :ls , 就相当于运行了 ls 命令。</li></ul><h2 id="粘贴模式-常用"><a href="#粘贴模式-常用" class="headerlink" title="粘贴模式(常用)"></a>粘贴模式(常用)</h2><p>相信你一定遇到过把本地的代码粘贴到Vim出现排版错乱问题，Vim 正常模式下的粘贴，会导致粘贴的代码一行接一行的缩进。如果要取消这种缩进的话，就要进入到 “粘贴模式”. （记得在这个模式下，无法使用 ctrl + t 命令来快速打开文件。）</p><pre><code>:set paste 进入到粘贴模式:set nopaste 取消粘贴模式</code></pre><h2 id="光标操作"><a href="#光标操作" class="headerlink" title="光标操作"></a>光标操作</h2><pre><code>h 左 l 右j 下 k 上w: 下一个词。 (word)b: 上一个词。 (backword)</code></pre><p>选择文本</p><pre><code>按住 v 加方向键</code></pre><h2 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h2><pre><code>y#复制反白的地方d#删除反白的地方yy#复制光标所在的那一行（常用）dd#删除光标所在的那一行（常用）</code></pre><h2 id="文本替换"><a href="#文本替换" class="headerlink" title="文本替换"></a>文本替换</h2><p>当前文件中替换</p><pre><code>:%s/原来的字符串/新字符串/</code></pre><p>替换匹配的所有文本</p><pre><code>:%s/原来的字符串/新字符串/g</code></pre><p>局部替换</p><pre><code>先v或 shift + v 选中若干行，然后:s/原来的/新的字符串</code></pre><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><pre><code>/ #搜索 some_thing: n #继续搜索下一个：shift + n #搜索前一个</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-question</title>
      <link href="/2018/10/22/Linux/question/"/>
      <url>/2018/10/22/Linux/question/</url>
      
        <content type="html"><![CDATA[<p>Linux遇到的问题</p><a id="more"></a><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>export LC_CTYPE=en_US.UTF-8 在 user目录下面，.bashrc 文件加入这一行，执行 <code>source .bashrc</code></p><p>解决svn 编码错误问题。或者直接执行 LC_CTYPE=en_US.UTF-8（对本次登陆有效）</p><p>lsb_release -a  查看版本信息</p><p>本地仓库关联远程仓库：通过GitHub创建的仓库，通常会有一个README.md，在本地初始化一个目录为git  当我们想把这个目录和远程GitHub仓库关联起来的时候，实际上是合并两个分支，所以如果两个仓库有同名文件就会发生冲突，最好不要有同名文件，以确保合并分支成功。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-shell 环境变量</title>
      <link href="/2018/10/22/Linux/linux-shell/"/>
      <url>/2018/10/22/Linux/linux-shell/</url>
      
        <content type="html"><![CDATA[<p>linux shell学习笔记</p><a id="more"></a><h2 id="定位系统环境变量"><a href="#定位系统环境变量" class="headerlink" title="定位系统环境变量"></a>定位系统环境变量</h2><p>登录shell的时候，默认情况下bash会在几个文件中查找命令，这些文件称为启动文件或环境文件。<br>这就是我们经常设置的把某个程序的目录加到环境变量，如果你跟风，用了什么 <code>item2</code> 这样的第三方shell，并对系统做了一些修改，那么原来安装的软件默认设置的环境变量就没有了，需要把他们迁移到新的shell中。</p><pre><code>bash检查的启动文件，取决于你启动shell的方式：- 登录时作为默认登陆shell- 作为非登录shell的交互式shell- 作为运行脚本的非交互shell虽然都是进入了shell，但是它们的环境变量有区别。</code></pre><h2 id="登录shell"><a href="#登录shell" class="headerlink" title="登录shell"></a>登录shell</h2><p>这种shell就是你登陆后启动的shell。</p><p>常见启动文件：</p><ul><li>/etc/profile</li><li>$HOME/.bash_profile&nbsp;&nbsp; $HOME/.bashrc</li><li>$HOME/.bash_login&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $HOME/.profile</li></ul><p>上述是 <code>bash shell</code> 的启动文件。如果你使用了一些第三方安装了 <code>zsh</code> 应该可以在~目录找到 <code>.zshrc</code>。<br><br><code>/etc/profile</code> 是系统环境变量，剩余的是用户的，每个用户都可以编辑这些文件添加自己的环境变量。<br>这些环境变量在启动 <code>bash shell</code> 的时候生效。</p><p>shell会按照按照下列顺序，运行第一个被找到的文件，余下的则被忽略:</p><ul><li>$HOME/.bash_profile  </li><li>$HOME/.bash_login</li><li>$HOME/.profile</li></ul><p>注意，这个列表中并没有 <code>$HOME/.bashrc文件</code>。这是因为该文件通常通过其他文件运行的，比如在有些Linux系统中 <code>./bash_profile</code> 文件会去找有没有 <code>.bashrc</code>，有的话先执行它。</p><h2 id="交互式shell"><a href="#交互式shell" class="headerlink" title="交互式shell"></a>交互式shell</h2><p>就是通过命令行启动shell，比如 <code>/bin/sh 如果安装zsh /bin/zsh</code> 这种情况不会访问系统变量。</p><h2 id="非交互式shell"><a href="#非交互式shell" class="headerlink" title="非交互式shell"></a>非交互式shell</h2><p>最后一种shell是非交互式shell。系统执行shell脚本时用的就是这种shell。不同的地方在于它<br>没有命令行提示符。但是当你在系统上运行脚本时，也许希望能够运行一些特定启动的命令。<strong>非交互，理解继承，如果你要编写脚本要知道这是什么情况</strong></p><p>为了处理这种情况，<code>bash shell</code> 提供了 <code>BASH_ENV</code> 环境变量。当shell启动一个非交互式shell进程时，它会检查这个环境变量来查看要执行的启动文件。如果有指定的文件，shell会执行该文件里的命令，这通常包括shell脚本变量设置。</p><p>在CentOS Linux发行版中，这个环境变量在默认情况下并未设置。如果变量未设置，printenv命令只会返回CLI提示符:<br>$ printenv BASH_ENV $</p><p>Ubuntu发行版中，变量BASH_ENV也没有被设置。记住，如果变量未设置，echo 命令会显示一个空行，然后返回CLI提示符:<br>$ echo $BASH_ENV</p><p>那如果BASH_ENV变量没有设置，shell脚本到哪里去获得它们的环境变量呢?别忘了有些shell脚本是通过启动一个子shell来执行的。子shell可以继承父shell导出过的变量。举例来说，如果父shell是登录shell，在/etc/profile、/etc/profile.d/*.sh和$HOME/.bashrc文件中<br>设置并导出了变量，用于执行脚本的子shell就能够继承这些变量。 </p><pre><code>要记住，由父shell设置但并未导出的变量都是局部变量。子shell无法继承局部变量。对于那些不启动子shell的脚本，变量已经存在于当前shell中了。所以就算没有设置BASH_ENV，也可以使用当前shell的局部变量和全局变量。</code></pre><h2 id="环境变量持久化"><a href="#环境变量持久化" class="headerlink" title="环境变量持久化"></a>环境变量持久化</h2><p>现在你已经了解了各种shell进程以及对应的环境文件，找出永久性环境变量就容易多了。也可以利用这些文件创建自己的永久性全局变量或局部变量。<br>对全局环境变量来说(Linux系统中所有用户都需要使用的变量)，可能更倾向于将新的或修改过的变量设置放在 <code>/etc/profile</code> 文件中，但这可不是什么好主意。如果你升级了所用的发行版，这个文件也会跟着更新，那你所有定制过的变量设置可就都没有了。</p><p>最好是在 <code>/etc/profile.d</code> 目录中创建一个以.sh结尾的文件。把所有新的或修改过的全局环境变 量设置放在这个文件中。<br>在大多数发行版中，存储个人用户永久性 <code>bash shell</code> 变量的地方是 <code>$HOME/.bashrc</code> 文件。这一点适用于所有类型的shell进程。但如果设置了BASH_ENV变量，那么记住，除非它指向的是 $HOME/.bashrc，否则你应该将非交互式shell的用户变量放在别的地方。<br>图形化界面组成部分(如GUI客户端)的环境变量可能需要在另外一些配置文件中设置，这和设置 <code>bash shell</code> 环境变量的地方不一样。<br>你可以把自己的alias设置放在 <code>$HOME/.bashrc</code> 启动文件中，使其效果永久化。</p><p>:sunny:<strong>总结：</strong><br><br>全局环境变量可以在对其作出定义的父进程所创建的子进程中使用。局部环境变量只能在定义它们的进程中使用。<br>Linux系统使用全局环境变量和局部环境变量存储系统环境信息。可以通过shell的命令行界面或者在shell脚本中访问这些信息。<code>bash shell</code> 沿用了最初 <code>Unix Bourne shell</code> 定义的那些系统环境变量，也支持很多新的环境变量。PATH环境变量定义了 <code>bash shell</code> 在查找可执行命令时的搜索目录。可以修改PATH环境变量来添加自己的搜索目录(甚至是当前目录符号)，以方便程序的运行。也可以创建自用的全局和局部环境变量。一旦创建了环境变量，它在整个shell会话过程中就都是可用的。</p><p><code>bash shell</code> 会在启动时执行几个启动文件。这些启动文件包含了环境变量的定义，可用于为每个bash会话设置标准环境变量。每次登录Linux系统，<code>bash shell</code>  都会访问/etc/profile启动文件以及3个针对每个用户的本地启动文件 <strong>:$HOME/.bash_profile、$HOME/.bash_login和$HOME/.profile。</strong> 用户可以在这些文件中定制自己想要的环境变量和启动脚本。<br>最后，我们还讨论了环境变量数组。这些环境变量可在单个变量中包含多个值。你可以通过指定索引值来访问其中的单个值，或是通过环境变量数组名来引用所有的值。</p><pre><code>重点：永久环境变量，用户环境变量，配置顺序也很重要，直接使用符号链接和配置环境变量</code></pre><h2 id="ssh免密登录"><a href="#ssh免密登录" class="headerlink" title="ssh免密登录"></a>ssh免密登录</h2><p>ssh-keygen 在本地生成密钥和私钥，有时候会看到带 -t DSA 参数，这是选择加密算法，一般用默认就行。<br>把公钥复制到目标机器的authorized_keys中即可</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HomeBrew mac-os 软件管理工具</title>
      <link href="/2018/10/22/Mac/HomeBrew/"/>
      <url>/2018/10/22/Mac/HomeBrew/</url>
      
        <content type="html"><![CDATA[<p>用mac电脑，你需要学会HomeBrew</p><a id="more"></a><h2 id="HomeBrew"><a href="#HomeBrew" class="headerlink" title="HomeBrew"></a>HomeBrew</h2><p>mac 平台的包管理工具，官网地址<a href="https://brew.sh/" target="_blank" rel="noopener">https://brew.sh/</a></p><pre class="line-numbers language-sh"><code class="language-sh">安装命令/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>记得先安装Xcode，保证安装脚步需要的环境都是可行的。</p><p>常用命令</p><table><thead><tr><th>Command</th><th align="center">Description</th></tr></thead><tbody><tr><td>brew info [name]</td><td align="center">查看已安装包都信息</td></tr><tr><td>brew search [name]</td><td align="center">搜索包</td></tr><tr><td>brew install remove rm [name]</td><td align="center">安装包</td></tr><tr><td>brew uninstall [name]</td><td align="center">卸载包</td></tr><tr><td>brew list</td><td align="center">查看已安装的包列表</td></tr><tr><td>brew cleanup</td><td align="center">删除文件残留</td></tr><tr><td>brew cleanup [name]</td><td align="center"></td></tr><tr><td>brew deps [name]</td><td align="center">查看包的依赖</td></tr><tr><td>brew outdated</td><td align="center">查看需要更新的包</td></tr><tr><td>brew update</td><td align="center">更新包</td></tr><tr><td>brew home [name]</td><td align="center">用浏览器打开，查看包的网页信息</td></tr><tr><td>brew options [name]</td><td align="center">查看包的安装选项</td></tr><tr><td>brew services list</td><td align="center">查看homebrew安装的服务情况</td></tr><tr><td>brew services start</td><td align="center">启动服务，后面跟服务名称</td></tr><tr><td>brew services stop</td><td align="center">停止服务，后面跟服务名称</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Util </tag>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Iterm2 终端工具</title>
      <link href="/2018/10/22/Mac/Iterm2/"/>
      <url>/2018/10/22/Mac/Iterm2/</url>
      
        <content type="html"><![CDATA[<p>不错的终端软件</p><a id="more"></a><h2 id="移动一个单词"><a href="#移动一个单词" class="headerlink" title="移动一个单词"></a>移动一个单词</h2><p>在Profile – keys下，找到如同的原配置信息。<br><img src="/images/Mac/iterm2_key_1.png" alt="image"><br>其实这是已有的功能，不过Mac默认的快捷键被占用了，修改成我们习惯的。<br>分别修改option+←和option+→的映射，选择Action为“Send Escape Sequence”，然后输入“b”和“f”即可。</p><h2 id="配置远程ssh登陆"><a href="#配置远程ssh登陆" class="headerlink" title="配置远程ssh登陆"></a>配置远程ssh登陆</h2><p>使用脚本传参数的方式登陆，先准备脚本，内容如下：</p><pre class="line-numbers language-sh"><code class="language-sh">#!/usr/bin/expectset timeout 30spawn ssh -p [lindex $argv 0] [lindex $argv 1]@[lindex $argv 2]expect {        "(yes/no)?"        {send "yes\n";exp_continue}        "password:"        {send "[lindex $argv 3]\n"}}interact<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在本地创建这么一个文件 <code>*.sh</code><br>然后去配置iterm2，如下图，用绝对路径指向这个文件，后面加上参数。 端口，用户，IP，password。<br>举例：<br><code>/Users/liuzhi/Documents/LinuxServer/liuzhiTX.sh 22 root 123.207.***.202 12345</code></p><p><img src="/images/Mac/iterm2_ssh.png" alt="image"></p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><table><thead><tr><th align="left">Command</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">垂直分屏</td><td align="left">command + d</td></tr><tr><td align="left">水平分屏</td><td align="left">command + shift + d</td></tr><tr><td align="left">切换屏幕</td><td align="left">command + option + 方向键 command + [ 或 command + ]</td></tr><tr><td align="left">查看历史命令</td><td align="left">command + ;</td></tr><tr><td align="left">查看剪贴板历史</td><td align="left">command + shift + h</td></tr><tr><td align="left">新建标签</td><td align="left">command + t</td></tr><tr><td align="left">关闭标签</td><td align="left">command + w</td></tr><tr><td align="left">切换标签</td><td align="left">command + 数字 command + 左右方向键</td></tr><tr><td align="left">切换全屏</td><td align="left">command + enter</td></tr><tr><td align="left">查找</td><td align="left">command + f</td></tr><tr><td align="left">清除当前行</td><td align="left">ctrl + u</td></tr><tr><td align="left">到行首</td><td align="left">ctrl + a</td></tr><tr><td align="left">到行尾</td><td align="left">ctrl + e</td></tr><tr><td align="left">前进后退</td><td align="left">ctrl + f/b (相当于左右方向键)</td></tr><tr><td align="left">上一条命令</td><td align="left">ctrl + p</td></tr><tr><td align="left">搜索命令历史</td><td align="left">ctrl + r</td></tr><tr><td align="left">删除当前光标的字符</td><td align="left">ctrl + d</td></tr><tr><td align="left">删除光标之前的字符</td><td align="left">ctrl + h</td></tr><tr><td align="left">删除光标之前的单词</td><td align="left">ctrl + w</td></tr><tr><td align="left">删除到文本末尾</td><td align="left">ctrl + k</td></tr><tr><td align="left">交换光标处文本</td><td align="left">ctrl + t</td></tr><tr><td align="left">清屏1</td><td align="left">command + r</td></tr><tr><td align="left">清屏2</td><td align="left">ctrl + l</td></tr><tr><td align="left">⌘ + f</td><td align="left">所查找的内容会被自动复制</td></tr><tr><td align="left">⌘ + r</td><td align="left">clear，而且只是换到新一屏，不会想 clear 一样创建一个空屏</td></tr><tr><td align="left">ctrl + u</td><td align="left">清空当前行，无论光标在什么位置</td></tr><tr><td align="left">输入开头命令后 按 ⌘ +</td><td align="left">会自动列出输入过的命令</td></tr><tr><td align="left">⌘ + shift + h</td><td align="left">会列出剪切板历史</td></tr></tbody></table><p>复制：</p><p>选中即复制：iterm2有2种好用的选中即复制模式。</p><p>一种是用鼠标，在iterm2中，选中某个路径或者某个词汇，那么，iterm2就自动复制了。</p><p>另一种是无鼠标模式，command+f，弹出iterm2的查找模式，输入要查找并复制的内容的前几个字母，确认找到的是自己的内容之后，输入tab，查找窗口将自动变化内容，并将其复制。如果输入的是shift+tab（实测好像没用），则自动将查找内容的左边选中并复制。</p><p>输入command+shift+h，iterm2将自动列出剪切板的历史记录，这个历史要使用过无鼠标模式才行</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Util </tag>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Locust测试工具</title>
      <link href="/2018/10/22/Locust/base/"/>
      <url>/2018/10/22/Locust/base/</url>
      
        <content type="html"><![CDATA[<p>locust 是一个简单易用的测试工具。</p><p>官方文档：<a href="https://docs.locust.io/en/stable/what-is-locust.html" target="_blank" rel="noopener">https://docs.locust.io/en/stable/what-is-locust.html</a></p><a id="more"></a><h2 id="文件描述符限制"><a href="#文件描述符限制" class="headerlink" title="文件描述符限制"></a>文件描述符限制</h2><p>如果做高并发测试，操作系统会限制一个进程能够创建的文件描述符上限制，因为每个tcp连接都需要用到一个socket句柄。</p><p><code>ulimit -n 可以查看系统允许当前用户打开的文件数限制</code> <br> <code>ulimit -n 65535 可以修改限制，本次有效果</code></p><p>根据官方文档描述来看，模拟用户数超过能打开的文件数，会出现错误。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>安装locust后，通过编写脚本，然后启动服务，此时通过浏览器端，就可以进行测试了。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python</span><span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-</span><span class="token comment" spellcheck="true"># @Time    : 2018/10/7 下午10:46</span><span class="token comment" spellcheck="true"># @Author  : liuzhi</span><span class="token comment" spellcheck="true"># @File    : locustfile.py</span><span class="token keyword">from</span> locust <span class="token keyword">import</span> HttpLocust<span class="token punctuation">,</span> TaskSet<span class="token punctuation">,</span> task<span class="token keyword">class</span> <span class="token class-name">UserBehavior</span><span class="token punctuation">(</span>TaskSet<span class="token punctuation">)</span><span class="token punctuation">:</span>    @task    <span class="token keyword">def</span> <span class="token function">sleep</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>client<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"/sleep"</span><span class="token punctuation">)</span>    @task    <span class="token keyword">def</span> <span class="token function">woek</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>client<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"/work"</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">WebsiteUser</span><span class="token punctuation">(</span>HttpLocust<span class="token punctuation">)</span><span class="token punctuation">:</span>    task_set <span class="token operator">=</span> UserBehavior    min_wait <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment" spellcheck="true"># 单位 ms 请求等待的最小时间</span>    max_wait <span class="token operator">=</span> <span class="token number">1</span><span class="token comment" spellcheck="true"># 测试server</span><span class="token comment" spellcheck="true"># locust -f test_14.py --host=http://localhost:8888</span>这里配置的host是要去测试的服务地址，Locust服务的地址会在启动信息中打印出来<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码主要有两个类，UserBehavior类两个任务就是模拟当前用户的行为，sleep和work代表本次请求的用户将执行sleep和work操作，可以设置随机或同顺序，或者执行的比重。<br><code>locust --host=http://localhost:8888</code>命令启动locust，8888代表测试服务的端口。</p><h2 id="UI界面描述"><a href="#UI界面描述" class="headerlink" title="UI界面描述"></a>UI界面描述</h2><ul><li>Type：请求类型；</li><li>Name：请求路径；</li><li>requests：当前请求的数量；</li><li>fails：当前请求失败的数量；</li><li>Median：中间值，单位毫秒，一般服务器响应时间低于该值，而另一半高于该值；</li><li>Average：所有请求的平均响应时间，毫秒；</li><li>Min：请求的最小的服务器响应时间，毫秒；</li><li>Max：请求的最大服务器响应时间，毫秒；</li><li>Content Size：单个请求的大小，单位字节；10.reqs/sec：每秒钟请求的个数。</li><li>RPS: 服务器每秒能处理的请求数</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoEngine 官方文档学习笔记</title>
      <link href="/2018/10/22/MongoDB/MongoEngine/"/>
      <url>/2018/10/22/MongoDB/MongoEngine/</url>
      
        <content type="html"><![CDATA[<p>文档<a href="http://docs.mongoengine.org/index.html" target="_blank" rel="noopener">http://docs.mongoengine.org/index.html</a><br>MongoEngine是Python操作MongoDB的ORM封装，可以看到很多ORM框架的影子，比如Django的ORM。底层调用了pymongo。</p><p>基本用法都是创建Document的class，得到class的instance，然后去操作instance。</p><p>MongoDB数据库是文档型的，在一个集合中，每一个文档都可以是不同的结构，不过使用了ORM，查询写入都会受到ORM的限制，当然你应该规范文档的结构。</p><p>ORM提供的功能比较有限，基础操作满足不了的，查pymongo，框架底层是基于pymongo。</p><a id="more"></a><h1 id="Document-instances"><a href="#Document-instances" class="headerlink" title="Document instances"></a>Document instances</h1><h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><p>实例方法，用来做save前操作。</p><h2 id="Cascading-Saves"><a href="#Cascading-Saves" class="headerlink" title="Cascading Saves"></a>Cascading Saves</h2><p>If your document contains ReferenceField or GenericReferenceField objects, then by default the save() method will not save any changes to those objects.<br>如果文档包含ReferenceField或者GenericReferenceField字段，save方法不会保存他们的修改，需要在save(cascade=True)设置，save方法描述：</p><blockquote><p>:param cascade: Sets the flag for cascading saves.  You can set a default by setting “cascade” in the document <strong>meta</strong><br>暂时没有做过测试。</p></blockquote><h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>执行delete，需要有id字段。</p><h2 id="Document-IDs"><a href="#Document-IDs" class="headerlink" title="Document IDs"></a>Document IDs</h2><p>文档要保存了才能访问id，通过情况不需要声明id字段</p><pre class="line-numbers language-s"><code class="language-s">>>> page = Page(title="Test Page")>>> page.id>>> page.save()>>> page.idObjectId('123456789abcdef000000000')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过设置字段的关键字来创建id，这里把email作为id，事实上id是主键的别名，pk == id 是等价的<br>? 修改了默认主键，是不是就不存在唯一表示了，既没有了ObjectId(‘123456789abcdef000000000’)</p><pre class="line-numbers language-s"><code class="language-s">>>> class User(Document):...     email = StringField(primary_key=True)...     name = StringField()...>>> bob = User(email='bob@example.com', name='Bob')>>> bob.save()>>> bob.id == bob.email == 'bob@example.com'True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Querying-the-database"><a href="#Querying-the-database" class="headerlink" title="Querying the database"></a>Querying the database</h1><p>QuerySetManager QuerySet 的概念在MongoEngine中也是适用的。<br>查询集使用本地缓存，如果想返回新的结果，使用no_cache方法。</p><h2 id="Filtering-queries"><a href="#Filtering-queries" class="headerlink" title="Filtering queries"></a>Filtering queries</h2><p>user = User.objects(name=’liu zhi’)</p><h2 id="Query-operators"><a href="#Query-operators" class="headerlink" title="Query operators"></a>Query operators</h2><pre><code>ne – not equal to 不等于lt – less than 小于lte – less than or equal to 小于等于gt – greater than 大于gte – greater than or equal to 大于等于not – negate a standard check, may be used before other operators (e.g. Q(age__not__mod=5)) 否定其它条件，比如查询所有age不在[20, 30]中的 age__not__in=[20, 30]in – value is in list (a list of values should be provided)nin – value is not in list (a list of values should be provided)mod – value % x == y, where x and y are two provided valuesall – every item in list of values provided is in arraysize – the size of the array isexists – value for field exists</code></pre><h3 id="String-queries"><a href="#String-queries" class="headerlink" title="String queries"></a>String queries</h3><p>The following operators are available as shortcuts to querying with regular expressions:</p><pre><code>exact – string field exactly matches valueiexact – string field exactly matches value (case insensitive)contains – string field contains valueicontains – string field contains value (case insensitive)startswith – string field starts with valueistartswith – string field starts with value (case insensitive)endswith – string field ends with valueiendswith – string field ends with value (case insensitive)match – performs an $elemMatch so you can match an entire document within an array</code></pre><h3 id="Geo-queries-特定字段扩展的查询"><a href="#Geo-queries-特定字段扩展的查询" class="headerlink" title="Geo queries(特定字段扩展的查询)"></a>Geo queries(特定字段扩展的查询)</h3><p>PointField, LineStringField and PolygonField字段增加了特殊的查询方法，详情看文档。</p><h3 id="Querying-lists-查询list字段的扩展"><a href="#Querying-lists-查询list字段的扩展" class="headerlink" title="Querying lists(查询list字段的扩展)"></a>Querying lists(查询list字段的扩展)</h3><h3 id="Raw-queries-pymongo查询"><a href="#Raw-queries-pymongo查询" class="headerlink" title="Raw queries(pymongo查询)"></a>Raw queries(pymongo查询)</h3><p>使用pyMongo的原生查询，document.objects(<strong>raw</strong>={‘name’: ‘liuzhi’})</p><h3 id="Limiting-and-skipping-results"><a href="#Limiting-and-skipping-results" class="headerlink" title="Limiting and skipping results"></a>Limiting and skipping results</h3><p>使用切片实现原生db.document.find().limit().skip()，get，first方法，get是检索唯一结果，如果有多个结果匹配，会触发MultipleObjectsReturned异常。get_or_create()已经弃用，最好不要使用，由于没有事务的原因，它不是安全的。</p><h3 id="Default-Document-queries-扩展模型管理器"><a href="#Default-Document-queries-扩展模型管理器" class="headerlink" title="Default Document queries(扩展模型管理器)"></a>Default Document queries(扩展模型管理器)</h3><p>相当于对objects重写，使用特定的装饰器，方法名字可以自定义，这样可以做到使用原始的查询原始数据，使用自定义，查询自定义数据，比如自定义的只查询状态是正常的。</p><pre><code>class BlogPost(Document):    title = StringField()    date = DateTimeField()    @queryset_manager    def objects(doc_cls, queryset):        # This may actually also be done by defining a default ordering for        # the document, but this illustrates the use of manager methods        return queryset.order_by('-date')</code></pre><h3 id="Custom-QuerySets-封装查询集方法"><a href="#Custom-QuerySets-封装查询集方法" class="headerlink" title="Custom QuerySets(封装查询集方法)"></a>Custom QuerySets(封装查询集方法)</h3><p>把某些特定查询条件组合，通过新的方法获取查询集，可以给多个文档模型使用。</p><pre><code>class AwesomerQuerySet(QuerySet):    def get_awesome(self):        return self.filter(awesome=True)class Page(Document):    meta = {'queryset_class': AwesomerQuerySet}# To call:Page.objects.get_awesome()</code></pre><h3 id="Aggregation"><a href="#Aggregation" class="headerlink" title="Aggregation"></a>Aggregation</h3><p>MongoDB的聚合方法<br>objects 方法</p><ul><li>count() 返回QuerySet() 数目</li><li>sun(‘quantitu’) 求和</li><li>average() 求平均</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Python </tag>
            
            <tag> DataBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB NoSQL 数据库</title>
      <link href="/2018/10/22/MongoDB/MongoDB/"/>
      <url>/2018/10/22/MongoDB/MongoDB/</url>
      
        <content type="html"><![CDATA[<p>MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p><a id="more"></a><h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><p><img src="/images/mongodb/MongoDB.png" alt="image"></p><h2 id="ObjectID字段"><a href="#ObjectID字段" class="headerlink" title="ObjectID字段"></a>ObjectID字段</h2><p><code>ObjectId</code>构成我们使用<code>MySQL</code>等关系型数据库时，主键都是设置成自增的。但在分布式环境下，这种方法就不可行了，会产生冲突。为此，<code>MongoDB</code>采用了一个称之为<code>ObjectId</code>的类型来做主键。<code>ObjectId</code>是一个12字节的<code>BSON</code>类型字符串。按照字节顺序，依次代表：</p><ul><li>4字节：UNIX时间戳</li><li>3字节：表示运行MongoDB的机器</li><li>2字节：表示生成此_id的进程</li><li>3字节：由一个随机数开始的计数器生成的值</li></ul><p><code>MongoDB</code>对<code>ObjectId</code>对象提供了<code>getTimestamp()</code>方法来获取<code>ObjectId</code>的时间。</p><p>这里不使用自增长<code>id</code>主要是因为<code>MongoDB</code>是分布式数据库，在并发插入的时候需要维护全局的唯一ID，传统的像MySQL是单机版的，使用自增长ID可以了，处理多条数据插入加锁就行了，虽然MySQL也可以部署集群，但是这种情况ID就没用了，需要自定义全局唯一字段。</p><p><code>ObjectID</code>是字段类型，通常来说它是按照默认规则来生产的，文档中的其它字段也可以使用这种字段类型。</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><ul><li>查询全部：<code>db.document.find({})</code></li><li>查询字段是对象的：<code>db.document.find({'id_card.idcard_type': '身份证'})</code></li></ul><h3 id="projection"><a href="#projection" class="headerlink" title="projection"></a>projection</h3><p>该参数指明要显示的字段或者要隐藏的字段</p><ul><li><code>db.document.find({}, {'name':1})</code>  返回结果只显示name字段</li><li><code>db.document.find({}, {'name':0})</code>  返回结果把name字段隐藏了，其它展示出来</li></ul><h2 id="内嵌文档"><a href="#内嵌文档" class="headerlink" title="内嵌文档"></a>内嵌文档</h2><p>见文档</p><h2 id="数据库引用"><a href="#数据库引用" class="headerlink" title="数据库引用"></a>数据库引用</h2><p>分为手动引用和DBRefs，手动引用就是自己建立关系，然后查多次或关联查询。</p><p>使用方法：</p><ul><li>$ref：集合名称</li><li>$id：引用的id</li><li>$db:数据库名称，可选参数</li></ul><p>产品document中引用attr_data，attr_data是产品属性document</p><pre class="line-numbers language-py"><code class="language-py">from collections import namedtuplePoint = namedtuple('Point', ['x', 'y'])p = Point(11, 22)x, y = pprint(x, y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">{</span>       <span class="token string">"_id"</span><span class="token punctuation">:</span><span class="token function">ObjectId</span><span class="token punctuation">(</span><span class="token string">"53402597d852426020000002"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token string">"product_name"</span><span class="token punctuation">:</span> <span class="token string">"卫龙辣条"</span><span class="token punctuation">,</span>    <span class="token string">"attr_data"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token string">"$ref"</span><span class="token punctuation">:</span> <span class="token string">"product_attr"</span><span class="token punctuation">,</span>        <span class="token string">"$id"</span><span class="token punctuation">:</span> <span class="token function">ObjectId</span><span class="token punctuation">(</span><span class="token string">"534009e4d852427820000002"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token string">"$db"</span><span class="token punctuation">:</span> <span class="token string">"testdata"</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>product_attr document</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>   <span class="token property">"_id"</span> <span class="token operator">:</span> ObjectId(<span class="token string">"534009e4d852427820000002"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>   <span class="token property">"size"</span><span class="token operator">:</span> <span class="token string">"大"</span><span class="token punctuation">,</span>   <span class="token property">"weight"</span><span class="token operator">:</span> <span class="token string">"100g"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查询</p><pre class="line-numbers language-sh"><code class="language-sh">var product = db.products.findOne({"product_name":"卫龙辣条"})var dbRef = product.attr_datadb[dbRef.$ref].findOne({"_id":(dbRef.$id)})结果：{   "_id" : ObjectId("534009e4d852427820000002"),   "size": "大",   "weight": "100g"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>mongodb不支持事务，所以，在你的项目中应用时，要注意这点。无论什么设计，都不要要求mongodb保证数据的完整性。</p><p>但是mongodb提供了许多原子操作，比如文档的保存，修改，删除等，都是原子操作。</p><p>所谓原子操作就是要么这个文档保存到Mongodb，要么没有保存到Mongodb，不会出现查询到的文档没有保存完整的情况。</p><h3 id="findAndModify方法"><a href="#findAndModify方法" class="headerlink" title="findAndModify方法"></a>findAndModify方法</h3><p>该方法将查询一些结果，如果查询到，执行更新。这些语句都是写在一个查询中的，并且使用对应的原子操作方法，让整个findAndModify实现原子性操作。<br>如果分开操作，就是先查询，再修改，在这两个操作之间，如果有人购买了产品，导致库存不足，那么修改操作就会导致数据库数据一致性问题。</p><pre><code>book = {          _id: 123456789,          title: "MongoDB: The Definitive Guide",          author: [ "Kristina Chodorow", "Mike Dirolf" ],          published_date: ISODate("2010-09-24"),          pages: 216,          language: "English",          publisher_id: "oreilly",          available: 3,          checkout: [ { by: "joe", date: ISODate("2012-10-15") } ]        }</code></pre><p>对于上述的book模型，available是我们的判别标志，当它大于0的时候，说明是可以操作的(比如借书)，这部分就是查询，查询成功了，就可以去执行要更新的操作。<br>db.document.findAndModify({<br>    query: {},<br>    update: {}<br>})<br>更新操作应该使用原子操作命令</p><p> $set:用来指定一个键并更新键值，若键不存在并创建。</p><p>{ $set : { field : value } }<br>  $unset:用来删除一个键</p><p>{ $unset : { field : 1} }<br>  $inc:可以对文档的某个值为数字型的键进行增减操作 </p><p>{ $inc : { field : value } }<br>  $push：把value追加到field里面去，field一定要是数组类型才行，如果field不存在，会新增一个数据类型加进去。</p><p>{ $push : { field : value } }<br>  $pushAll:同$push,只是一次可以追加到多个值到一个数组字段内。</p><p>{ $pushAll : { field : value_array } }<br>  $pull:从数组field内删除一个等于value值</p><p>{ $pull : { field : _value } }<br>  $addToSet：增加一个值到数组内，而且只有当这个值不在数组内才增加。<br>  $pop：删除数组的第一个或最后一个元素<br>{ $pop : { field : 1 } }<br>  $rename：修改字段名称<br>{ $rename : { old_field_name : new_field_name } }<br>  $bit：位操作，integer类型<br>{$bit : { field : {and : 5}}}<br>  偏移操作符</p><blockquote><p>t.find() { “_id” : ObjectId(“4b97e62bf1d8c7152c9ccb74”), “title” : “ABC”, “comments” : [ { “by” : “joe”, “votes” : 3 }, { “by” : “jane”, “votes” : 7 } ] }</p></blockquote><blockquote><p>t.update( {‘comments.by’:’joe’}, {$inc:{‘comments.$.votes’:1}}, false, true )</p></blockquote><blockquote><p>t.find() { “_id” : ObjectId(“4b97e62bf1d8c7152c9ccb74”), “title” : “ABC”, “comments” : [ { “by” : “joe”, “votes” : 4 }, { “by” : “jane”, “votes” : 7 } ] }</p></blockquote><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>MongoDB通过索引加快查询速度，索引运行在内存中，数据库的操作也需要对索引进行操作，索引超过内存的情况，将会删除一些索引。最好只对大数据文档创建索引。</p><p>索引不能被以下的查询使用：</p><ul><li>正则表达式及非操作符，如 $nin, $not, 等</li><li>算术运算符，如 $mod, 等</li><li>$where 子句</li></ul><p>所以，检测你的语句是否使用索引是一个好的习惯，可以用explain来查看。</p><h3 id="最大范围"><a href="#最大范围" class="headerlink" title="最大范围"></a>最大范围</h3><ul><li>集合中索引不能超过64个</li><li>索引名的长度不能超过128个字符</li><li>一个复合索引最多可以有31个字段</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> DataBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqlAlchemy-query 常见操作总结</title>
      <link href="/2018/10/22/MySql/sqlAlchemy-query/"/>
      <url>/2018/10/22/MySql/sqlAlchemy-query/</url>
      
        <content type="html"><![CDATA[<p>MySQL 的 Python 版 ORM</p><a id="more"></a><h1 id="sqlAlchemy-数据库操作"><a href="#sqlAlchemy-数据库操作" class="headerlink" title="sqlAlchemy 数据库操作"></a>sqlAlchemy 数据库操作</h1><p>sqlAlchemy提供了数据库的很多封装</p><h2 id="模型创建"><a href="#模型创建" class="headerlink" title="模型创建"></a>模型创建</h2><p>模型需要继承 <code>db.Model</code> ，db.Colum类描述table的字段，<code>__tablename__</code> 描述table在数据库中的名称，不写默认为类名。<br><code>__table_args__</code> 创建数据库是时附加语句，有点像sql脚本的语句，下面的 <code>db.Index('idx_commit_item', target_id, target_kind, user_id)</code> 翻译成sql语句就是 <code>create index idx_commit_item on collect_items (target_id, target_kind, user_id);</code></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">CommentItem</span><span class="token punctuation">(</span>db<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>    __tablename__ <span class="token operator">=</span> <span class="token string">'comment_items'</span>    user_id <span class="token operator">=</span> db<span class="token punctuation">.</span>Column<span class="token punctuation">(</span>db<span class="token punctuation">.</span>Integer<span class="token punctuation">)</span>    target_id <span class="token operator">=</span> db<span class="token punctuation">.</span>Column<span class="token punctuation">(</span>db<span class="token punctuation">.</span>Integer<span class="token punctuation">)</span>    target_kind <span class="token operator">=</span> db<span class="token punctuation">.</span>Column<span class="token punctuation">(</span>db<span class="token punctuation">.</span>Integer<span class="token punctuation">)</span>    __table_args__ <span class="token operator">=</span> <span class="token punctuation">(</span>        db<span class="token punctuation">.</span>Index<span class="token punctuation">(</span><span class="token string">'idx_commit_item'</span><span class="token punctuation">,</span> target_id<span class="token punctuation">,</span> target_kind<span class="token punctuation">,</span> user_id<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>__abstract__ = True</code> 模型设置了该值，说明该模型是抽象基类，不会被创建数据库<br><code>extend_existing = True</code> 重定义表结构</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>filter 和 filter_by 的区别：</p><p><code>q = Moedl.query.filter_by(id=1)</code><br><code>q = Model.query.filter(Model.id == 1)</code></p><p>一般来说，查询单体结果，使用 <code>filter_by</code>，而 <code>filter</code> 可以配合复杂的查询来使用</p><p><code>q = Model.query.with_entities(Model.id, Model.name, Model.age).filter(Model.state == '1')</code></p><p>为了连表查询，使用 <code>db.session.query(Model, User)</code> 的形式，和 <code>Model.query</code> 的形式接近，就是需要把查询模型写入query中，其它关于filter或with_entities的方法都是类似的。</p><blockquote><p>连表查询可能会伴随重复的数据，需要注意</p></blockquote><h2 id="查询集的操作"><a href="#查询集的操作" class="headerlink" title="查询集的操作"></a>查询集的操作</h2><p>对于 <code>q = Model.query.filter(Model.id == 1)</code> 是还没有操作数据库的，执行 <code>q.all()</code> 拿到所有的查询结果，<code>q.first()</code> 获取第一个，类似的方法可以参考文档。</p><h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><p>C是指create新增，R是指retrieve检索，U是指update更改，D是指delete删除，一般用的最多的就是查询操作，其它操作基本使用如下：</p><p>C(create新增)：</p><pre class="line-numbers language-python"><code class="language-python">db<span class="token punctuation">.</span>session<span class="token punctuation">.</span>add<span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># self 为模型对象的实例</span>db<span class="token punctuation">.</span>session<span class="token punctuation">.</span>commit<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 修改数据库操作记得提交事务</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>U(update更改)：</p><pre class="line-numbers language-python"><code class="language-python">kwargs <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true"># 需要修改的数据字典</span><span class="token keyword">for</span> attr<span class="token punctuation">,</span> value <span class="token keyword">in</span> kwargs<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        setattr<span class="token punctuation">(</span>self<span class="token punctuation">,</span> attr<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 将值修改到查询实例 self 上</span>    db<span class="token punctuation">.</span>session<span class="token punctuation">.</span>add<span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># self 为模型对象的实例</span>    db<span class="token punctuation">.</span>session<span class="token punctuation">.</span>commit<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 修改数据库操作记得提交事务</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>D(delete删除)：</p><pre class="line-numbers language-python"><code class="language-python">db<span class="token punctuation">.</span>session<span class="token punctuation">.</span>delete<span class="token punctuation">(</span>self<span class="token punctuation">)</span>db<span class="token punctuation">.</span>session<span class="token punctuation">.</span>commit<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>查询操作，返回查询结果，参数必须是主键<br><code>model = Model.query.get(2)</code></p><h2 id="count"><a href="#count" class="headerlink" title="count"></a>count</h2><p>对查询集使用，返回查询数目合计</p><h2 id="filter-查询条件"><a href="#filter-查询条件" class="headerlink" title="filter 查询条件"></a>filter 查询条件</h2><ol><li><p>notin_ 和 in_<br>q = Model.query.filter(Model.id.in_([1, 2, 3]))</p></li><li><p>or_ 和 and_<br>q = Model.query.filter(or_(Model.id == 1, Model.id == 3))</p></li><li><p>like<br>q = Model.query.filter(Model.name.like(‘%’ + ‘python’ + ‘%’))</p></li><li><p>between<br>q = Model.query.filter(Model.age.between(10, 18))</p></li></ol><h2 id="order-by"><a href="#order-by" class="headerlink" title="order_by"></a>order_by</h2><p>对查询集来使用，<code>q = Model.query.filter(Model.id.in_([1, 2, 3])).order_by(Post.id.desc())</code><br>配合参数的形式</p><pre class="line-numbers language-python"><code class="language-python">eval<span class="token punctuation">(</span><span class="token string">'db.%s(func.length(MemberIntegralSetting.%s))'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>sortOrder<span class="token punctuation">,</span> sort<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>eval<span class="token punctuation">(</span><span class="token string">'MemberIntegralSetting.%s.%s()'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>sort<span class="token punctuation">,</span> sortOrder<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>转换字符串类型，或者用func函数</p><pre class="line-numbers language-python"><code class="language-python">upgrade_value_order_by <span class="token operator">=</span> <span class="token string">'(MemberCardSetting.upgrade_value + 0)'</span>eval<span class="token punctuation">(</span><span class="token string">'%s.%s()'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>upgrade_value_order_by<span class="token punctuation">,</span> sortOrder<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="offset-和-limit"><a href="#offset-和-limit" class="headerlink" title="offset 和 limit"></a>offset 和 limit</h2><p>对查询集取范围，offset决定了起始位，比如User有10条数据，<code>User.query.offset(2).all()</code> 返回 id是3到10的数据。<br>limit截取多少，<code>User.query.offset(2).limit(3).all()</code> 表示从id是3的数6条数据，即返回3到8的数据。</p><p>对于查询集可以使用切片的方式，但是这将查询所有的数据利用切片来获取，和原生语句有效率上的区别的，需要注意。</p><h2 id="with-entities"><a href="#with-entities" class="headerlink" title="with_entities"></a>with_entities</h2><p>用于直接获取查询字段的值（不然会查出所有字段，浪费资源），很方便，配合fun函数等，可以直接转换特定对象</p><p>需要用到的函数先导入<br><code>from sqlalchemy import or_, func, extract, and_, cast, FLOAT, CHAR</code></p><p>例子：</p><p>先定义一个集合</p><pre class="line-numbers language-python"><code class="language-python">with_entities_field <span class="token operator">=</span> <span class="token punctuation">{</span>    func<span class="token punctuation">.</span>count<span class="token punctuation">(</span>User<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span>label<span class="token punctuation">(</span><span class="token string">'sum_count'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># 计算User的总数，并添加新的标签sum_count</span>    func<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>User<span class="token punctuation">.</span>recharge_value<span class="token punctuation">)</span><span class="token punctuation">.</span>label<span class="token punctuation">(</span><span class="token string">'sum_recharge_value'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># 求和</span>    User<span class="token punctuation">.</span>type <span class="token comment" spellcheck="true"># 通常情况</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python">user <span class="token operator">=</span> User<span class="token punctuation">.</span>query<span class="token punctuation">.</span>with_entities<span class="token punctuation">(</span>with_entities_field<span class="token punctuation">)</span><span class="token punctuation">.</span>filter<span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">.</span>all<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>除了func函数，还有cast函数，用来转换类型</p><ol><li>整形数据转换成字符串<br><code>cast(FoodOrderInfo.product_count, CHAR).label('product_count')</code></li><li>时间对象转换成字符串<br><code>cast(FoodOrderInfo.create_time, CHAR).label('create_time')</code> </li></ol><h2 id="subquery"><a href="#subquery" class="headerlink" title="subquery"></a>subquery</h2><pre class="line-numbers language-python"><code class="language-python">merchant_info_subquery <span class="token operator">=</span> db<span class="token punctuation">.</span>session<span class="token punctuation">.</span>query<span class="token punctuation">(</span>            MerchantInfo<span class="token punctuation">.</span>merchant_code<span class="token punctuation">,</span>            MerchantInfo<span class="token punctuation">.</span>merchant_name        <span class="token punctuation">)</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>            SysOrg<span class="token punctuation">,</span> and_<span class="token punctuation">(</span>                SysOrg<span class="token punctuation">.</span>org_code<span class="token punctuation">.</span>like<span class="token punctuation">(</span>org_code <span class="token operator">+</span> <span class="token string">'%'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                SysOrg<span class="token punctuation">.</span>org_id <span class="token operator">==</span> MerchantInfo<span class="token punctuation">.</span>org_id            <span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token punctuation">.</span>group_by<span class="token punctuation">(</span>MerchantInfo<span class="token punctuation">.</span>merchant_code<span class="token punctuation">)</span><span class="token punctuation">.</span>subquery<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="批量插入（非orm方式）"><a href="#批量插入（非orm方式）" class="headerlink" title="批量插入（非orm方式）"></a>批量插入（非orm方式）</h2><pre class="line-numbers language-py"><code class="language-py"># MemberCouponRecord 为要操作的表名db.session.execute(    MemberCouponRecord.__table__.insert(),    [{'coupon_id': 'NO0001', 'member_id': 0002, 'update_time': get_current_time(), 'create_by': get_op_user_name()} for item in item_data])db.session.commit()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Python </tag>
            
            <tag> DataBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL install-problem</title>
      <link href="/2018/10/22/MySql/install-problem/"/>
      <url>/2018/10/22/MySql/install-problem/</url>
      
        <content type="html"><![CDATA[<p>安装MySQL遇到的问题</p><a id="more"></a><h1 id="安装遇到的问题"><a href="#安装遇到的问题" class="headerlink" title="安装遇到的问题"></a>安装遇到的问题</h1><p>安装软件总会遇到很多问题，很多问题仅在当时情况下出现，其实解决的思路都是大致的，多看报错和官方文档。</p><h2 id="mysql-sock-无法被创建"><a href="#mysql-sock-无法被创建" class="headerlink" title="mysql.sock 无法被创建"></a>mysql.sock 无法被创建</h2><p>mysql 的链接需要借助这个套接字，如果不小心删除了，会导致服务无法运行</p><p>mac mysql 8.0.12安装教程</p><p>本次中Mac上使用非root账户来安装mysql，终于装好了。主要原因在于8.0版本配置（说是没有配置，但还说有，通过brew安装的可以在 /usr/local/etc 目录下找到配置文件，linux包管理软件安装的东西一般都在这个目录）没有配置东西，用的是默认的，这导致要创建链接的socket的时候没有指定目录使用了默认的 /tmp，没有执行/tmp的权限或者是用户所属等问题导致创建失败（并不是很建议去操作这个文件，有些人直接运行成功了，可能和个人的系统有很大关系）。无法创建mysql服务</p><p>大概解决思路<br>mysql安装会在data目录下生成很多东西，如果没有或生成的不对，可以把目录删除了，通过启动服务来生成（我就说这么干的），然后配置了socket的客户端和服务端的路径，路径指向data即可（以为mysql的data是有执行权限的），这样服务就启动成功了，然后安装brew指导，创建root用户。</p><p>配置</p><pre class="line-numbers language-s"><code class="language-s">[client]socket=/usr/local/lnmp/mysql/data/mysql.sock[mysqld]socket=/usr/local/lnmp/mysql/data/mysql.sock<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>两个都要指定</p><p>mysql.sock 无法创建，问题可能是多方面的，在data目录下，会生成 .err后缀的文件，可以在里面查看错误信息，然后结合经验来解决问题。  还有就是data目录下数据不对，这个目录应该有很多文件的，但是我一直没有，我通过删除，再执行服务成功生成了，感觉并不是很正确的解决思路。</p><p>mysqld –help –verbose | less<br>这个目录可以列出mysql的一些信息，包括配置文件可能的路径，一些已经配置的参数。</p><p>最后，使用编译源代码的方式，估计是最后的活路。</p><h2 id="报错：MySQL-Illegal-mix-of-collations-for-operation-‘like’"><a href="#报错：MySQL-Illegal-mix-of-collations-for-operation-‘like’" class="headerlink" title="报错：MySQL Illegal mix of collations for operation ‘like’"></a>报错：MySQL Illegal mix of collations for operation ‘like’</h2><p>MySQL Illegal mix of collations for operation ‘like’</p><p>在 MySQL 5.5 以上, 若字段类型 Type 是 time,date,datetime </p><p>在 select时如果使用 like ‘%中文%’ 会出现 Illegal mix of collations for operation ‘like’</p><p>在编程时要对每个字段进行查找，在执行时可能就会出现时间字段 like ‘%中文%’ 这种语法，在旧版的 MySQL 是不会出现错误的。</p><p>升到 MySQL 5.5 以上, 必需改成 like binary ‘%中文%’ 即可避免出现错误。</p><p>在python代码中，解决方案为使用cast(fields, CHAR)转换类型后再做like.(高mysql版本中使用like的使用，非字符类型和字符类型混合在filter条件中做like，就会导致这个问题)</p><h2 id="mac-python2-7-安装-Mysql-python"><a href="#mac-python2-7-安装-Mysql-python" class="headerlink" title="mac python2.7 安装 Mysql-python"></a>mac python2.7 安装 Mysql-python</h2><p>Mac安装Mysql-python遇到的坑，被这俩报错反复摩擦：’my_config.h’ file not found 和 IndexError: string index out of range</p><pre><code>brew install mysqlbrew unlink mysqlbrew install mysql-connector-csed -i -e 's/libs="$libs -l "/libs="$libs -lmysqlclient -lssl -lcrypto"/g' /usr/local/bin/mysql_configpip install MySQL-pythonbrew unlink mysql-connector-cbrew link --overwrite mysql</code></pre><p>解决参考<a href="https://stackoverflow.com/questions/12218229/my-config-h-file-not-found-when-intall-mysql-python-on-osx-10-8/12233148" target="_blank" rel="noopener">Stackoverflow</a></p><p>如果MySQL安装了，那么安装mysql-connector-c后，执行 <code>sed -i -e 's/libs="$libs -l "/libs="$libs -lmysqlclient -lssl -lcrypto"/g' /usr/local/bin/mysql_config</code> 差不多就可以安装成功了。</p><p>本质就是读取配置文件错误，通过文本替换命令sed修改配置。</p><h2 id="解决Access-denied-for-user-‘’-’localhost’-to-database-‘mysql"><a href="#解决Access-denied-for-user-‘’-’localhost’-to-database-‘mysql" class="headerlink" title="解决Access denied for user ‘’@’localhost’ to database ‘mysql"></a>解决Access denied for user ‘’@’localhost’ to database ‘mysql</h2><p>Access denied for user ‘’@’localhost’ to database ‘</p><p>出现原因是MySQL的密码有问题，使用yum安装的时候，没设置密码进入交互环境后不能创建用户</p><p>用mysql匿名用户可以进入数据库，但是看不见mysql数据库.</p><p>解决办法：</p><p>具体操作步骤：</p><p>关闭mysql:</p><ol><li>service mysqld stop</li></ol><p>然后:</p><ol start="2"><li>mysqld_safe –skip-grant-tables</li></ol><p>启动mysql:</p><ol start="3"><li>service mysqld start</li></ol><p>mysql -u root</p><p>mysql&gt; use mysql</p><p>mysql&gt; UPDATE user SET Password=PASSWORD(‘xxx’) WHERE user=’root’;</p><p>mysql&gt; flush privileges;</p><p>到这里密码已经修改成功，</p><p>mysql -u root -p</p><p>mysql -udbappwgs -p -h127.0.0.1 有些时候要知道host才能连接上</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> DataBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flask 框架学习笔记</title>
      <link href="/2018/10/22/Python/Flask/"/>
      <url>/2018/10/22/Python/Flask/</url>
      
        <content type="html"><![CDATA[<p>Flask框架学习笔记</p><p>Flask 也是Python web 开发中很重要的框架，相比Django来说，它体现在一个“微型”上，只提供核心功能，其余功能由模块来扩展。拥有很强大的灵活性，通过核心来不断的扩展实现需求。</p><a id="more"></a><h1 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h1><p><img src="/images/Python/Flask.png" alt="image"></p><h2 id="关于扩展"><a href="#关于扩展" class="headerlink" title="关于扩展"></a>关于扩展</h2><p>通过安装对应的扩展包，可以扩展框架的很多功能（这些扩展和框架会有结合，有点想开启框架的功能一样），Flask的扩展都暴露在flask.ext命名空间下，你可以在环境中通过pip安装好相应扩展，然后再在程序中导入相应的包即可使用扩展。</p><p>在新的版本中，引入flask扩展不能再从flask.ext导入了，直接从安装模块导入，比如 <code>from flask_sqlalchemy import SQLAlchemy</code></p><h2 id="自定义url转换器"><a href="#自定义url转换器" class="headerlink" title="自定义url转换器"></a>自定义url转换器</h2><p>在路由中，使用&lt;&gt;来获取动态参数，默认是字符串类型的，如果想要指定参数类型，需要标记成<code>&lt;converter:variable_name&gt;</code> 这样的格式，类似 <code>&lt;int:quantity&gt;</code>，使用any可以指定多种路径，类似<code>&lt;any(a, b:page_name)&gt;</code>。像any，int做为类型可以自定义，比如定义list类型，代码如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> urllib <span class="token keyword">import</span> parse<span class="token keyword">from</span> flask <span class="token keyword">import</span> Flask<span class="token keyword">from</span> werkzeug<span class="token punctuation">.</span>routing <span class="token keyword">import</span> BaseConverterapp <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">ListConverter</span><span class="token punctuation">(</span>BaseConverter<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> url_map<span class="token punctuation">,</span> separator<span class="token operator">=</span><span class="token string">'+'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        super<span class="token punctuation">(</span>ListConverter<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>url_map<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>separator <span class="token operator">=</span> parse<span class="token punctuation">.</span>unquote<span class="token punctuation">(</span>separator<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># unquote 对url进行解码</span>    <span class="token keyword">def</span> <span class="token function">to_python</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> value<span class="token punctuation">.</span>split<span class="token punctuation">(</span>self<span class="token punctuation">.</span>separator<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">to_url</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> values<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>separator<span class="token punctuation">.</span>join<span class="token punctuation">(</span>BaseConverter<span class="token punctuation">.</span>to_url<span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span>                                <span class="token keyword">for</span> value <span class="token keyword">in</span> values<span class="token punctuation">)</span>app<span class="token punctuation">.</span>url_map<span class="token punctuation">.</span>converters<span class="token punctuation">[</span><span class="token string">'list'</span><span class="token punctuation">]</span> <span class="token operator">=</span> ListConverter@app<span class="token punctuation">.</span>route<span class="token punctuation">(</span><span class="token string">'/list1/&lt;list:page_names>/'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">list1</span><span class="token punctuation">(</span>page_names<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>page_names<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token string">'Separator: {} {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">'+'</span><span class="token punctuation">,</span> page_names<span class="token punctuation">)</span>@app<span class="token punctuation">.</span>route<span class="token punctuation">(</span><span class="token string">'/list2/&lt;list(separator=u"|"):page_names>/'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">list2</span><span class="token punctuation">(</span>page_names<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token string">'Separator: {} {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">'|'</span><span class="token punctuation">,</span> page_names<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    app<span class="token punctuation">.</span>run<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">'0.0.0.0'</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">9000</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="唯一url"><a href="#唯一url" class="headerlink" title="唯一url"></a>唯一url</h2><p>在路由的装饰器中，如果指定了结尾的反斜杠，类似这样的路径 <code>\page\</code>，那么浏览器访问地址以反斜杠结尾，或者没有反斜杠都可以访问(访问一个不以反斜杠结尾的url会被重定向到到反斜杠的url上)，如果路由是<code>\page</code>，那么浏览器访问以反斜杠结尾会报错。</p><h2 id="扩展响应"><a href="#扩展响应" class="headerlink" title="扩展响应"></a>扩展响应</h2><p>这是一个很常见的需求，对返回对象进行包装，比如返回一个ORM的查询实例，这个是不能被json序列化的，通过扩展返回数据，可以对特定对象进行处理。另一种情况，是重写响应类，<code>app.response = JSONResponse</code></p><h2 id="静态文件管理"><a href="#静态文件管理" class="headerlink" title="静态文件管理"></a>静态文件管理</h2><p>在创建flask实例的时候，通过static_folder修改默认静态文件路径，<code>Flask(__name__, static_folder='/tmp')</code></p><h2 id="关于视图"><a href="#关于视图" class="headerlink" title="关于视图"></a>关于视图</h2><p>通常使用函数视图，但是这样就发挥不出类的作用了，比如继承一个基类，定义一些基础的东西，flask也可以使用基于类的视图</p><h3 id="标准类视图"><a href="#标准类视图" class="headerlink" title="标准类视图"></a>标准类视图</h3><p>标准类视图是继承自 <code>flask.views.View</code>，并且在子类中必须实现 <code>dispatch_request</code> 方法，这个方法类似于视图函数，也要返回一个基于Response或者其子类的对象。通过 <code>app.add_url_rule(url_rule, view_func)</code> 来进行注册</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> flask<span class="token punctuation">.</span>views <span class="token keyword">import</span> View<span class="token keyword">class</span> <span class="token class-name">PersonalView</span><span class="token punctuation">(</span>View<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">dispatch_request</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"hello"</span>app<span class="token punctuation">.</span>add_url_rule<span class="token punctuation">(</span><span class="token string">'/users/'</span><span class="token punctuation">,</span>view_func<span class="token operator">=</span>PersonalView<span class="token punctuation">.</span>as_view<span class="token punctuation">(</span><span class="token string">'personalview'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="基于调度方法的视图"><a href="#基于调度方法的视图" class="headerlink" title="基于调度方法的视图"></a>基于调度方法的视图</h3><p>继承自 <code>flask.views.MethodView</code>，可以对不同的HTTP方法执行对应的函数，使用方法的小写名。在类视图中定义一个属性叫做decorators，然后存储装饰器。以后每次调用这个类视图的时候，就会执行这个装饰器</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> flask <span class="token keyword">import</span> Flask<span class="token punctuation">,</span> jsonify<span class="token keyword">from</span> flask<span class="token punctuation">.</span>views <span class="token keyword">import</span> MethodView<span class="token keyword">from</span> flask <span class="token keyword">import</span> sessionapp <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">login_required</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> session<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"user_id"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">'auth failure'</span>        <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>    <span class="token keyword">return</span> wrapper<span class="token keyword">class</span> <span class="token class-name">UserAPI</span><span class="token punctuation">(</span>MethodView<span class="token punctuation">)</span><span class="token punctuation">:</span>    decorators <span class="token operator">=</span> <span class="token punctuation">[</span>login_required<span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> jsonify<span class="token punctuation">(</span><span class="token punctuation">{</span>            <span class="token string">'username'</span><span class="token punctuation">:</span> <span class="token string">'fake'</span><span class="token punctuation">,</span>            <span class="token string">'avatar'</span><span class="token punctuation">:</span> <span class="token string">'http://lorempixel.com/100/100/nature/'</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">post</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">'UNSUPPORTED!'</span>app<span class="token punctuation">.</span>add_url_rule<span class="token punctuation">(</span><span class="token string">'/user'</span><span class="token punctuation">,</span> view_func<span class="token operator">=</span>UserAPI<span class="token punctuation">.</span>as_view<span class="token punctuation">(</span><span class="token string">'userview'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    app<span class="token punctuation">.</span>run<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">'0.0.0.0'</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">9000</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用命令行接口"><a href="#使用命令行接口" class="headerlink" title="使用命令行接口"></a>使用命令行接口</h2><p>和Django一样，flask框架也提供了很多命令，flask命令需要添加都环境变量，这个一般在安装后就有了。然后需要设置flask应用的环境变量，可以使用 <code>export FLASK_APP='app.py path'</code> 。</p><p>也可以自定义命令，比如 <code>flask run_test</code> 执行一个测试脚本，代码如下：</p><pre class="line-numbers language-python"><code class="language-python">@app<span class="token punctuation">.</span>cli<span class="token punctuation">.</span>command<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">run_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'this is a test script'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>理解请求上下文和应用上下文。</p><h2 id="werkzeug"><a href="#werkzeug" class="headerlink" title="werkzeug"></a>werkzeug</h2><p>WSGI 协议工具集</p><h2 id="配置参数讲解"><a href="#配置参数讲解" class="headerlink" title="配置参数讲解"></a>配置参数讲解</h2><p>创建app需要传递配置参数，以供各个模块使用</p><p>SECRET_KEY：密码加盐的参数，推荐设置成系统变量</p><h2 id="扩展模块"><a href="#扩展模块" class="headerlink" title="扩展模块"></a>扩展模块</h2><p>扩展模块很多是基于现有的模块做扩展，封装成flask的扩展，比如把实例加入请求上下文中；模块的更多用法可以参考原模块。</p><p>需要分析用法的模块，列出项目地址。</p><h3 id="flask-script"><a href="#flask-script" class="headerlink" title="flask_script"></a>flask_script</h3><p>用来自定义命令的，不过模块没有维护了，官方也推荐不要再使用它了，推荐使用 <code>@app.cli.command</code> 的形式来添加命令。然后配置环境变量，通过flask command的形式来执行命令。</p><p>可以使用装饰器，和类来添加命令。装饰器：<code>@manager.command</code>；类：继承Command类，实现run方法。</p><p>由于是弃用的模块，不再赘述。</p><h3 id="flask-migrate"><a href="#flask-migrate" class="headerlink" title="flask_migrate"></a>flask_migrate</h3><p>Flask-Migrate是用于处理SQLAlchemy 数据库迁移的扩展工具。当Model出现变更的时候，通过migrate去管理数据库变更。依赖alembic模块。</p><p>用法：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> flask <span class="token keyword">import</span> Flask<span class="token keyword">from</span> flask_sqlalchemy <span class="token keyword">import</span> SQLAlchemy<span class="token keyword">from</span> flask_migrate <span class="token keyword">import</span> Migrateapp <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>app<span class="token punctuation">.</span>config<span class="token punctuation">[</span><span class="token string">'SQLALCHEMY_DATABASE_URI'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'sqlite:///app.db'</span>db <span class="token operator">=</span> SQLAlchemy<span class="token punctuation">(</span>app<span class="token punctuation">)</span>migrate <span class="token operator">=</span> Migrate<span class="token punctuation">(</span>app<span class="token punctuation">,</span> db<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>命令：</p><ol><li><p>初始化<br>flask db init<br>这个命令会在当前目录下生成一个migrations文件夹。这个文件夹也需要和其他源文件一起，添加到版本控制。</p></li><li><p>生成最初的迁移<br>flask db migrate<br>此命令会在migrations下生成一个version文件夹，下面包含了对应版本的数据库操作py脚本。</p></li><li><p>数据库升级<br>flask db upgrade<br>最后一步。此命令相当于执行了version文件夹下的相应py版本，对数据库进行变更操作。此后，对model有变更，只要重复migrate和upgrade操作即可。</p></li></ol><p>由于migrate并不一定全部发现你对model的所有改动，因此生成的py脚本需要review, 有错的话则需要edit。</p><p>例如目前知道的，表名称表更，列名称变更，或给constraints命名等，migreate都不能发现的。更多限制细节见此：Alembic autogenerate documentation。</p><p>在Alembic 中，数据库迁移用迁移脚本表示。脚本中有两个函数，分别是upgrade() 和downgrade()。upgrade() 函数把迁移中的改动应用到数据库中，downgrade() 函数则将改动删除。Alembic 具有添加和删除改动的能力，因此数据库可重设到修改历史的任意一点。</p><p>我们可以使用revision 命令手动创建Alembic 迁移，也可使用migrate 命令自动创建。手动创建的迁移只是一个骨架，upgrade() 和downgrade() 函数都是空的，开发者要使用Alembic 提供的Operations 对象指令实现具体操作。自动创建的迁移会根据模型定义和数据库当前状态之间的差异生成upgrade() 和downgrade() 函数的内容。自动创建的迁移不一定总是正确的，有可能会漏掉一些细节。自动生成迁移脚本后一定要进行检查。</p><p>查看帮助文档：flask db –help</p><p>运行flask db init后，提示配置日志输出，默认输出到终端，应该配置日志到文件，方便以后排查问题（看看是谁动了数据库）</p><h3 id="flask-logging"><a href="#flask-logging" class="headerlink" title="flask_logging"></a>flask_logging</h3><p><a href="https://github.com/dgilland/flask-logconfig" target="_blank" rel="noopener">GitHub地址</a></p><p>用来快速实现登录验证。在User模型中，通过继承UserMixin实现以下属性：</p><ol><li><p>is_authenticated 属性，用来判断是否是已经授权了，如果通过授权就会返回true</p></li><li><p>is_active 属性，判断是否已经激活</p></li><li><p>is_anonymous 属性，判断是否是匿名用户</p></li><li><p>get_id() 方法，返回用户的唯一标识</p></li></ol><p>模块提供了login_required, login_user, logout_user等方法，验证成功后，通过login_user设置session。</p><h3 id="flask-sqlalchemy"><a href="#flask-sqlalchemy" class="headerlink" title="flask_sqlalchemy"></a>flask_sqlalchemy</h3><p>配置参数：</p><ul><li><code>SQLALCHEMY_DATABASE_URI</code>：配置数据库连接</li></ul><p><code>sqlite:////tmp/test.db 或 mysql://username:password@server/db</code></p><ul><li><p>SQLALCHEMY_BINDS：用来绑定多个数据库，例如：</p><pre><code>SQLALCHEMY_DATABASE_URI = 'postgres://localhost/main'SQLALCHEMY_BINDS = {  'users':        'mysqldb://localhost/users',  'appmeta':      'sqlite:////path/to/appmeta.db'}</code></pre><p>多个数据库在创建数据库或在模型中声名使用哪个，比如在模型中 <code>__bind_key__ = 'users'</code></p></li><li><p><code>SQLALCHEMY_ECHO</code>：值为Boolean（默认为False），设置为True，会把查询语句输出到stderr</p></li><li><p><code>SQLALCHEMY_RECORD_QUERIES</code>：可以用于显式地禁用或者启用查询记录。查询记录 在调试或者测试模式下自动启用。<br>一般我们不设置。</p></li><li><p><code>QLALCHEMY_NATIVE_UNICODE</code>：可以用于显式地禁用支持原生的unicode。</p></li><li><p><code>SQLALCHEMY_POOL_SIZE</code>：数据库连接池的大小。默认是数据库引擎的默认值（通常是 5）。当用户需要访问数据库时，并非建立一个新的连接，而是从连接池中取出一个已建立的空闲连接对象。使用完毕后，用户也并非将连接关闭，而是将连接放回连接池中，以供下一个请求访问使用。而连接的建立、断开都由连接池自身来管理。</p></li><li><p><code>SQLALCHEMY_POOL_TIMEOUT</code>：指定数据库连接池的超时时间。默认是10。</p></li><li><p><code>SQLALCHEMY_POOL_RECYCLE</code>：自动回收连接的秒数（1200即为2小时）。这对MySQL是必须的，默认情况下MySQL会自动移除闲置8小时或者以上的连接，Flask-SQLAlchemy会自动地设置这个值为2小时。也就是说如果连接池中有连接2个小时被闲置，那么其会被断开和抛弃。</p></li><li><p><code>SQLALCHEMY_MAX_OVERFLOW</code>：控制在连接池达到最大值后可以创建的连接数。当这些额外的连接使用后回收到连接池后将会被断开和抛弃。保证连接池只有设置的大小。</p></li><li><p><code>SQLALCHEMY_TRACK_MODIFICATIONS</code>：如果设置成 True (默认情况)，Flask-SQLAlchemy 将会追踪对象的修改并且发送信号。这需要额外的内存，如果不必要的可以禁用它。</p></li></ul><p>常用字段</p><table><thead><tr><th>Command</th><th align="left">Description</th></tr></thead><tbody><tr><td>Integer</td><td align="left">int普通整数，一般是32位</td></tr><tr><td>SmallInteger</td><td align="left">int取值范围小的整数，一般是16位</td></tr><tr><td>BigInteger</td><td align="left">int或long不限制精度的整数</td></tr><tr><td>Float</td><td align="left">float浮点数</td></tr><tr><td>Numeric</td><td align="left">decimal.Decimal普通整数，一般是32位</td></tr><tr><td>String</td><td align="left">str变长字符串</td></tr><tr><td>Text</td><td align="left">str变长字符串，对较长或不限长度的字符串做了优化</td></tr><tr><td>Unicode</td><td align="left">unicode变长Unicode字符串</td></tr><tr><td>UnicodeText</td><td align="left">unicode变长Unicode字符串，对较长或不限长度的字符串做了优化</td></tr><tr><td>Boolean</td><td align="left">bool布尔值</td></tr><tr><td>Date</td><td align="left">datetime.date时间</td></tr><tr><td>Time</td><td align="left">datetime.datetime日期和时间</td></tr><tr><td>LargeBinary</td><td align="left">str二进制文件</td></tr><tr><td>Enum</td><td align="left">enum枚举类型</td></tr></tbody></table><p>字段选项</p><table><thead><tr><th>Command</th><th align="left">Description</th></tr></thead><tbody><tr><td>primary_key</td><td align="left">如果为True，代表表的主键</td></tr><tr><td>unique</td><td align="left">如果为True，代表这列不允许出现重复的值</td></tr><tr><td>index</td><td align="left">如果为True，为这列创建索引，提高查询效率</td></tr><tr><td>nullable</td><td align="left">如果为True，允许有空值，如果为False，不允许有空值</td></tr><tr><td>default</td><td align="left">为这列定义默认值，如default=1</td></tr></tbody></table><p>flask_sqlalchemy的db实例提供了创建数据库的方法，不过这个是把当前上下文的模型创建数据库，如果是大型项目，那么就是把所有模型创建数据库，它的使用也有局限性，一般做为外部使用（一个测试工具，在这个上下文中创建db实例，对指定的模型来创建表）。所以应该使用迁移工具来管理数据库。</p><p>常用的过滤器</p><table><thead><tr><th>Command</th><th align="left">Description</th></tr></thead><tbody><tr><td>filter()</td><td align="left">把过滤器添加到原查询上，返回一个新查询</td></tr><tr><td>filter_by()</td><td align="left">把等值过滤器添加到原查询上，返回一个新查询</td></tr><tr><td>limit()</td><td align="left">使用指定的值限定原查询返回的结果</td></tr><tr><td>offset()</td><td align="left">偏移原查询返回的结果，返回一个新查询</td></tr><tr><td>order_by()</td><td align="left">根据指定条件对原查询结果进行排序，返回一个新查询</td></tr><tr><td>group_by()</td><td align="left">根据指定条件对原查询结果进行分组，返回一个新查询</td></tr></tbody></table><p>执行器</p><table><thead><tr><th>Command</th><th align="left">Description</th></tr></thead><tbody><tr><td>all()</td><td align="left">以列表形式返回查询的所有结果</td></tr><tr><td>first()</td><td align="left">返回查询的第一个结果，如果未查到，返回None</td></tr><tr><td>first_or_404()</td><td align="left">返回查询的第一个结果，如果未查到，返回404</td></tr><tr><td>get()</td><td align="left">返回指定主键对应的行，如不存在，返回None</td></tr><tr><td>get_or_404()</td><td align="left">返回指定主键对应的行，如不存在，返回404</td></tr><tr><td>count()</td><td align="left">返回查询结果的数量</td></tr><tr><td>paginate()</td><td align="left">返回一个Paginate对象，它包含指定范围内的结果</td></tr></tbody></table><h2 id="应用调度"><a href="#应用调度" class="headerlink" title="应用调度"></a>应用调度</h2><p><code>werkzeug.wsgi.DispatcherMiddleware</code> 可以把特定的请求分配到对应的一个新的flask应用上，这可以用来组织多个flask应用。需要注意的是新的flask应用和之前的是相互独立的，比如登录，使用的secret_key(可以使用不同的配置)等，所以要解耦项目，需要考虑这个问题，例如把接口的请求用新的app来处理，如果这些接口是需要登录才能使用的，那么在用户登录后，请求接口仍然需要登录</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> werkzeug<span class="token punctuation">.</span>wsgi <span class="token keyword">import</span> DispatcherMiddleware<span class="token keyword">from</span> frontend_app <span class="token keyword">import</span> application <span class="token keyword">as</span> frontend<span class="token keyword">from</span> backend_app <span class="token keyword">import</span> application <span class="token keyword">as</span> backendapplication <span class="token operator">=</span> DispatcherMiddleware<span class="token punctuation">(</span>frontend<span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token string">'/backend'</span><span class="token punctuation">:</span>     backend<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Framework </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 数据库基本</title>
      <link href="/2018/10/22/MySql/base/"/>
      <url>/2018/10/22/MySql/base/</url>
      
        <content type="html"><![CDATA[<p>mysql学习笔记</p><a id="more"></a><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>一般对于命令是不区分大小写的，为了区分保留关键字，一般保留关键字大写，变量和数据小写。</p><pre><code>sudo service mysql startmysql -u rootmysql -u root -pshow databases;use dataname;show tables;create database; 库名    //创建数据库drop database; 库名      //删除数据库</code></pre><p>/app/mysql/5.7.18/bin/mysql –socket=/app/mysql/5.7.18/dirstats/mysqld.sock -uroot -h134.108.3.196  -p</p><p>请先到 /etc/mysql   配置  my.cnf  避免中文插入有误</p><pre class="line-numbers language-s"><code class="language-s">[client]  default-character-set=utf8  [mysqld]  character-set-server=utf8  collation-server=utf8_general_ci<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>mysql –verbose –help | grep -A 1 ‘Default options’ </p><h2 id="理解数据库和实例，数据库引擎"><a href="#理解数据库和实例，数据库引擎" class="headerlink" title="理解数据库和实例，数据库引擎"></a>理解数据库和实例，数据库引擎</h2><p>关于引擎：引擎是数据库进行读写，保存，执行事务等一系列行为时，如何进行这些行为，就是由引擎来决定的。mysql默认会使用InnoDB引擎，引擎可以修改，可以对表指定不同的引擎（数据库应该要支持这种引擎），例如对于需要大量数据访问的，指定查询能力较强的引擎，对于需要事务处理的表，指定能处理事务的引擎。有些引擎是不支持事务的，InnoDB是功能较为齐全的引擎，各方面能力均衡。</p><p>索引：引擎不同，索引的实现也不用，保存的索引文件也不同（对于数据库来说，会有表结构文件，表数据文件，索引文件等，引擎不同也文件也不同，因为存储方式不一样）。<br>索引类型：B-Tree索引，哈希索引，空间数据索引（R-Tree），全文索引（数据库引擎要支持，这种索引用来做海量搜索，但是如果需求高，还是用专业的搜索引擎）。</p><p>主键索引，唯一索引，普通索引</p><p>mysql锁：大致分为表级锁，行级锁，页面锁。理解这三种锁很简单，从字面就可以看出锁的锁定粒度，也就知道他们的区别了。其中这个页面锁的粒度介于另外两者之间。同样，锁怎么去控制数据库，也是和引擎有关的。</p><p>乐观和悲观：常会看到乐观锁，悲观锁，是一类概念的统称，比如假定对数据库的操作都会产生资源竞争的问题，这个时候就要锁库，悲观的做法就是都锁，实现这样的锁也可以被称为悲观锁。乐观的概念就是相反的，你假定不会出现资源竞争的情况。</p><p>悲观的做法</p><p>悲观的做法表明，您应该完全锁定资源，直到完成它。如果没有人可以在您处理对象时获取对象上的锁定，那么可以确保对象没有被更改。<br>我们使用数据库锁有几个原因：</p><ol><li>数据库非常擅长管理锁并保持一致性。</li><li>数据库是访问数据的最低级别 - 获取最低级别的锁也会防止其他进程尝试修改数据。 例如，DB中的直接更新，cron作业，清理任务等。</li><li>Django应用程序可以在多个进程 （例如工作者）上运行。 在应用程序级别维护锁将需要大量（不必要的）工作。</li></ol><p>要在Django中锁定一个对象，我们使用 <code>select_for_update</code>。</p><p>主键 id int primary key not null auto_increment</p><p>外键 CONSTRAINT emp_fk FOREIGN KEY (in_dpt) REFERENCES department(dpt_name) CONSTRAINT 后面的名字在一张表里面不能重复</p><p>插入数据  INSERT INTO tablename (column, column)  VALUES （values）</p><p><strong>数据类型</strong></p><p>除了我们常用的，补充  可变字符VARCHAR， ENUM单选（必须是定义时枚举的值之一） SET多选 </p><p><strong>SQL约束</strong></p><p>通过对表的行为或列的数据做出限制，来确保表的数据的完整性、唯一性</p><p><strong>约束类型</strong></p><p>主键  默认值  唯一  外键 非空</p><p>主键 ：对于主键还有复合主键，由两个字段来确定唯一性，比如一个学生成绩表，有学号，课程号，成绩。通过学号和课程号我们可以得到他的成绩，这个两个字段就组成复合主键，联合主键就是多个字段来决定主键。</p><p>唯一 ： 这个约束就是这个字段的这一列的值是唯一的，在执行INSERT 语句的时候，如果插入重复的值则会失败。例如 UNIQUE （phone） 对这个字段进行唯一约束</p><p>非空约束： age INT(10) NOT NULL, 在创建的表的语句中出现了这个，就是非空约束，如果插入数据的时候不填，会警告，不会报错。（可能有些mySQL版本会报错）</p><p>select  fields from table where 限制条件</p><p>限制条件比如大于小于，在什么范围。 where in (3, 10)  where not in (5, 20)</p><p>where age between 20 and 25  年龄在20到25包括20和25</p><p>通配符  where fieldname like ‘12_’  可以匹配到123 125等   用  %  代表不定个未指定字符</p><h2 id="概念内容"><a href="#概念内容" class="headerlink" title="概念内容"></a>概念内容</h2><p>合并排序：一种将数据排序的算法，在数据库排序的时候使用，这种算法比较灵活，比如你不必把数据完全读取出来，这种方法称为 原地排序</p><p>二维阵列：最简单的数据结构，就是一张表</p><p>二叉查找树：用来做索引。数据在保存的时候，如果使用了索引，则这个索引信息将建立一个二叉查找树。当然的，你每次更新新的数据都要维护和更新这个查找数，这个算法比起从头到尾查找数据，将会快很多。</p><p>B+索引树：二叉的升级版，新的索引结构方式，支持范围查找，比如1到5，你只要找到1，在结果里面，1下面对应的数据一直到5，我们需要的就得到了。如果是二叉树，那么你要找1，然后找2，2还不一定有，接着找3…</p><p>哈希表：是一种数据结构，保存的数据是键值对类型的。散列函数（哈希函数）是把键转换成哈希码的函数，散列表（哈希表）是存放记录的数组（这个记录空间是一片连续的空间），数据的键通过散列函数得到一样结果的，都分类在一个数组里面。  概述就是对数据保存进行哈希，得到一个哈希表，去查找数据的时候，对数据的键进行哈希函数运算（得到哈希码后，可能还要进行求模运算才得到记录数组的下标），得到的结果就是记录里面数组的下标，在这个数组里面去找值。</p><p>一些概念扩展：数据库是数据库和实例结合的，数据库服务被启动后，用户需要链接到服务上，我们去链接数据库后，系统为你分配了各种资源来操作数据库，就是你得到了数据库的一个实例。这个链接由客户端管理器来处理</p><p>多实例：理解了实例和数据库后，我们可以使用多实例，你只需要部署一次数据库应用（在linux上装一个MySql server）然后通过多个实例进行链接，生成的数据库文件也是多个的，这样可以实现很多功能，比如主从数据库。</p><p>数据库是多个组件构成的：一般有查询管理器，数据管理器，工具，核心组件</p><p>核心组件：<br>进程管理器（process manager）：很多数据库具备一个需要妥善管理的进程/线程池。再者，为了实现纳秒级操作，一些现代数据库使用自己的线程而不是操作系统线程。<br>网络管理器（network manager）：网路I/O是个大问题，尤其是对于分布式数据库。所以一些数据库具备自己的网络管理器。<br>文件系统管理器（File system manager）：磁盘I/O是数据库的首要瓶颈。具备一个文件系统管理器来完美地处理OS文件系统甚至取代OS文件系统，是非常重要的。<br>内存管理器（memory manager）：为了避免磁盘I/O带来的性能损失，需要大量的内存。但是如果你要处理大容量内存你需要高效的内存管理器，尤其是你有很多查询同时使用内存的时候。<br>安全管理器（Security Manager）：用于对用户的验证和授权。<br>客户端管理器（Client manager）：用于管理客户端连接。<br>……</p><p>工具：<br>备份管理器（Backup manager）：用于保存和恢复数据。<br>复原管理器（Recovery manager）：用于崩溃后重启数据库到一个一致状态。<br>监控管理器（Monitor manager）：用于记录数据库活动信息和提供监控数据库的工具。<br>Administration管理器（Administration manager）：用于保存元数据（比如表的名称和结构），提供管理数据库、模式、表空间的工具。<br>……</p><p>查询管理器：<br>查询解析器（Query parser）：用于检查查询是否合法<br>查询重写器（Query rewriter）：用于预优化查询<br>查询优化器（Query optimizer）：用于优化查询<br>查询执行器（Query executor）：用于编译和执行查询<br>数据管理器：<br>事务管理器（Transaction manager）：用于处理事务<br>缓存管理器（Cache manager）：数据被使用之前置于内存，或者数据写入磁盘之前置于内存<br>数据访问管理器（Data access manager）：访问磁盘中的数据</p><p>获取数据和联接数据</p><p>如何获取数据？</p><p>全扫描：完全读取一个表或者索引</p><p>范围扫描：where语句</p><p>唯一扫描：索引中获取一个值</p><p>存取路径：</p><p>1、问题的提出</p><p>数据库必须支持多个用户的多种应用，因而也就必须提供对数据访问的多个入口，也就是说对同一数据的存储要提供多条存取路径。数据库物理设计的任务之一就是确定应建立哪些存取路径。存取路径即索引结构，因为索引结构提供了定位和存取数据的一条路径。存取方法是快速存取数据库中数据的技术。数据库管理系统一般都提供多种存取方法。常用的存取方法有三种：</p><ul><li>索引方法；</li><li>簇集方法；</li><li>HASH方法；</li></ul><p>B+树索引方法是数据库中经典的索引存取方法，使用最普遍。</p><p>2、存取路径的特点</p><p>在关系数据库中存取路径具有以下特点：</p><ul><li>存取路径和数据是分离的，对用户来说是不可见的；</li><li>存取路径可以由用户建立、删除，也可以由系统动态地建立、删除。例如，在执行查询时DBMS的查询优化器会根据优化策略自动地建立索引，以提高查询效率；</li><li>存取路径的物理组织通常采用顺序文件、Ｂ+树文件和散列文件结构等等。</li></ul><h2 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h2><p>innodb 表，数据和索引是一个文件<br>myisim 表，数据，索引，三个分开</p><h2 id="为什么直接跳到8"><a href="#为什么直接跳到8" class="headerlink" title="为什么直接跳到8"></a>为什么直接跳到8</h2><p>MySQL 5.5 -&gt; MySQL 5<br>MySQL 5.6 -&gt; MySQL 6<br>MySQL 5.7 -&gt; MySQL 7<br>MySQL 8.0 -&gt; MySQL 8</p><h2 id="DQL-DML-DDL-DCL"><a href="#DQL-DML-DDL-DCL" class="headerlink" title="DQL DML DDL DCL"></a>DQL DML DDL DCL</h2><p>SQL语言共分为四大类：数据查询语言DQL，数据操纵语言DML，数据定义语言DDL，数据控制语言DCL。</p><ol><li><p>数据查询语言DQL<br>数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE<br>子句组成的查询块：<br>SELECT &lt;字段名表&gt;<br>FROM &lt;表或视图名&gt;<br>WHERE &lt;查询条件&gt;</p></li><li><p>数据操纵语言DML data manipulation language<br>数据操纵语言DML主要有三种形式：<br>1) 插入：INSERT<br>2) 更新：UPDATE<br>3) 删除：DELETE</p></li><li><p>数据定义语言DDL<br>数据定义语言DDL用来创建数据库中的各种对象—–表、视图、<br>索引、同义词、聚簇等如：<br>CREATE TABLE/VIEW/INDEX/SYN/CLUSTER<br>| | | | |<br>表 视图 索引 同义词 簇</p></li></ol><p>DDL操作是隐性提交的！不能rollback </p><ol start="4"><li>数据控制语言DCL<br>数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制<br>数据库操纵事务发生的时间及效果，对数据库实行监视等。如：<br>1) GRANT：授权。</li></ol><p>2) ROLLBACK [WORK] TO [SAVEPOINT]：回退到某一点。<br>回滚—ROLLBACK<br>回滚命令使数据库状态回到上次最后提交的状态。其格式为：<br>SQL&gt;ROLLBACK;</p><p>3) COMMIT [WORK]：提交。<br>在数据库的插入、删除和修改操作时，只有当事务在提交到数据<br>库时才算完成。在事务提交前，只有操作数据库的这个人才能有权看<br>到所做的事情，别人只有在最后提交完成后才可以看到(不是绝对的，看当前的事务隔离级别)。<br>提交数据有三种类型：显式提交、隐式提交及自动提交。下面分<br>别说明这三种类型。</p><p>(1) 显式提交<br>用COMMIT命令直接完成的提交为显式提交。其格式为：<br>SQL&gt;COMMIT；</p><p>(2) 隐式提交<br>用SQL命令间接完成的提交为隐式提交。这些命令是：<br>ALTER，AUDIT，COMMENT，CONNECT，CREATE，DISCONNECT，DROP，<br>EXIT，GRANT，NOAUDIT，QUIT，REVOKE，RENAME。</p><p>(3) 自动提交<br>若把AUTOCOMMIT设置为ON，则在插入、修改、删除语句执行后，<br>系统将自动进行提交，这就是自动提交。其格式为：<br>SQL&gt;SET AUTOCOMMIT ON；</p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>SELECT @@tx_isolation 查看数据库隔离级别，版本不一致命令也不同，8.0 为 select @@transaction_isolation</p><p>start transaction;<br>update abc ts set ts.name=’abc’ where ts.id=’1’;</p><p>ACID 原子性 一致性 隔离性 持久性</p><p>事务隔离级别                   脏读     不可重复读    幻读<br>读未提交（read-uncommitted）    是      是       是<br>不可重复读(读已提交)（read-committed）    否      是       是<br>可重复读（repeatable-read）       否      否       是<br>串行化（serializable）           否      否       否</p><p>理解事务隔离级别产生的问题: 脏读，不可重复读，幻读</p><p>并发带来的问题: 丢失更新</p><p>幻读举例，MySQL8.0 默认事务隔离级别，不可重复读</p><p>开启两个会话</p><p>假设表是abc，有两条数据，表的字段是id name</p><p>会话1<br>start transaction;<br>select * from abc where id=5;</p><p>会话2<br>start transaction;<br>insert into abc (name) values (‘zxc’);<br>commit;</p><p>会话1<br>mysql&gt; insert into abc (id,name) values (3,’zxc’);<br>ERROR 1062 (23000): Duplicate entry ‘3’ for key ‘PRIMARY’<br>mysql&gt; select * from abc where id = 3;<br>Empty set (0.00 sec)</p><p>出现了幻读，会话2的数据已经插入了，而会话1读取不到（都要在事务中才有这种效果，并且数据库隔离级别不是串行化）</p><h2 id="事务流程与日志模块"><a href="#事务流程与日志模块" class="headerlink" title="事务流程与日志模块"></a>事务流程与日志模块</h2><p>通过日志模块来支持事务：binlog（归档日志）和redo log（重做日志）</p><h2 id="三范式和反范式"><a href="#三范式和反范式" class="headerlink" title="三范式和反范式"></a>三范式和反范式</h2><ol><li><p>第一范式<br>确保数据表中每列（字段）的原子性。<br>如果数据表中每个字段都是不可再分的最小数据单元，则满足第一范式。<br>例如：user用户表，包含字段id,username,password</p></li><li><p>第二范式<br>在第一范式的基础上更进一步，目标是确保表中的每列都和主键相关。<br>如果一个关系满足第一范式，并且除了主键之外的其他列，都依赖于该主键，则满足第二范式。<br>例如：一个用户只有一种角色，而一个角色对应多个用户。则可以按如下方式建立数据表关系，使其满足第二范式。<br>user用户表，字段id,username,password,role_id<br>role角色表，字段id,name<br>用户表通过角色id（role_id）来关联角色表</p></li><li><p>第三范式<br>在第二范式的基础上更进一步，目标是确保表中的列都和主键直接相关，而不是间接相关。<br>例如：一个用户可以对应多个角色，一个角色也可以对应多个用户。则可以按如下方式建立数据表关系，使其满足第三范式。<br>user用户表，字段id,username,password<br>role角色表，字段id,name<br>user_role用户-角色中间表，id,user_id,role_id<br>像这样，通过第三张表（中间表）来建立用户表和角色表之间的关系，同时又符合范式化的原则，就可以称为第三范式。</p></li><li><p>反范式化<br>反范式化指的是通过增加冗余或重复的数据来提高数据库的读性能。<br>例如：在上例中的user_role用户-角色中间表增加字段role_name。<br>反范式化可以减少关联查询时，join表的次数。</p></li></ol><h2 id="InnoDB-架构线程"><a href="#InnoDB-架构线程" class="headerlink" title="InnoDB 架构线程"></a>InnoDB 架构线程</h2><p>采用的是多线程模型，主要包括:</p><ol><li>Master Thread</li></ol><p>核心的后台线程，主要负责把缓冲池的数据异步刷新到磁盘，保证数据一致性</p><ol start="2"><li>IO Thread</li></ol><p>存储引擎使用大量的异步IO处理IO请求，IO Thread主要负责这些IO请求的回调</p><p>又可以细分到 write read insert buffer log 4中 IO Thread，线程数量不是单一的，读写线程比较多，版本演进也发生了变化</p><ol start="3"><li>Purge Thread</li></ol><p>事务被提交后，使用到的undolog可能不再需要，需要Purge Thread来回收已经使用过的undo页。随着版本的演进也发生了变化</p><ol start="4"><li>Page Cleaner Thread</li></ol><p>用来处理脏页刷新的，减轻Master Thread的压力</p><h2 id="聚蔟索引和非聚蔟索引"><a href="#聚蔟索引和非聚蔟索引" class="headerlink" title="聚蔟索引和非聚蔟索引"></a>聚蔟索引和非聚蔟索引</h2><p>或者叫聚集索引也行</p><p>非聚集索引索引项顺序存储，但索引项对应的内容却是随机存储的；</p><p>表中主键id是该表的聚集索引、name为非聚集索引；<br>表中的每行数据都是按照聚集索引id排序存储的；<br>比如要查找name=’Arla’和name=’Arle’的两个同学，他们在name索引表中位置可能是相邻的，但是实际存储位置可能差的很远(B+树存储)<br>name索引表节点按照name排序，检索的是每一行数据的<code>主键</code><br>聚集索引表按照主键id排序，检索的是每一行数据的<code>真实内容</code></p><p>也就是说查询name=’Arle’的记录时，首相通过name索引表查找到Arle的主键id（可能有多个主键id，因为有重名的同学），再根据主键id的聚集索引找到相应的行记录；</p><p>聚集索引一般是表中的主键索引，如果表中没有显示指定主键，则会选择表中的第一个不允许为NULL的唯一索引，如果还是没有的话，就采用Innodb存储引擎为每行数据内置的6字节ROWID作为聚集索引</p><p>每张表只有一个聚集索引，因为聚集索引在精确查找和范围查找方面良好的性能表现（相比于普通索引和全表扫描），聚集索引就显得弥足珍贵，聚集索引选择还是要慎重的（一般不会让没有语义的自增id充当聚集索引）</p><p>sql举例，1用了主键索引，2用了非聚蔟索引。1就是顺序查找，然后直接得到数据。2就name找id，id可能是离散存储不是顺序的，然后通过id取到数据。总体来说多了一层IO，也就是回表，而且不能顺序读取，也会有一定的性能损坏</p><p>（1）select * from student where id &gt;5000 and id &lt;20000;</p><p>（2）select * from student where name &gt; ‘Alie’ and name &lt; ‘John’;</p><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>悲观锁用for_update<br>乐观锁</p><p>锁</p><p>共享锁<br>排它锁</p><p>意向共享锁<br>意向排它锁</p><p>间隙锁</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> DataBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yaml 标记语言</title>
      <link href="/2018/10/22/Other/yaml/"/>
      <url>/2018/10/22/Other/yaml/</url>
      
        <content type="html"><![CDATA[<p>yaml 语言</p><a id="more"></a><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进时不允许使用Tab键，只允许使用空格。</li><li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>YAML 支持的数据结构有三种</p><p>对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）</p><p>数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）</p><p>纯量（scalars）：单个的、不可再分的值</p><h2 id="python-操作"><a href="#python-操作" class="headerlink" title="python 操作"></a>python 操作</h2><p>load  和 dump 方法<br>load 加载 yaml 文件   dump将数据写入yaml文件</p><p>先创建一个文件对象 ，并加载 <code>stream = file('example.yaml','r') dicts = yaml.load(stream)</code> 这个时候，我们就可以去取值了</p><p>举例：<br>yaml文件为</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">url</span><span class="token punctuation">:</span><span class="token punctuation">-</span> www.baidu.com<span class="token punctuation">-</span> www.taobao.com<span class="token punctuation">-</span> vlcoa.inruan.com <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这个属于数组，取值时用索引就可以了 <code>print dicts['url'][1]</code> 结果是 <code>www.taobao.com</code></p><p>yaml文件为</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">language</span><span class="token punctuation">:</span>        <span class="token key atrule">top1</span><span class="token punctuation">:</span>            python        <span class="token key atrule">top2</span><span class="token punctuation">:</span>               java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>属于对象，language是一个字典 <code>print dicts['language']['top1']</code> 结果 <code>python</code></p><p>比较简单的配置文件：</p><pre><code>settime: 5     </code></pre><p>load后，<code>dicts[settime]</code>，就可以取到5了，冒号后面一点要有空格，使用数组就可以使用索引去取值，而且dicts到的是列表，可以去迭代参数，必须要用  ‘-‘ 加空格的形式，不能使用Tab键来缩进，一定要用空格。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Yaml </tag>
            
            <tag> Other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机知识补充</title>
      <link href="/2018/10/22/Other/base/"/>
      <url>/2018/10/22/Other/base/</url>
      
        <content type="html"><![CDATA[<p>计算机知识补充</p><a id="more"></a><h2 id="为什么不要用记事本来写代码？"><a href="#为什么不要用记事本来写代码？" class="headerlink" title="为什么不要用记事本来写代码？"></a>为什么不要用记事本来写代码？</h2><p>可能有人会怪windows怎么那么傻，一个\n不就可以了，为什么要用\r\n呢，给我们造成了多大的麻烦。其实这也不能怪windows。使用\r\n的历史可以追溯到遥远的19世纪。 那时候发明的打字机主要结构是一个实心圆筒+排列成菊花状的字模。纸张被牢牢地固定在圆筒的表面上。当我们按下一个字母的时候，机械装置引动字模”飞”向纸张，同时圆筒前的色带升起，用力地印下去，于是纸张上面就出现一个字了。印完之后，机械装置自动地让圆筒向左移动一个字母格子，方便打印下一个字符。打完一行之后，左手边上有一个摇杆，摇一下，圆筒就可以滚动一个行距，这是换行。不过，因为打字的时候圆筒总会不断地向左移动，所以打字员还需要用力地把圆筒推回右边，这就是传说中的回车了。在计算机里常见的换行操作在打字机里需要换行+回车两个操作。自然，计算机里不用这么麻烦，不过windows喜欢看起来更兼容一点。于是换行就成了\r\n了。</p><h2 id="猴子补丁"><a href="#猴子补丁" class="headerlink" title="猴子补丁"></a>猴子补丁</h2><p>“猴子补丁”就是指，在函数或对象已经定义之后，再去改变它们的行为。</p><h2 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h2><p>Scale Out（也就是Scale horizontally）横向扩展，向外扩展</p><p>Scale Up（也就是Scale vertically）纵向扩展，向上扩展</p><p>无论是Scale Out，Scale Up，Scale In，实际上就是一种架构的概念，这些概念用在存储上可以，用在数据库上，网络上一样可以。</p><p>简单比喻下Scale out和Scale up，帮助我们理解：</p><ul><li>Scale Out，比如：我们向原有的web、邮件系统添加一个新机器。</li><li>Scale UP，比如：我们向原有的机器添加CPU、内存。</li></ul><h2 id="斜杠与反斜杠"><a href="#斜杠与反斜杠" class="headerlink" title="斜杠与反斜杠"></a>斜杠与反斜杠</h2><p>“\”与“/”斜杠与反斜杠，只要知道，在windows路径里面用反斜杠，其它一般都是斜杠</p><p>\ 转义，Python中加 r 不转义 r ‘\t’ 结果是 \t</p><h2 id="秒的定义"><a href="#秒的定义" class="headerlink" title="秒的定义"></a>秒的定义</h2><p>国际单位制词头经常与秒结合以做更细微的划分，例如ms（毫秒，千分之一秒）、μs（微秒，百万分之一秒）和ns（纳秒，十亿分之一秒）。虽然国际单位制词头虽然也可以用于扩增时间，例如Ks（千秒）、Ms（百万秒）和Gs（十亿秒），但实际上很少这样子使用，大家都还是习惯用60进制的分、时和24进制的日做为秒的扩充。</p><h2 id="csv文件"><a href="#csv文件" class="headerlink" title="csv文件"></a>csv文件</h2><p>csv文件，使用逗号分隔，这种格式的文本可以导到excel</p><h2 id="名词缩写"><a href="#名词缩写" class="headerlink" title="名词缩写"></a>名词缩写</h2><p>进程间通信（Inter Process Communication，IPC）</p><p>POSIX表示可移植操作系统接口（Portable Operating System Interface of UNIX，缩写为 POSIX ）这个标准制定了一些通用的东西，方便大家在实现的时候做到通用性，那么移植就不会有太大的问题了</p><p>SMP：对称多处理结构，一个计算机上使用多个CPU，而内存，总线是共享的</p><p>conditional requests : 条件请求，可以改变请求的资源</p><p>Cross Origin Resource Sharing（CORS）跨域资源共享</p><p>fd(file descriptor) 文件描述符</p><p>oom (out of memory) 内存溢出 <code>oom killer</code> 这个东西会在系统内存耗尽的情况下跳出来，选择性的干掉一些进程以求释放一些内存。具体的记录日志是在/var/log/messages中，如果出现了Out of memory字样，说明系统曾经出现过OOM！</p><h2 id="utf-8-和-unicode"><a href="#utf-8-和-unicode" class="headerlink" title="utf-8 和 unicode"></a>utf-8 和 unicode</h2><p>必须知道的是，utf-8是unicode的一种实现方式，比如utf-16也是。互联网多采用utf-8，之所以出现unicode的多种实现，是因为为了表数多字符的二进制，需要使用多个字节，这带来的存储的不便利（比如在Unicode中英文用一个字节就行了，汉字会占用2个或3个等，如果大家都统一成4字节，倒是存储解析都可以了，但是大大浪费了空间，utf-8这种实现就是一种灵活的可变字节数的编码，如果符号只用一个字节，那么存储就是一个，需要多个就多个。如何解析呢？利用第一个字节的前几位表示这个符合占用几个字节，这样解析的时候就知道这次是拿几个字节出来解码成对应的符号，大大利用了空间。）<br>编码过程：2条。1）单字节首位是0，其它7位是Unicode码。2）多字节，对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p><pre><code>字符  严     Unicode   100    111000   100101utf-8     111  0 (0100) 10 (111000) 10 (100101)    通过括号和空格分割，可以看道字符是如何从Unicode到utf-8的。</code></pre><p>关于字节序：Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（zero width no-break space），用FEFF表示。这正好是两个字节，而且FF比FE大1。</p><p>如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。</p><h2 id="事件句柄"><a href="#事件句柄" class="headerlink" title="事件句柄"></a>事件句柄</h2><p>事件句柄又称为事件处理函数。它需要被赋值，比如将一个函数赋值给事件句柄。<br>当特定事件发生的时候，就去检查事件句柄有没有被赋值，如果有，则执行事件<br>句柄（执行该函数）</p><h2 id="函数签名"><a href="#函数签名" class="headerlink" title="函数签名"></a>函数签名</h2><p>函数的名称及其参数类型组合在一起，就定义了一个唯一的特性，称为函数签名。（不包括返回类型）</p><p>在编写包含函数调用的语句时，编译器就会使用该调用创建一个函数签名。再把它与函数原型/或定义中可用的函数签名集比较。如果找到匹配的函数名，就建立所调用的函数。(c++的解释)</p><p>函数签名对象，表示调用函数的方式，即定义了函数的输入和输出。在Python中，可以使用标准库inspect的一些方法或类，来操作或创建函数签名。</p><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>多个相同函数名，不同的参数个数或者类型的形式叫做函数的重载。</p><h2 id="arp-a"><a href="#arp-a" class="headerlink" title="arp -a"></a>arp -a</h2><p>这个Windows命令中有一个类型的概念</p><p>类型：动态的是说过一定时间如果这个mac地址没有用到过，就会被删掉；静态的会被永久保留</p><h2 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h2><p>可重入函数主要用于多任务环境中，一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误；而不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。</p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>在IP通信中，经常有数据包到达不了对方的情况。原因是，在通信途中的某处的一个路由器由于不能处理所有的数据包，就将数据包一个一个丢弃了。或者，虽然到达了对方，但是由于搞错了端口号，服务器软件可能不能接受它。这时，在错误发生的现场，为了联络而飞过来的信鸽就是ICMP 报文。在IP 网络上，由于数据包被丢弃等原因，为了控制将必要的信息传递给发信方。ICMP 协议是为了辅助IP 协议，交换各种各样的控制信息而被制造出来的。</p><p>制定万维网规格的IETF 在1981 年将RFC7922作为ICMP 的基本规格整理出来了。那个RFC792 的开头部分里写着“ICMP 是IP 的不可缺少的部分，所有的IP 软件必须实现ICMP协议。也是，ICMP 是为了分担IP 一部分功能而被制定出来的。</p><h2 id="前端概述"><a href="#前端概述" class="headerlink" title="前端概述"></a>前端概述</h2><p>前端的发展到现在，我们引用人类文明发展历程做比喻，划分为4个时代，每一个时代都是技术的革命和进步，包括原始社会，石器时代，铁器时代，工业时代。</p><ol><li>原始社会</li></ol><p>1994 年的时候，网景公司 (Netscape Communications) 推出了第一款浏览器：NCSAMosaic，当时还没有JavaScript语言，网页是静态的，基于HTML文本描述语言，提交一个表单，等待很久，最后可能返回给你个 “用户名错误”。</p><p>总结：这个时候是没有前端的概念的，页面是后端的一部分，也就是网页是由后端代码直接生成的。</p><ol start="2"><li>石器时代</li></ol><p>就在同一年(1994 年)，PHP 出现了，有了将数据嵌入到 HTML 中的形式，这意味着互联网行业出现了钻木取火，不断朝石器时代发展。<br>这时候的互联网，兴起了数据嵌入模板，模板直接写样式的开发模式，发展成了后来的 MVC 模式：</p><p>Model（模型层）：提供/保存数据。<br>Controller（控制层）：数据处理，实现业务逻辑。<br>View（视图层）：展示数据，提供用户界面。</p><p>该模式至今仍在沿用，网页同样由后端生成，不过不是直接输出了，而是对模块的渲染，编写模板的工作已经属于前端的范畴了，不过由于模板和后端的绑定，编写模板需要了解后端，如现在的Django的模板语言，JSP技术等，此时仍然没有前端的地位，这些工作一般由后端开发人员完成，除非是比较复杂的页面布局，交由专门的人员编写。</p><p>总结: 技术开始规范，提出了MVC的开发模式。不过编写模板人员仍然需要了解后端模板语言，或者模板是静态的，写好后又由后端开发人员修改数据，工作重复和繁琐。</p><ol start="3"><li>铁器时代</li></ol><ul><li>3.1 JavaScript的诞生</li></ul><p>1995年，网景工程师Brendan Eich花了10天时间设计了JavaScript语言。起初这种脚本语言叫做Mocha，后改名LiveScript，后来为了借助Java语言创造良好的营销效果最终改名为JavaScript。网景公司把这种脚本语言嵌入到了Navigator 2.0之中，使其能在浏览器中运行。这也是历史遗留问题的开端，Brendan Eich最初只是为了开发一种脚本语言，因而没有面向对象，也没有模块化等特性。</p><ul><li>3.2 ECMA规范 </li></ul><p>与此相对的是，1996年，微软发布了VBScript和JScript。JScript是对JavaScript进行逆向工程的实现，并内置于Internet Explorer 3中。但是JavaScript与JScript两种语言的实现存在差别，这导致了程序员开发的网页不能同时兼容Navigator和Internet Explorer浏览器。Internet Explorer开始抢夺Netscape的市场份额，这导致了第一次浏览器战争。</p><p>1996年11月，为了确保JavaScript的市场领导地位，网景将JavaScript提交到欧洲计算机制造商协会（European Computer Manufacturers Association）以便将其进行国际标准化。</p><p>1997年6月，ECMA以JavaScript语言为基础制定了ECMAScript标准规范ECMA-262。JavaScript是ECMAScript规范最著名的实现之一，除此之外，ActionScript和JScript也都是ECMAScript规范的实现语言。自此，浏览器厂商都开始逐步实现ECMAScript规范。</p><p>该规范一直沿用至今，我们经常听到的ES6, 全称 ECMAScript 6.0，是 JavaScript 的一个版本标准，2015.06 发布，增加了面向对象，模块化等支持，使得JavaScript 语言可以用来编写复杂的大型应用程序</p><ul><li>3.3 动态网页</li></ul><p>到了 1998 年前后，Ajax（Asynchronous Java And XML：异步的 Java 和 XML）得到了相对的应用，并且在之后逐渐被使用到各个页面上，从而促进了 Web 从 1.0 的静态网页，纯内容展示向 Web 2.0 模式迈进。</p><p>这时候，前端不再是后端的模板，它可以独立得到各种数据。相对于 Web 1.0 的时代，Web 2.0 由石器时代迈向了铁器时代！</p><p>在 Web 2.0 的时代中，在 2006 年的时候，用于操作 DOM 的 jQuery 出现了，它快速地风靡了全球。大量的基于 jQuery 的插件构成了一个庞大的生态系统，从而稳固了 jQuery 作为 JS 库一哥的地位。</p><p>jQuery 的影响是源远流长的，很少有人直接操作原生接口。</p><p>总结：JavaScript诞生，并由ECMA协会统一了规范和标准，避免了混乱的开端，ECMAScript是一个很重要的标准。提出了AJAX技术，网页从静态向动态发展。用于操作DOM的jQuery成为主流，降低了对DOM的操作难度。</p><ol start="4"><li>工业时代</li></ol><p>伴随着信息时代、大数据时代的到来，jQuery 在大量的数据操作中的弊端体现出来了，它在对 DOM 进行大量的操作中，会导致页面的加载缓慢等问题（这也和DOM的设计，历史原因相关），这时，有些前端开发人员逐渐觉得力不从心了。</p><p>1999年，W3C发布了HTML 4.0.1版本，在之后的几年，没有再发布更新的Web标准。随着Web的迅猛发展，旧的Web标准已不能满足Web应用的快速增长，委员会开始起草新的web标准HTML5，2008年1月22日，第一份正式草案发布。<br>HTML5草案发布不久，Google在2008年12月发布了Chrome浏览器，加入了第二次浏览器大战当中。Chrome使用了Safari开源的WebKit作为布局引擎，并且研发了高效的JavaScript引擎V8。谷歌 V8 引擎发布，终结微软 IE 时代。</p><p>Chrome的发布，其JavaScript引擎V8的高效执行引起了Ryan Dahl的注意。2009年，Ryan利用Chrome的V8引擎打造了基于事件循环的异步I/O框架——Node.js诞生，谷歌也推出了自己的前端框架AngularJS，此后，2011 年 React 诞生。<br>2014 年 Vue.js 诞生。</p><p>新框架衍生出了新的MVVM开发模式</p><pre><code>何为 MVVM 模式？Model：提供/保存数据。View：视图View-Model：简化的 Controller，唯一的作用就是为 View 提供处理好的数据，不含其它逻辑。</code></pre><p>如果说，Angular、React、Vue 等 MVVM 模式的出现，以及 Webpack 的前端工程化构建，加速了数据驱动前端工程化的发展。那么，Node 这个基于 V8 引擎的服务端 JavaScript 运行环境的诞生，可媲美 Ajax 对于前端的贡献。</p><p>Node 是前端的第二次飞跃，它使 JS 在服务端语言中也有了一席之地。</p><p>总结：前端开始飞速发展，百花齐放。三大框架Angular、React、Vue并立而行。至此，前端正式进入工业时代，开发更加工程化和规范化，JavaScript也不再是以往被人调侃的“玩具语言”，也不再局限于web开发，被运用于服务端，游戏，桌面，APP等。</p><h3 id="当前主流"><a href="#当前主流" class="headerlink" title="当前主流"></a>当前主流</h3><ol><li>JavaScript的组成</li></ol><p>我们回顾了前端的发展历程，提到了很多概念，我们常说的JavaScript是一种广义上的定义，它应该由三部分组成</p><p>JavaScript 分为 ECMAScript，DOM，BOM。</p><p>ECMAScript：在上文中已经多次提到了，它是欧洲计算机协会制定的标准，是一门程序设计语言，新版本中已经支持了许多特性，使得语言在项目开发中更加工程化，模块化。</p><p>DOM（文档对象模型）：DOM把整个HTML页面映射为一个多层节点结果，开发人员可借助DOM提供的API，轻松地删除、添加、替换或修改任何节点。</p><p>BOM（浏览器对象模型）：操作浏览器的API，比如页面刷新，跳转等。</p><p>理解了上面三点才是真正理解了JavaScript，ECMAScript是核心，只要有运行环境就可以被执行，而前端要依托于浏览器，DOM和BOM就是浏览器厂商来设计的，当然也会遵循一定的规范，有了这些接口我们才能实现丰富多彩的页面。</p><ul><li>传统开发模式</li></ul><p>在传统的前端开发模式中，一般就是围绕着html，js，css来展开，主页面是一个html页面，引入各种js依赖和css，当页面被浏览器加载的时候，整个页面被渲染完成，包含的js脚本完成各自的工作，主要就是对dom的事件绑定。<br>这种开发模式中，带来了很多问题</p><ol><li>首先就是js是单文件的，多个js的导入共享同一个命名空间，你可能会在代码中看到各种函数的调用，却不知道它到底在何处定义，越是复杂的项目这个问题就尤为突出。</li><li>DOM的操作过于繁琐，虽然有了jQuery，但是操作的本质还是没有变化，复杂一点的页面实现需要大量的html字符串拼接来实现，这种拼接极其晦涩难懂，而且性能上也会下降很多，造成这种情况的原因主要是对dom的理解不够深入，因为dom还是过于复杂，一般的应用编程完全不会涉及这么深的内容，应为当你了解到这个层次的时候，你可能已经可以开发一套完善的操作框架了。</li><li>请求次数过于频繁，这也是传统开发模式的弊端。在ajax技术出现后，已经没有必要多次请求数据了，但是传统模式中，响应新页面要重新发起请求。请求过多，也就链接过多，对服务器处理造成一点负担。</li></ol><ul><li>新开发模式</li></ul><p>以上问题在新开发模式中都被解决了</p><ol><li>新的ES标准，提供了模块化的支持，模块化是现代程序设计语言构建大型项目的基石，模块划分了命名空间</li><li>基于新的ES标准所开发的Vue，React框架，拥有更加先进的DOM操作技术，多DOM的操作将变得极其简单</li><li>通过webpack工具打包后，零散的文件将被整合，页面的跳转将转化为跟DOM节点的操作，这些操作都由浏览器来完成，页面只在第一次加载的时候请求资源，此后的所有操作都不再请求资源（接口数据除外），最大程度的降低了前端的请求次数，这种模式也被称为单页面应用(SPA)</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Other </tag>
            
            <tag> Learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>collections 模块使用</title>
      <link href="/2018/10/22/Python/collections/"/>
      <url>/2018/10/22/Python/collections/</url>
      
        <content type="html"><![CDATA[<p>collections模块是python的内建模块，提供类很多实用的集合类。有时候很多数据结构其实标准库已经实现了，不妨来这里找找有没有你想要的。内容参考官方文档。</p><a id="more"></a><h2 id="nametuple-命名元组"><a href="#nametuple-命名元组" class="headerlink" title="nametuple(命名元组)"></a>nametuple(命名元组)</h2><p>从名字可以看出，这是一个对tuple定义name的类，通过nametuple创建的tuple有了名字，最重要的是可以通过属性来访问<code>new tuple</code> 的元素。</p><blockquote><p><code>collections.namedtuple(typename, field_names, *, rename=False, defaults=None, module=None)</code><br>Returns a new tuple subclass named typename. The new subclass is used to create tuple-like objects that have fields accessible by attribute lookup as well as being indexable and iterable. Instances of the subclass also have a helpful docstring (with typename and field_names) and a helpful <strong>repr</strong>() method which lists the tuple contents in a name=value format.</p></blockquote><p>示例：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> namedtuplePoint <span class="token operator">=</span> namedtuple<span class="token punctuation">(</span><span class="token string">'Point'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'x'</span><span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>p <span class="token operator">=</span> Point<span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">)</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span> p<span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>输出 11 22</p></blockquote><p>注意：field_name参数不能是关键字，也不能有重复。rename参数用于当field_name重名的时候，自动进行重命名。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> namedtuplePoint <span class="token operator">=</span> namedtuple<span class="token punctuation">(</span><span class="token string">'Point'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'x'</span><span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> rename<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>p <span class="token operator">=</span> Point<span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>_fields<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>输出<br> Point(x=11, y=22, _2=33)<br>(‘x’, ‘y’, ‘_2’)<br><br>重命名的时候使用了下划线 _ 加元素所在索引数的方式进行重命名</p></blockquote><h3 id="classmethod-somenamedtuple-make-iterable"><a href="#classmethod-somenamedtuple-make-iterable" class="headerlink" title="classmethod somenamedtuple._make(iterable)"></a>classmethod somenamedtuple._make(iterable)</h3><p>该方法用来给实例赋值，这通常配合一些有序数据处理，如csv</p><pre class="line-numbers language-py"><code class="language-py">from collections import namedtuplePoint = namedtuple('Point', ['x', 'y'], rename=True)t = [11, 22]p = Point._make(t)print(Point, p)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>输出 &lt;class ‘<strong>main</strong>.Point’&gt; Point(x=11, y=22)</p></blockquote><h2 id="deque-双向列表"><a href="#deque-双向列表" class="headerlink" title="deque(双向列表)"></a>deque(双向列表)</h2><p>使用list存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为list是线性存储，数据量大的时候，插入和删除效率很低，deque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈。</p><p>示例</p><pre class="line-numbers language-py"><code class="language-py">from collections import dequeraw_list = ['1', '2', '3', 'a', 'b', 'c']new_list = deque(raw_list)new_list_2 = deque(['11', '22'])b = new_list_2 + new_listprint(b)print(new_list, type(new_list), isinstance(new_list, list))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>OutPut<br>deque([‘11’, ‘22’, ‘1’, ‘2’, ‘3’, ‘a’, ‘b’, ‘c’])<br>deque([‘1’, ‘2’, ‘3’, ‘a’, ‘b’, ‘c’]) &lt;class ‘collections.deque’&gt; False</p></blockquote><p>可以看到，deque创建到列表不是list的实例，只有deque的实例能相互进行运算。<br>deque支持的方法和list类似，多了像appendleft, popleft等方法，remove，reverse等通用方法，详情参考文档。</p><h2 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h2><p>在对字典操作的时候，如果没有值会key错误，通过defaultdict创建的字典，第一个参数传递一个callable对象或者None(None创建的字典和原字典没有区别)，如果key不存在则返回callable调用的值。</p><pre class="line-numbers language-py"><code class="language-py">from collections import defaultdicta = [('a', 2), ('b', 3)]_dict = defaultdict(int, a)print(_dict, isinstance(_dict, dict))print(_dict['aa'])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>OutPut<br>defaultdict(&lt;class ‘int’&gt;, {‘a’: 2, ‘b’: 3}) True<br>0</p></blockquote><p>使用int返回0，list返回[]，或者使用:lambda: ‘The key doesn’t exist’。<br>对于需要对字典key不存在的时候，返回统一值，就可以使用defaultdict。<br>使用get访问字典也是不错的编程习惯，在不想触发异常。</p><h2 id="OrderedDict-有序字典"><a href="#OrderedDict-有序字典" class="headerlink" title="OrderedDict(有序字典)"></a>OrderedDict(有序字典)</h2><p>使用OrderedDict创建一个有序字典，在迭代的时候就按照创建的顺序来。</p><pre class="line-numbers language-py"><code class="language-py">from collections import OrderedDicta = [('a', 1), ('b', 2), ('c', 3)]_dict = OrderedDict(a)print(_dict, isinstance(_dict, dict))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h2><p>用来统计字符出现的个数，结果返回一个dict</p><pre class="line-numbers language-py"><code class="language-py">from collections import Countera = [('a', 1), ('b', 2), ('c', 3)]c = Counter('aasjaslajl')c2 = Counter(['aasjaslajl', 'aa', 'bb', 'aa'])c3 = Counter(a)print(c, c2, c3)print(sorted(c3.elements()))print(isinstance(c, dict))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>OutPut<br>Counter({‘a’: 4, ‘s’: 2, ‘j’: 2, ‘l’: 2}) Counter({‘aa’: 2, ‘aasjaslajl’: 1, ‘bb’: 1}) Counter({(‘a’, 1): 1, (‘b’, 2): 1, (‘c’, 3): 1})<br>[(‘a’, 1), (‘b’, 2), (‘c’, 3)]<br>True</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django 框架学习笔记</title>
      <link href="/2018/10/22/Python/Django/"/>
      <url>/2018/10/22/Python/Django/</url>
      
        <content type="html"><![CDATA[<p>django学习笔记 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8">🎉</span> <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8">🎉</span></p><p>对文档阅读的大致补充，框架拥有功能的概述，详细内容查阅文档。</p><p>在使用前后端分离的项目中，模版相关的内容基本没什么用了，对于Django如果不是快速开发的应用，基本也不用它提供的功能（认证，表单等），使用较多的有中间件，URL到视图响应，ORM，个人认为扩展ORM开发一套自己的框架很有实战意义，你可以做一个自己风格的ORM，实现像只完成模型定义，就拥有对模型进行增加(Create)、读取查询(Retrieve)、更新(Update)和删除(Delete)的能力。</p><p>如此，你便迭代出一个非常适合自己的框架，相信大公司都会有自己的一套迭代框架，用于快速开发产品。</p><a id="more"></a><h1 id="Django-相关"><a href="#Django-相关" class="headerlink" title="Django 相关"></a>Django 相关</h1><p><img src="/images/Python/Django.png" alt="image"></p><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>session是一种常用的web技术，在Django框架中很容易去使用它。</p><h3 id="session-概念"><a href="#session-概念" class="headerlink" title="session 概念"></a>session 概念</h3><p>大多数的应用都是用 <code>Cookie</code> 来实现 <code>Session</code> 跟踪的，第一次创建 <code>Session</code> 的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie里面记录一个 <code>Session ID</code>，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。如果客户端的浏览器禁用了Cookie怎么办？一般这种情况下，会使用一种叫做 <code>URL重写</code> 的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 <code>sid=xxxxx</code> 这样的参数，服务端据此来识别用户。</p><p>网站保存登录账号和密码是由本地的Cookie来实现的。</p><blockquote><p>关于缓存：为了实现性能，缓存还是有必要的，不过先做到数据库的实现。session还可以基于文件来实现</p></blockquote><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>session是要浏览器这边配合Cookie来实现的，所以浏览器不能禁用cookie：</p><ol><li>当用户来访问服务端时,服务端生成一个随机字符串；</li><li>当用户登录成功后 把 {sessionID :随机字符串} 组织成键值对 加到 cookie里发送给用户；</li><li>服务器以发送给客户端 cookie中的随机字符串做键，用户信息做值，保存用户信息；</li></ol><h3 id="代码流程（在默认配置下）"><a href="#代码流程（在默认配置下）" class="headerlink" title="代码流程（在默认配置下）"></a>代码流程（在默认配置下）</h3><p>在代码上，我们直接 <code>request.session['name'] = "my name"</code> 这一步执行了，就是使用随机字符串，创建了session保存到数据库，然后把 <code>session_id</code>（随机字符串）放在cookie里面给到浏览器，浏览器就设置了cookie，下次浏览器就会在请求里面cookie带上这个id，框架流程上中间件会拿出请求体的cookie查询数据库，并将session对象赋值给 <code>request.session</code>。</p><h3 id="session序列化-框架文档有讲解"><a href="#session序列化-框架文档有讲解" class="headerlink" title="session序列化(框架文档有讲解)"></a>session序列化(框架文档有讲解)</h3><p>session的数据会被序列化保存在数据库中，默认是json，一般不需要改，由于是json，所以数据创建的键最好是字符串，数据要能被json编码，你不能直接把一个对象设置在session的键值对当中。</p><p>如果想保存更高级的格式，就需要自己实现序列化程序。（从数据库的数据来看，存储的并不是是序列字符串，是一定规则化的字母，猜测是为了压缩数据，s.get_decoded()可以得到解码的结果）</p><h3 id="会话对象准则"><a href="#会话对象准则" class="headerlink" title="会话对象准则"></a>会话对象准则</h3><p>使用普通的Python字符串作为字典键 <code>request.session</code>。这是一个比硬性规定更重要的惯例。<br>以下划线开头的会话字典键由Django保留供内部使用。不要request.session用新对象覆盖，也不要访问或设置其属性。像Python字典一样使用它。</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>session 就是用来在后端，为了给无状态的HTTP协议提供识别（用户识别），扩展它是很重要的。比如我们不依赖cookie，而是每次都传递一个id，后端用这个id自己创建session，然后前端每次请求都带这个ID，这样后端中间件每次都通过ID查询数据库，赋值request.session</p><p>扩展依赖于 <code>SessionStore</code></p><p><code>from django.contrib.sessions.backends.db import SessionStore</code></p><p>如果 <code>SESSION_ENGINE</code> 不是数据库，需要从对应的引擎来引入，可以这样：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> importlib <span class="token keyword">import</span> import_module<span class="token keyword">from</span> django<span class="token punctuation">.</span>conf <span class="token keyword">import</span> settingsSessionStore <span class="token operator">=</span> import_module<span class="token punctuation">(</span>settings<span class="token punctuation">.</span>SESSION_ENGINE<span class="token punctuation">)</span><span class="token punctuation">.</span>SessionStore<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>如果您在cookie中设置了 <code>HttpOnly</code> 性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止 <code>XSS</code> 攻击，具体一点的介绍请google进行搜索</p><p>遇到这个问题时：</p><blockquote><p>The request’s session was deleted before the request completed. The user may have logged out in a concurrent request, for example.</p></blockquote><p>该地址有讲解，不过这个问题应该是出现在开发阶段的调试中，如果出现了问题可以清除浏览器数据来解决，一劳永逸的方案（还没看，链接在下面）不一定需要。<br><a href="https://stackoverflow.com/questions/42211065/django-memcached-error-the-requests-session-was-deleted-before-the-request-c" target="_blank" rel="noopener">https://stackoverflow.com/questions/42211065/django-memcached-error-the-requests-session-was-deleted-before-the-request-c</a></p><h2 id="密码加密"><a href="#密码加密" class="headerlink" title="密码加密"></a>密码加密</h2><p>框架提供了密码加密功能，该部分讲解了密码如何存储，密码升级，密码验证，管理密码。</p><p>密码存储暂时没看。</p><p>密码升级有从下一版本升级到新版本的时候，使用新的算法，和对所有需要升级的一次处理，具体参考文档。</p><p>除了框架的自己提供的，还可以使用自己编写的算法进行加密</p><p>手动管理密码：包括几个函数，对密码进行加密得到加密的结果，这个用来保存在数据库，验证密码，把明文密码和数据库存储的加密密码进行验证，返回布尔值。</p><p>密码验证：控制用户输入的密码，避免太简单，例如用户的密码输入6为，验证规则是9位那么验证不通过。</p><p>配置文件：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 密码加密使用的算法</span><span class="token comment" spellcheck="true"># 列表的第一个元素 (即settings.PASSWORD_HASHERS[0]) 会用于储存密码，</span><span class="token comment" spellcheck="true"># 所有其它元素都是用于验证的哈希值，它们可以用于检查现有的密码。</span>PASSWORD_HASHERS <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string">'django.contrib.auth.hashers.PBKDF2PasswordHasher'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.auth.hashers.Argon2PasswordHasher'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.auth.hashers.BCryptSHA256PasswordHasher'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.auth.hashers.BCryptPasswordHasher'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.auth.hashers.SHA1PasswordHasher'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.auth.hashers.MD5PasswordHasher'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.auth.hashers.UnsaltedSHA1PasswordHasher'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.auth.hashers.UnsaltedMD5PasswordHasher'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.auth.hashers.CryptPasswordHasher'</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>高版本需要继承MiddlewareMixin，低版本不需要。</p><p>各种架构中都会用到的技术（有些框架也称为管道，httphandle）。用户发起的请求会依次经过所有的中间件。由于中间件也用来处理django的内部的东西，所以自己添加的中间件一般写在系统中间件后面，除非你对流程很了解，想在框架某个流程时插入某些东西。</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><ul><li>每个模型都是django.db.models.Model 的一个Python 子类。模型的每个属性都表示为数据库中的一个字段。</li><li>每个字段都被指定成一个类属性，例如Field类。每个属性映射到一个数据库的列。</li><li>查阅或看源代码，可以从模型类上获取到很多内容。</li></ul><h3 id="字段参数"><a href="#字段参数" class="headerlink" title="字段参数"></a>字段参数</h3><p><strong>question_text = models.CharField(max_length=200,blank=true,null=true)</strong></p><ul><li><code>blank，null</code> 都是该字段可以为空，blank是在admin中可以为空，要在表中可以为空，设置null</li><li><code>null = Ture</code> 指定空，blank = Ture 允许填</li><li><code>choices</code> 这个字段参数设置该字段内容是选择列表</li><li><code>primary_key</code> 该参数为Ture  指定其为主键字段，不写，自动添加一个IntegerField字段为主键</li><li><code>db_index</code> 为此字段创建索引</li><li><code>editable</code> 设置为False  这个字段将不会出现在 admin 或者其他 ModelForm.，会跳过模型验证</li><li><code>unique</code> 为Ture，这个字段在表中必须有唯一值，注意当设置 unique 为True 时，你不需要再指定 db_index，因unique 本身就意味着一个索引的创建</li></ul><p>verbose_name（字段的自述名）</p><p><code>Field.verbose_name</code> 一个字段的可读性更高的名称。如果用户没有设定冗余名称字段，Django会自动将该字段属性名中的下划线转换为空格，并用它来创建冗余名称。可以参照 <code>Verbose field names</code>。</p><p><code>元参数</code> permissions 是用来这种模型的权限的，default_permissions 是设置默认权限的，比如add，change，即模型是否能添加，改变。</p><blockquote><p>由于Django 查询语法的工作方式，字段名称中连续的下划线不能超过一个。<br>django不允许重写字段。</p></blockquote><h3 id="模型的属性"><a href="#模型的属性" class="headerlink" title="模型的属性"></a>模型的属性</h3><p><code>objects</code> 模型最重要的属性是Manager。它是Django 模型进行数据库查询操作的接口，并用于从数据库获取实例。如果没有自定义Manager，则默认的名称为objects。Managers 只能通过模型类访问，而不能通过模型实例访问。</p><p>Manager 称为管理器 ，它是一个类，该类下面有多个方法，比如get，all，filter 方法，它们都属于这个管理器，你也可以重写一个新的管理器，实现新的查询方法。通常的 Objects.get()，就是指向该类下的方法。</p><h3 id="类的扩展"><a href="#类的扩展" class="headerlink" title="类的扩展"></a>类的扩展</h3><p>创建一个可公共使用的模型，他的字段将被其他模型包含，这个模型称为：<code>抽象基类</code>。</p><p>当你想将一些共有信息放进其它一些model的时候，抽象化类是十分有用的。你编写完基类之后，在 <code>Meta</code> 类中设   <code>abstract=True</code>，这个模型就不会被用来创建任何数据表。取而代之的是，当它被用来作为一个其他model的基类时，它的字段将被加入那些子类中。如果抽象基类和它的子类有相同的字段名，那么将会出现 <code>error（并且Django将抛出一个exception）</code>。</p><p>一个例子：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>db <span class="token keyword">import</span> models<span class="token keyword">class</span> <span class="token class-name">CommonInfo</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>    name <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span>    age <span class="token operator">=</span> models<span class="token punctuation">.</span>PositiveIntegerField<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">class</span> <span class="token class-name">Meta</span><span class="token punctuation">:</span>        abstract <span class="token operator">=</span> <span class="token boolean">True</span><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">(</span>CommonInfo<span class="token punctuation">)</span><span class="token punctuation">:</span>    home_group <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Student 模型将有三个项：name，age 和 home_group。CommonInfo 模型无法像一般的Django模型一样使用，因为它是一个抽象基类。它无法生成一张数据表或者拥有一个管理器，并且不能实例化或者直接储存。</p><p>许多应用场景下, 这种类型的模型继承恰好是你想要的。它提供一种在 Python 语言层级上提取公共信息的方式，同时在数据库层级上，每个子类各自仍然只创建一个数据库表。</p><p><code>多表继承</code></p><p>这是 Django 支持的第二种继承方式。使用这种继承方式时，每一个层级下的每个 model 都是一个真正意义上完整的 model 。每个 model 都有专属的数据表，都可以查询和创建数据表。继承关系在子 model 和它的每个父类之间都添加一个链接 (通过一个自动创建的 OneToOneField来实现)。 </p><p>例如：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>db <span class="token keyword">import</span> models<span class="token keyword">class</span> <span class="token class-name">Place</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>    name <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">)</span>    address <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Restaurant</span><span class="token punctuation">(</span>Place<span class="token punctuation">)</span><span class="token punctuation">:</span>    serves_hot_dogs <span class="token operator">=</span> models<span class="token punctuation">.</span>BooleanField<span class="token punctuation">(</span>default<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>    serves_pizza <span class="token operator">=</span> models<span class="token punctuation">.</span>BooleanField<span class="token punctuation">(</span>default<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Place里面的所有字段在 Restaurant中也是有效的，只不过数据保存在另外一张数据表当中。所以下面两个语句都是可以运行的：</p><pre class="line-numbers language-sh"><code class="language-sh">>>> Place.objects.filter(name="Bob's Cafe")>>> Restaurant.objects.filter(name="Bob's Cafe")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>代理继承</code></p><p>使用多表继承时，model 的每个子类都会创建一张新数据表，通常情况下，这正是我们想要的操作。这是因为子类需要一个空间来存储不包含在基类中的字段数据。但有时，你可能只想更改 model 在 Python 层的行为实现。比如：更改默认的 manager ，或是添加一个新方法。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>db <span class="token keyword">import</span> models<span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>    first_name <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">)</span>    last_name <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">MyPerson</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">class</span> <span class="token class-name">Meta</span><span class="token punctuation">:</span>        proxy <span class="token operator">=</span> <span class="token boolean">True</span>    <span class="token keyword">def</span> <span class="token function">do_something</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># ...</span>        <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它们都操作同一个数据表，设置 proxy = Ture 实现代理，为Person 模型添加了一个方法<br>你可以在代理中重写方法，或者改变某一字段的排序，不会对原始模型产生影响。比如你用原模型<br>查询a字段是无序的，你在代理中对a字段元属性进行了排序，用代理模型去查询就是有序的。</p><h2 id="模型对应关系"><a href="#模型对应关系" class="headerlink" title="模型对应关系"></a>模型对应关系</h2><p>框架实现了大部分字段了，文件，图片都有，关于文件如果用到可以仔细看看，另外有模型API，方便获取对象的信息，这对于开发很有用。</p><h3 id="一对一和一对多"><a href="#一对一和一对多" class="headerlink" title="一对一和一对多"></a>一对一和一对多</h3><p>一对多比较了解了，被to的模型，通常会被多个表to。如果字段是外键，并且这个外键只被这个字段to那么这个时候就可以用一对一了，就是这个被to的模型，一张表只被另一张表to（不知道再被另一张表to的时候会发生什么）。通常用来做详情或扩展，比如用户的扩展，那么扩展内容可以是一个新的模型，因为这些内容是和用户相关的，所以应该一条详情对应一个用户，就可以用一对一。</p><p>使用一对一模型，在查询的时候，这个被关联的字段可以互相取到双方的值。</p><p>如 <code>user</code> 有 <code>detail</code> 对到模型 <code>detail</code>：</p><pre class="line-numbers language-python"><code class="language-python">u <span class="token operator">=</span> user<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>filter<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">(</span><span class="token punctuation">)</span>u<span class="token punctuation">.</span>detail<span class="token punctuation">.</span>msg<span class="token comment" spellcheck="true"># 反向查询</span>d <span class="token operator">=</span> detail<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>filter<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">(</span><span class="token punctuation">)</span>d<span class="token punctuation">.</span>user<span class="token punctuation">.</span>name<span class="token comment" spellcheck="true"># 一对多，上面的详情变成了class</span>u <span class="token operator">=</span> user<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>filter<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">(</span><span class="token punctuation">)</span>u<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span>msg<span class="token comment" spellcheck="true"># 反向查询</span>c <span class="token operator">=</span> <span class="token keyword">class</span><span class="token punctuation">.</span>objects<span class="token punctuation">.</span>filter<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>user_set<span class="token punctuation">.</span>all<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 返回查询集</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>反向查询如果设置了 <code>related_name</code>，比如 <code>class_user</code>，可以这样 <code>c.class_user</code>，默认用 <code>表名_set</code>。</p><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>一般通过外键，新建一个表，把两张表联系起来，实现多对多。或者在其中一个模型里面建立多对多字段。<br>此时进行正向查询，不会像一对多那样得到外键id或对象，应该 <code>.all()</code> 得到查询集（一对多方向才得到查询集），反向查询也是得到查询集，反向查询也是可以用 <code>related_name</code>。</p><h3 id="什么时候用多对多"><a href="#什么时候用多对多" class="headerlink" title="什么时候用多对多"></a>什么时候用多对多</h3><p>对于一对多来说，被to的可以说是独立的，它可以不依赖其它模型，比如学生和班级，班级就是班级，而学生要和班级建立关系就用一对多，班级被to了，才会通过反向查询得到所有的学生。</p><p>对于上诉情况也会有特殊情况，上诉情况比较实用于中学，中学就是一个学生属于一个班级，如果在大学，我们进行选课，那么课程会是一个模型，一个学生会选择多个课程，这个时候用多对多就比较合适了，当然也可以通过第三张表将课程和学生建立关系，用一对多来实现。</p><p>被用做多对多的字段，创建对象的时候，如何赋值，add, set, remove, clear。</p><h2 id="查询与数据库"><a href="#查询与数据库" class="headerlink" title="查询与数据库"></a>查询与数据库</h2><p>框架ORM查询补充</p><h3 id="数据迁移与修改模型"><a href="#数据迁移与修改模型" class="headerlink" title="数据迁移与修改模型"></a>数据迁移与修改模型</h3><p>迁移功能非常强大，可以让你在开发过程中不断修改你的模型而不用删除数据库或者表然后再重新生成一个新的 —— 它专注于升级你的数据库且不丢失数据。实现模型变更的三个步骤：</p><ol><li>修改你的模型（在models.py文件中）</li><li>运行python manage.py makemigrations ，为这些修改创建迁移文件</li><li>运行python manage.py migrate ，将这些改变更新到数据库中</li></ol><p>将生成和应用迁移文件的命令分成几个命令来执行，是因为你可能需要将迁移文件提交到你的版本控制系统中并跟随你的应用一起变化；这样做不仅可以使开发变得更加简单，而且对其他开发者以及上线生产非常有用。</p><h3 id="跨关联关系的查询"><a href="#跨关联关系的查询" class="headerlink" title="跨关联关系的查询"></a>跨关联关系的查询</h3><p>可以像这样，只需使用关联的模型字段的名称，并使用双下划线分隔，直至你想要的字段</p><p><code>dquery = DrawMoneyRecord.objects.filter(drawuser__district__name__icontains='西山片区')</code></p><p>发现当关联的字段有null的时候，查询不到结果。比如模型DMR有三张表，三张都有drawuser，到了drawuser外键对应的模型User的时候，有两张User的表，其中一张district字段为null，此时查询失效，需保证有关联的都不能为null。</p><p>它还可以反向工作。若要引用一个“反向”的关系，只需要使用该模型的小写的名称。</p><p>比如 Order 和  OrderItem ，它们的对应关系为：</p><p><code>order = models.ForeignKey(to=Order, verbose_name=_('订单'), editable=False)</code></p><p>想要从Order来查：<code>Order.objects.filter(orderitem__name__icontains='小')</code>，便可以利用orderitem来查出order</p><p>反向查询，关系是从右看到左：</p><p><code>AgencyOrder.objects.filter(agencyorderitem__orderitem__order_id__in=order_ids)</code></p><p>上面这个order_ids可以得到order，向上得到orderitem…</p><p>order__bigorder__date</p><h3 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h3><p>prefetch_related  select_related </p><p>都是针对表有关联的，如果不用，则拿到的只是外键的id，如果使用，则一次就把外键对象拿到。</p><h3 id="打印-SQL-语句"><a href="#打印-SQL-语句" class="headerlink" title="打印 SQL 语句"></a>打印 SQL 语句</h3><ol><li>确保 <code>django.core.context_processors.debug</code> 在 <code>CONTEXT_PROCESSORS</code> 中</li><li>DEBUG = True</li></ol><p>代码如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>db <span class="token keyword">import</span> connection<span class="token comment" spellcheck="true"># 这里是查询</span>MyModel<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>filter<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"my name"</span><span class="token punctuation">)</span><span class="token keyword">print</span> connection<span class="token punctuation">.</span>queries<span class="token comment" spellcheck="true"># 或者</span><span class="token keyword">from</span> django<span class="token punctuation">.</span>db <span class="token keyword">import</span> connection<span class="token keyword">print</span> MyModel<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>filter<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"my name"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>query<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="save-方法"><a href="#save-方法" class="headerlink" title="save 方法"></a>save 方法</h3><p>一般在得到查询集后，只有是去创建的情况才使用 <code>queryset.save()</code>，对于数据的修改，使用 <code>quseryset.save(update_fields=['fields'])</code>。</p><h3 id="查询对象-F，Q"><a href="#查询对象-F，Q" class="headerlink" title="查询对象 F，Q"></a>查询对象 F，Q</h3><p>F用来做运算，加减乘除。Q做复杂查询。</p><h3 id="查询对象Case"><a href="#查询对象Case" class="headerlink" title="查询对象Case"></a>查询对象Case</h3><pre class="line-numbers language-py"><code class="language-py">equipments = equipments.order_by(    Case(When(id__in=[item.get('eqid', 0) for item in equipment_ids], then=0), default=1), '-ismonitor', 'id')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>equipments中，先把id为特定条件的数据放到最前面，然后后面的数据按照<code>'-ismonitor', 'id'</code>的规则进行排序</p><h3 id="查询集"><a href="#查询集" class="headerlink" title="查询集"></a>查询集</h3><p>查询集，就是查询结果的集合。</p><p>Blog.objects.all() 返回包含数据库中所有 Blog 对象的一个查询集。</p><ul><li>filter(**kwargs) 返回一个新的查询集，它包含满足查询参数的对象。</li><li>exclude(**kwargs) 返回一个新的查询集，它包含不满足查询参数的对象。</li></ul><p>通过 get 获取一个单一的对象 <code>one_entry = Entry.objects.get(pk=1)</code></p><p>queryset是查询集，就是传到服务器上的url里面的查询内容。Django会对查询返回的结果集QuerySet进行缓存，这是为了提高查询效率。也就是说，在你创建一个QuerySet对象的时候，Django并不会立即向数据库发出查询命令，只有在你需要用到这个QuerySet的时候才会这样做。</p><p>缓存和查询集：</p><p>每个查询集都包含一个缓存来最小化对数据库的访问。理解它是如何工作的将让你编写最高效的代码。<br>在一个新创建的查询集中，缓存为空。首次对查询集进行求值 —— 同时发生数据库查询 ——Django 将保存查询的结果到查询集的缓存中并返回明确请求的结果（例如，如果正在迭代查询集，则返回下一个结果）。接下来对该查询集 的求值将重用缓存的结果。<br>请牢记这个缓存行为，因为对查询集使用不当的话，它会坑你的。例如，下面的语句创建两个查询集，对它们求值，然后扔掉它们：</p><pre class="line-numbers language-sh"><code class="language-sh">>>> print([e.headline for e in Entry.objects.all()])>>> print([e.pub_date for e in Entry.objects.all()])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这意味着相同的数据库查询将执行两次，显然倍增了你的数据库负载。同时，还有可能两个结果列表并不包含相同的数据库记录，因为在两次请求期间有可能有Entry被添加进来或删除掉。为了避免这个问题，只需保存查询集并重新使用它：</p><pre class="line-numbers language-sh"><code class="language-sh">>>> queryset = Entry.objects.all()>>> print([p.headline for p in queryset]) # Evaluate the query set.>>> print([p.pub_date for p in queryset]) # Re-use the cache from the evaluation.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="查询集方法"><a href="#查询集方法" class="headerlink" title="查询集方法"></a>查询集方法</h3><ul><li>order_by 排序</li><li>pk__in  当需要取多个结果的时候，比如id=1,2,3这三条数据，<code>models.object.filter(pk__in = ids)</code>，ids=[1,2,3]</li><li>select_related()函数 在一对一和外键中使用，目的：减少查询次数</li></ul><p>关联查询例子：</p><p>Person(人)，字段中有一个居住地living，living外键到City，City 中有 province(省)，如何直接得到省的数据？</p><pre class="line-numbers language-py"><code class="language-py">p=Person.object.select_related('living').get(name="小明")p.living.province<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果省是其它的外键，比如 province外键到 Province类，查询集要用 <code>' __ '</code>，<code>p=Person.object.select_related('living__province').get(name="小明")</code>。</p><p>常用方法：</p><table><thead><tr><th>Command</th><th align="center">Description</th></tr></thead><tbody><tr><td>__exact</td><td align="center">精确等于 like ‘aaa’</td></tr><tr><td>__iexact</td><td align="center">精确等于 忽略大小写 ilike ‘aaa’</td></tr><tr><td>__contains</td><td align="center">包含 like ‘%aaa%’</td></tr><tr><td>__icontains</td><td align="center">包含 忽略大小写 ilike ‘%aaa%’，但是对于sqlite来说，contains的作用效果等同于icontains。</td></tr><tr><td>__gt</td><td align="center">大于</td></tr><tr><td>__gte</td><td align="center">大于等于</td></tr><tr><td>__lt</td><td align="center">小于</td></tr><tr><td>__lte</td><td align="center">小于等于</td></tr><tr><td>__in</td><td align="center">存在于一个list范围内</td></tr><tr><td>__startswith</td><td align="center">以…开头</td></tr><tr><td>__istartswith</td><td align="center">以…开头 忽略大小写</td></tr><tr><td>__endswith</td><td align="center">以…结尾</td></tr><tr><td>__iendswith</td><td align="center">以…结尾，忽略大小写</td></tr><tr><td>__range</td><td align="center">在…范围内</td></tr><tr><td>__year</td><td align="center">日期字段的年份</td></tr><tr><td>__month</td><td align="center">日期字段的月份</td></tr><tr><td>__day</td><td align="center">日期字段的日</td></tr><tr><td>__isnull=True/False</td><td align="center"></td></tr><tr><td>__isnull=True</td><td align="center">与 __exact=None的区别</td></tr></tbody></table><p>例子：<br>类是 Author 字段 username，password </p><pre class="line-numbers language-py"><code class="language-py">Author.objects.filter(username__exact=username)   #精准查询k=Author.objects.filter(username__exact=username)obj=Author.objects.get(username__exact=username)   #get 取得的是字段为username<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>匹配的对象：在使用update的时候，需要注意，查询集才有这个方法，查询集实例没有，查询集有5个，update可以一次更新5张表的数据。</p><h3 id="分页实现"><a href="#分页实现" class="headerlink" title="分页实现"></a>分页实现</h3><p>两个参数 page，limit 每次都传这两个参数，决定了数据的截取位置和截取多少。</p><p><code>query[ (page-1)*limit : page*limit ]</code></p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li>对于模型的新创建的实例，直接save()就行了，不能用 <code>save(update_fields=[])</code>，本来就没有字段，所以不能用。如果是QS的元素，考虑使用 <code>save(update_fields=[])</code>，它只更新特定的字段。 </li><li>对于QS，可以使用QS.update(field=value)，批量跟新。</li></ul><p><code>django queryset</code> 的 <code>values</code> 和 <code>values_list(values_list('id', flat=true))</code></p><p>这两个函数可以得到特定字段的值，有些字段是外键，我们在表示的时候，需要的是外键所对应的对象，利用这个外键id,查到数据后，将查到的对象添加到刚才的列表中去。</p><ul><li>去除重复：distinct</li></ul><p>distinct()可以对查询集进行去重复，比如querset.distinct(),  得到的查询集元素都是唯一的对象。（有些时候，我们用id__in去得到的数据会有好几个，比如一个模型的两张表字段外键都是对到同一个，这个时候id__in 就会得到两个查询集对象，但是这个去重一般是在想处理相同字段的时候使用）当我们想去除字段相同的数据的时候，<code>querset.values(fields).distinct().order_by('fields')</code>, 这个操作会返回dict, 这里需要排序的原因是如果不排序。在执行distinct的时候，使用默认排序id, 两列数据id是不一样的，只有我们想去重的字段是一样的，所以要以想去重的字段为准，执行一次排序。</p><ul><li><p>在做查询的时候，filter的参数如果是None，就是把模型中该字段为null的查出来</p></li><li><p>sql：EXISTS用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回值True或False。EXISTS 指定一个子查询，检测 <code>行</code> 的存在。django也可以用这个方法，对于queryset.exists()即可</p></li><li><p>aggregate和annotate方法使用详解与示例</p></li></ul><p><a href="https://blog.csdn.net/weixin_42134789/article/details/84567365" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42134789/article/details/84567365</a></p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>默认情况下，django的sql执行都是在事务中进行的，MySQL一般都是开启默认事务提交的，正常情况下，sql语句必须要开启事务，如何才能提交事务。而django的sql的执行会默认在事务中，避免了脏读。</p><p>在Django中使用事务：<code>@transaction.atomic</code> 该装饰器将装饰内容由事务来处理，也就是把多个sql执行封装在一个事务里面。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>项目目录下的 <code>manage.py</code> 接受输入参数，执行对应命令。</p><ul><li>python manage.py validate 验证模型的有效性</li><li>python manage.py migrate  创建数据库表</li><li>python manage.py makemigrations polls  关联应用，激活模型（现在Django知道要包含polls应用。 可以运行这个命令）</li><li>sqlmigrate    展示迁移的SQL语句</li></ul><p>如果在后面的开发中需要更改模型，先在代码中加入新的字段，然后执行 <code>迁移命令</code>，再执行数据库创建命令。</p><ul><li>python manage.py makemigrations （根据模型给应用生成迁移脚本）</li><li>python manage.py migrate</li><li>python mange.py shell 进入交互式shell</li></ul><p>各种修改表后，可能会导致表无法创建（历史原因，可能），执行命令来同步表（遇到场景，提示字段名字重复，创建了字段后，又修改，删除migrations，创建），可以执行以下命令：</p><pre class="line-numbers language-sh"><code class="language-sh">python manage.py migrate myapp --fake<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="创建管理员"><a href="#创建管理员" class="headerlink" title="创建管理员"></a>创建管理员</h3><p>首先，我们需要创建一个能够登录管理站点的用户。 </p><p>运行如下命令：</p><ol><li><p><code>$ python manage.py createsuperuser</code> 键入你想要使用的用户名，然后按下回车键</p></li><li><p><code>Username: admin</code> 然后提示你输入想要使用的邮件地址</p></li><li><p><code>Email address: admin@example.com</code> 你将被要求输入你的密码两次，第二次输入是确认密码</p></li></ol><pre><code>Password: **********Password (again): *********Superuser created successfully.</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置修改setting.py文件</p><h3 id="Django设置TIME-ZONE"><a href="#Django设置TIME-ZONE" class="headerlink" title="Django设置TIME_ZONE"></a>Django设置TIME_ZONE</h3><p>Django默认的timezone是 <code>TIME_ZONE = 'America/Chicago'</code>，现在要改成我们中国的时区 只需编辑settings.py文件，把time_zone的值改成TIME_ZONE=即可。</p><h2 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h2><p>模版语法可以快速开发页面，<strong>不过对于前后端分离的项目，基本没什么用了</strong>。</p><ul><li>使用模板，实现动态的生成HTML。模板包含所需HTML输出的静态部分，以及一些特殊的语法，描述如何将动态内容插入。</li><li>Django 为加载和渲染模板定义了一套标准的API，与具体的后台无关。</li><li>加载包括根据给定的标识找到模板然后预处理，通常会将它编译好放在内存中。</li><li>渲染表示使用Context 数据对模板插值并返回生成的字符串。</li></ul><p>注意在django工程的设置中，模板设置里面，APP_DIRS设置为True，这样就允许查找应用下的模板。这里的应用包括自己创建和系统的，可以查看设置文件看看该项目有哪些应用。只要在该项目下有过Template文件夹，django就可以找到模板。</p><p>模板语言：</p><p>变量 {{ }}，变量的值来自于context中的输出</p><p>句点查找，就是  .  查找，比如 {{ f.b }}，将按照一定顺序的查找规则。<br>字典，属性，方法调用，列表类型索引。  </p><p>系统使用所找到的第一个有效类型，这是一种短路逻辑它可以嵌套，比如 { { f.a.bv(&nbsp;) }}，按顺序来，如果a没有找到，就去找bv()。</p><h3 id="Django-模板中的HTML自动转义"><a href="#Django-模板中的HTML自动转义" class="headerlink" title="Django 模板中的HTML自动转义"></a>Django 模板中的HTML自动转义</h3><p>当用户输入的信息是一个JS脚本的时候，这个时候浏览器会执行脚本，难免会有漏洞。所以不能进行转义。</p><p>可以使用模板过滤器：safe</p><p>例子： </p><pre><code>hello {{name|safe}}</code></pre><h3 id="自定义标签"><a href="#自定义标签" class="headerlink" title="自定义标签"></a>自定义标签</h3><p>我们可以创建一个模板库，里面包含我们自己写的标签和过滤器。在应用目录下创建一个templates文件夹，该文件创建一个文件<br><code>__init__.py</code>，说明它是一个模块，如何就可以写自定义的 <code>.py</code> 标签过滤器。</p><p>在模板中 <code>{% raw %}{% load poll_extras %}{% endraw %}</code> 便可以将标签载入，load后面的是写的.py。</p><p><code>{% raw %}{% load %}{% endraw %}</code> 标签检查 INSTALLED_APPS 中的设置，仅允许加载已安装的Django应用程序中的<br>模板库。这是一个安全特性。它可以让你在一台电脑上部署很多的模板库的代码，而又不用把它们<br>暴露给每一个Django安装。</p><h3 id="url-标签"><a href="#url-标签" class="headerlink" title="url 标签"></a>url 标签</h3><pre class="line-numbers language-py"><code class="language-py">urlpatterns = patterns('',        (r'^article$','news_index' ),)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/article<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>资讯<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通常我们的URL都是硬编码的，在模板里面可能会有多个标签都是一个url，如果你要改变这个url，那么模板里面所有的url都要改变，这时候我们可以使用url标签。</p><pre class="line-numbers language-py"><code class="language-py">urlpatterns = patterns('',        url(r'^article$','news_index' ，name="news_index"),)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{%url <span class="token punctuation">'</span>news_index<span class="token punctuation">'</span>%}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>资讯<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>增加一个nema，当你改变原来的url时，模板的地址也会随之改变，在view中使用 <code>HttpResponseRedirect("/article")</code>。</p><p>使用 <code>reverse()</code> 函数 <code>HttpResponseRedirect(reverse("news_index"))</code>。</p><p>带参数的url </p><pre class="line-numbers language-py"><code class="language-py">url(r'^(?P<year>\d{4})/(?P<month>\d{1,2})/$','news_list',name="news_archive" )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{%url <span class="token punctuation">'</span>news_archive<span class="token punctuation">'</span> 2010  02%}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>2010年02月<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者这样:</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{%url <span class="token punctuation">'</span>news_archive<span class="token punctuation">'</span> year<span class="token punctuation">=</span>2010  month<span class="token punctuation">=</span>02%}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>2010年02月<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h3><p>创建一个基本的骨架模板，将里面的部分内容用其它模板来替换。</p><pre class="line-numbers language-html"><code class="language-html">{% block title %}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Home<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/blog/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Blog<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>{% endblock %}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个模板中，使用block标签， block 告诉模版引擎：子模版可能会覆盖掉模版中的这些位置。</p><p>只是可能替换，不一定非要替换，如果没被替换，输出是原样：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Home<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/blog/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Blog<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在子模板中，同样是block标签。比如</p><pre class="line-numbers language-html"><code class="language-html">{% block title %}My amazing blog{% endblock %}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>则原模板在使用的时候，它的title包围的块被替换成 <code>My amazing blog</code>，子模板在开头加上extend标签，说明继承关系：</p><pre class="line-numbers language-html"><code class="language-html">{% extends "base.html" %}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果需要获得父模板中代码块的内容，可以使用 </p><blockquote></blockquote><p>如果只想在上级代码块基础上添加内容，而<br>不是全部重载，该变量就显得非常有用了。</p><p>过滤器可以自己定义，记得在设置中添加路径<br>自定义的过滤器添加了才有用，继承中没有添加过的过滤器不能使用</p><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>Django自带了大约24个内置的模版标签。你可以在内置标签参考手册中阅读全部关于它们的内容。</p><p>标签在渲染的过程中提供任意的逻辑。</p><p>这个定义是刻意模糊。例如，一个标签可以输出内容，作为控制结构，例如“if”语句或“for”循环从数据库中提取内容，甚至可以访问其他的模板标签。Tags是由 <code>{%   %}</code> 来定义的。</p><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>更改变量或标签参数的值</p><p><code>{{ django|title }}</code> 把django变量的内容开头是小写的变成大写</p><p>过滤器能够被“串联”。一个过滤器的输出将被应用到下一个。<code>{{ text|escape|linebreaks }}</code> 就是一个常用的过滤器链，它编码文本内容，然后把行打破转成 <code>&lt;p&gt;</code> 标签。</p><p>一些过滤器带有参数。过滤器的参数看起来像是这样：<code>{{ bio|truncatewords:30 }}</code>。这将显示 bio 变量的前30个词。<br>过滤器参数包含空格的话，必须被引号包起来；例如，使用逗号和空格去连接一个列表中的元素，你需要使用 <code>{{ list|join:", " }}</code>。</p><p>Django提供了大约六十个内置的模版过滤器。你可以在 内置过滤器参考手册中阅读全部关于它们的信息。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>`` 这样完成类注释，注释的内容不会在模板渲染时输出。</p><p>要注意的是，注释不会跨多行比如：</p><pre><code>This is a test.</code></pre><p>这个注释是无效的。</p><h3 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h3><p>ifequal：输出第一个判断为True的值</p><h2 id="其它功能"><a href="#其它功能" class="headerlink" title="其它功能"></a>其它功能</h2><ul><li>发送信号：在特点操作完成前后都可以发送信息，比如数据save()</li><li>聚合内容（RSS ATOM）</li><li>静态文件收集：方便部署</li><li>验证器：用在模型字段参数里面，对字段的值进行验证<br>froms:表单模型，表单相关，验证器可以在表单模型字段里面使用（表单模型不是我常用的东西）</li><li>日志记录模块</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Framework </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-patter 相关设计模式</title>
      <link href="/2018/10/22/Python/patter/"/>
      <url>/2018/10/22/Python/patter/</url>
      
        <content type="html"><![CDATA[<p>Python常见设计模式总结</p><a id="more"></a><h2 id="Borg-模式"><a href="#Borg-模式" class="headerlink" title="Borg 模式"></a>Borg 模式</h2><p>这个模式创建的实例，属性都是共享的</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">borg</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>    cls<span class="token punctuation">.</span>_state <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    orig_init <span class="token operator">=</span> cls<span class="token punctuation">.</span>__init__    <span class="token keyword">def</span> <span class="token function">new_init</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>__dict__ <span class="token operator">=</span> cls<span class="token punctuation">.</span>_state        orig_init<span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>    cls<span class="token punctuation">.</span>__init__ <span class="token operator">=</span> new_init    <span class="token keyword">return</span> cls@borg<span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>a <span class="token operator">=</span> A<span class="token punctuation">(</span><span class="token punctuation">)</span>a<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token string">'2'</span>b <span class="token operator">=</span> A<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>b<span class="token punctuation">,</span> b<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Pool-对象池模式"><a href="#Pool-对象池模式" class="headerlink" title="Pool 对象池模式"></a>Pool 对象池模式</h2><p>以下代码实现了维护一定线程池</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">import</span> threading<span class="token keyword">from</span> contextlib <span class="token keyword">import</span> contextmanager<span class="token keyword">class</span> <span class="token class-name">ObjectPool</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> klass<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> max_size<span class="token operator">=</span>None<span class="token punctuation">,</span> timeout<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>_klass <span class="token operator">=</span> klass        self<span class="token punctuation">.</span>_max_size <span class="token operator">=</span> max_size        self<span class="token punctuation">.</span>_size <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>_args <span class="token operator">=</span> args        self<span class="token punctuation">.</span>_kwargs <span class="token operator">=</span> kwargs        self<span class="token punctuation">.</span>_tiemout <span class="token operator">=</span> timeout        self<span class="token punctuation">.</span>_items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>_mutex <span class="token operator">=</span> threading<span class="token punctuation">.</span>Lock<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>_item_available <span class="token operator">=</span> threading<span class="token punctuation">.</span>Condition<span class="token punctuation">(</span>self<span class="token punctuation">.</span>_mutex<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">with</span> self<span class="token punctuation">.</span>_mutex<span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>_items <span class="token operator">and</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>_max_size <span class="token keyword">is</span> None <span class="token operator">or</span>                                    self<span class="token punctuation">.</span>_size <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>_max_size<span class="token punctuation">)</span><span class="token punctuation">:</span>                item <span class="token operator">=</span> self<span class="token punctuation">.</span>_klass<span class="token punctuation">(</span><span class="token operator">*</span>self<span class="token punctuation">.</span>_args<span class="token punctuation">,</span> <span class="token operator">**</span>self<span class="token punctuation">.</span>_kwargs<span class="token punctuation">)</span>                self<span class="token punctuation">.</span>_size <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>_items<span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>_item_available<span class="token punctuation">.</span>wait<span class="token punctuation">(</span>self<span class="token punctuation">.</span>_tiemout<span class="token punctuation">)</span>                item <span class="token operator">=</span> self<span class="token punctuation">.</span>_items<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> item    <span class="token keyword">def</span> <span class="token function">put</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">with</span> self<span class="token punctuation">.</span>_mutex<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>_items<span class="token punctuation">.</span>append<span class="token punctuation">(</span>item<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>_item_available<span class="token punctuation">.</span>notify<span class="token punctuation">(</span><span class="token punctuation">)</span>    @contextmanager    <span class="token keyword">def</span> <span class="token function">item</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        item <span class="token operator">=</span> self<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            <span class="token keyword">yield</span> item        <span class="token keyword">finally</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>put<span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>a <span class="token operator">=</span> a        self<span class="token punctuation">.</span>b <span class="token operator">=</span> bpool <span class="token operator">=</span> ObjectPool<span class="token punctuation">(</span>Test<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> max_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">with</span> pool<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> item<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'&lt;{item.__class__.__name__} at {id(item)}>'</span><span class="token punctuation">)</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    threads <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        t <span class="token operator">=</span> MyThread<span class="token punctuation">(</span><span class="token punctuation">)</span>        t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>        threads<span class="token punctuation">.</span>append<span class="token punctuation">(</span>t<span class="token punctuation">)</span>    <span class="token keyword">for</span> t <span class="token keyword">in</span> threads<span class="token punctuation">:</span>        t<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytest web 开发中的单元测试工具</title>
      <link href="/2018/10/22/Python/pytest/"/>
      <url>/2018/10/22/Python/pytest/</url>
      
        <content type="html"><![CDATA[<p>pytest，Python的单元测试工具，用于web开发中做测试，使用也比较简单。关于测试又是一个大的分支，编写测试代码也有一定的套路，比如测试细节步骤，测试各个接口，但是个人认为测试一个整体的模块结果会比较容易。</p><p>另外不要为了测试而写测试，测试应该和业务代码相互结合，有些业务代码确实不好测试，有些过于简单又不用测，这导致测试的效率，测试的覆盖程度大大折扣，所以又衍生出<code>基于测试驱动开发的模式</code>，一开始就考虑好如何测试，如何编写代码，集成的时候以测试结果作为评审依据，让整个系统更加健壮。</p><p>所以，好的架构要有测试用例，测试用例还能用来理解代码，不要在系统都开发到一大半的时候，才来考虑测试的问题，这个时候测试代码很难接入，要么对各个接口做单独测试，要么把业务抽象出来，测试大功能。</p><a id="more"></a><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><pre class="line-numbers language-sh"><code class="language-sh">py.testpy.test --versionpy.test name.pypy.test --resultlog=report  保存测试报告py.test               # run all tests below current dir  py.test test_mod.py   # run tests in module  py.test somepath      # run all tests below somepath  py.test -k stringexpr # only run tests with names that match the                        # the "string expression", e.g. "MyClass and not method"                        # will select TestMyClass.test_something                        # but not TestMyClass.test_method_simple  py.test test_mod.py::test_func  # only run tests that match the "node ID",                                  # e.g "test_mod.py::test_func" will select                                  # only test_func in test_mod.py  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>测试文件以test_开头（以_test结尾也可以）</li><li>测试类以Test开头，并且不能带有 <strong>init</strong> 方法</li><li>测试函数以test_开头</li><li>断言使用基本的assert即可</li></ul><h2 id="相关装饰器讲解"><a href="#相关装饰器讲解" class="headerlink" title="相关装饰器讲解"></a>相关装饰器讲解</h2><blockquote><p>@pytest.fixture(scope=”module”)</p></blockquote><p>这个装饰器会让被装饰的函数只执行一次，通常用来装饰需要在多个测试直接使用到的同一个变量，例如：</p><pre><code>@pytest.fixture(scope='module')def get_result():    return 1</code></pre><blockquote><p>把上面的代码放入conftest.py 文件中（经测试这个文件名字不能改，不知道为什么）</p></blockquote><p>这样在其它测试文件中，我们可以把get_result做为参数传入，例如：<br>文件  test_func.py</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">TestApi</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">test_func</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> get_result<span class="token punctuation">)</span><span class="token punctuation">:</span>        a <span class="token operator">=</span> get_result        <span class="token keyword">assert</span> a <span class="token operator">!=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>pytest.mark.usefixtures  装饰器的使用，就是显式的调用，先用@pytest.fixture()把需要公用的函数做装饰，使用的时候通过pytest.mark.usefixtures装饰，就可以得到公用函数了，下面展示了使用三种方法：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> pytest@pytest<span class="token punctuation">.</span>fixture<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\nbefore each test'</span><span class="token punctuation">)</span>@pytest<span class="token punctuation">.</span>mark<span class="token punctuation">.</span>usefixtures<span class="token punctuation">(</span><span class="token string">"before"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">test_1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'test_1()'</span><span class="token punctuation">)</span>@pytest<span class="token punctuation">.</span>mark<span class="token punctuation">.</span>usefixtures<span class="token punctuation">(</span><span class="token string">"before"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">test_2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'test_2()'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Test1</span><span class="token punctuation">:</span>    @pytest<span class="token punctuation">.</span>mark<span class="token punctuation">.</span>usefixtures<span class="token punctuation">(</span><span class="token string">"before"</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">test_3</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'test_1()'</span><span class="token punctuation">)</span>    @pytest<span class="token punctuation">.</span>mark<span class="token punctuation">.</span>usefixtures<span class="token punctuation">(</span><span class="token string">"before"</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">test_4</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'test_2()'</span><span class="token punctuation">)</span>@pytest<span class="token punctuation">.</span>mark<span class="token punctuation">.</span>usefixtures<span class="token punctuation">(</span><span class="token string">"before"</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Test2</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">test_5</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'test_1()'</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">test_6</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'test_2()'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于 fixture 的scope参数</p><ul><li>function：每个test都运行，默认是function的scope </li><li>class：每个class的所有test只运行一次 </li><li>module：每个module的所有test只运行一次 </li><li>session：每个session只运行一次</li></ul><p>比如你的所有test都需要连接同一个数据库，那可以设置为module，只需要连接一次数据库，对于module内的所有test，这样可以极大的提高运行效率。</p><p>autouse 参数</p><p>这个参数默认是Fals, 设置为True的时候，一个session的所有test都会自动调用autouse设置为True的fixture。就是自动调用了，你都不需要把fixture作为参数传入，比如你的fixture写成打印一些友好提示，这样在每个测试执行的时候，这些提示都会打印出来。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gunicorn python 应用服务器</title>
      <link href="/2018/10/22/Python/gunicorn/"/>
      <url>/2018/10/22/Python/gunicorn/</url>
      
        <content type="html"><![CDATA[<p>Gunicorn ‘Green Unicorn’ is a Python WSGI HTTP Server for UNIX. It’s a pre-fork worker model. The Gunicorn server is broadly compatible with various web frameworks, simply implemented, light on server resources, and fairly speedy.</p><a id="more"></a><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><pre><code>gunicorn -w 2 --threads=4 application:app -b localhost:8080gunicorn -c HttpTest/gunicorn.py HttpTest.wsgi:application 指定配置文件</code></pre><p>-w 指启动的进程数量如2</p><p><code>ps -ef|grep python</code> 可以看到python共有3个进程，其中一个主进程和两个work进程（两个work进程是master的子进程）</p><p>注意，线程配置<br>threads = 100 </p><p>假如用sync模式，线程数不能不设置，否则就是1，即分发到每个工作进程的线程只能有1，一定要配，如果是其它模式，协程和io多路复用都只需要1个线程，配置无用</p><p>gunicorn 工作模式</p><ul><li>sync 默认使用同步阻塞的网络模型（-k sync）</li><li>eventlet - Requires eventlet &gt;= 0.9.7</li><li>gevent - Requires gevent &gt;= 0.13</li><li>tornado - Requires tornado &gt;= 0.2</li><li>gthread - Python 2 requires the futures package to be installed</li><li>gaiohttp - Requires Python 3.4 and aiohttp &gt;= 0.21.5</li></ul><p>使用 <code>-k</code> 指定工作模式</p><p>Linux进程有父进程和子进程之分，windows的进程是平等关系</p><p>gunicorn的同步模式，一次只处理一个请求，虽然python有GIL，但不是所有操作都是线程安全的。</p><h2 id="指定配置参数"><a href="#指定配置参数" class="headerlink" title="指定配置参数"></a>指定配置参数</h2><p>通过 <code>-c</code> 来指定配置文件来运行，就不需要把参数写入命令。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>遇到的问题汇总</p><h3 id="启动django项目，找不到静态资源"><a href="#启动django项目，找不到静态资源" class="headerlink" title="启动django项目，找不到静态资源"></a>启动django项目，找不到静态资源</h3><p>gunicorn 来直接启动django项目，找不到静态资源，在url配置文件中加入</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>contrib<span class="token punctuation">.</span>staticfiles<span class="token punctuation">.</span>urls <span class="token keyword">import</span> staticfiles_urlpatternsurlpatterns <span class="token operator">+=</span> staticfiles_urlpatterns<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>问题解决来自 <a href="https://stackoverflow.com/questions/12800862/how-to-make-django-serve-static-files-with-gunicorn" target="_blank" rel="noopener">Stack Overflow</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Note </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-socket</title>
      <link href="/2018/10/22/Python-socket/base/"/>
      <url>/2018/10/22/Python-socket/base/</url>
      
        <content type="html"><![CDATA[<p>python网络编程笔记</p><a id="more"></a><h2 id="EAGAIN"><a href="#EAGAIN" class="headerlink" title="EAGAIN"></a>EAGAIN</h2><p>当客户通过Socket提供的send函数发送大的数据包时，就可能返回一个EAGAIN的错误。该错误产生的原因是由于 send 函数中的size变量大小超过了tcp_sendspace的值。tcp_sendspace定义了应用在调用send之前能够在kernel中缓存的数据量。当应用程序在socket中设置了O_NDELAY或者O_NONBLOCK属性后，如果发送缓存被占满，send就会返回EAGAIN的错误。 </p><h2 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h2><p>accept()是在一个套接口接受的一个连接。accept（）是c语言中网络编程的重要的函数，本函数从s的等待连接队列中抽取第一个连接，创建一个与s同类的新的套接口并返回句柄</p><h2 id="socket-listen-backlog"><a href="#socket-listen-backlog" class="headerlink" title="socket.listen(backlog)"></a>socket.listen(backlog)</h2><p>开始监听传入连接。backlog指定在拒绝连接之前，可以挂起的最大连接数量。</p><p>backlog等于5，表示内核已经接到了连接请求，但服务器还没有调用accept进行处理的连接个数最大为5<br>这个值不能无限大，因为要在内核中维护连接队列。</p><h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><p>close方法可以释放一个连接的资源，但是不是立即释放，如果想立即释放，那么在close之前使用shutdown方法shut_rd() ——-关闭接受消息通道shut_wr()——–关闭发送消息通道shut_rdwr()——-连个通道都关闭使用：在close()之前加上shutdown(num)即可  </p><p>[shut_rd(), shut_wr(), shut_rdwr()分别代表num 为0  1  2 ]（但是测试过close()关闭，发现如果关闭后，那么accept()得到的connection就马上不能用了[提示不能在非套接字上]）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-virtualenv 虚拟环境使用总结</title>
      <link href="/2018/10/22/Python/virtualenv/"/>
      <url>/2018/10/22/Python/virtualenv/</url>
      
        <content type="html"><![CDATA[<p>python 虚拟环境总结，总有一款适合你</p><p>使用虚拟环境是很有必要的，另外在windows和Linux上还是有区别的，windows上的支持要差些，我用过的虚拟环境太多了，和IDE的配合也很熟练了，总结下来虚拟环境还是只能用来创建运行环境，至于有些宣称的包管理工具，还是有很多欠缺的地方，pip才是最强的！ <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8">🔥</span></p><a id="more"></a><h2 id="Linux-python-virtualenv"><a href="#Linux-python-virtualenv" class="headerlink" title="Linux python virtualenv"></a>Linux python virtualenv</h2><p>大致和windows上是一样的，安装virtualenv</p><p>virtualenv -p 解释器目录 virtual目录</p><p>ls /usr/bin/python*  一般现在的linux都有python3，在这里指定解释器就可以了，没有就装一个</p><p>source py34env/bin/activate  激活</p><p>deactivate  退出    </p><p>windows上的虚拟环境还是不能直接在linux上用，虽然可以跑，但是创建这个虚拟环境的时候是指定了解释器的，直接跑解释器不对，包的内容和版本也不对，所以还是在linux上创建虚拟环境吧。</p><h2 id="virtualenvwrapper"><a href="#virtualenvwrapper" class="headerlink" title="virtualenvwrapper"></a>virtualenvwrapper</h2><p>virtualenvwrapper 是对virtualenv的扩展，利用它管理虚拟环境，最好的特征就是直接用命令就可以进入虚拟环境，不用像原来一样需要切换到目录下进入。<a href="https://www.jianshu.com/p/9f47a9801329" target="_blank" rel="noopener">简书</a></p><p>基本命令</p><p>workon   查看虚拟环境</p><p>workon  环境名称  进入对应虚拟环境</p><p>deactivate 退出环境</p><p>export WORKON_HOME=/  环境安装路径</p><p>export VIRTUALENVWRAPPER_PATHON= /  python解释器路径</p><p>source  /  virtualenvwrapper.sh  路径</p><p>我的流程： pip 安装  virtualenvwrapper  virtualenv  配置  ~/.bash_profile 为上面内容  把virtualenv添加符号链接</p><p>source ~/.bash_profile(激活环境变量，让workon命令可以被执行到，仅本次登陆有效)</p><h2 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h2><p>该软件有新的包管理工具 conda 这个不仅是python，是一个其它语言也可以用的包管理工具。用conda命令安装的python包，会去寻找相关依赖，提示你需要安装依赖，并一起安装。而pip虽然也会连同依赖一起装（听说没有conda好），但是有些包不会（猜测依赖的机制是包自身的，有些第三方包没有做这个处理，导致你安装了后，运行报错还要去装其它的，个人猜测）。</p><p><code>conda env export &gt; environment.yaml</code> 命令导出当前虚拟环境，可以用这个文件恢复虚拟环境。这个文件中有一个pip相关的信息，记录了该环境用pip安装的包。    </p><p>虽然用了conda，但是还是有一些包没法安装，还得用pip安装（猜测是一些个人写的包，不出名，没在conda上记录，或者就是单纯的没有记录）conda 和 pip ，conda可以管理pip和自己安装的包（用conda list查看），pip好像不行，只能管理自己的。</p><p>关于安装的时候是否选择添加到path，如果你电脑已经有了python，就不要选了。选了这个直接在命令行输入python，就会使用Anaconda的虚拟环境。</p><p>在新的虚拟环境中执行 <code>pip install -r requirements.txt</code> 导入pip安装的包</p><ul><li>activate 环境名称：进入对应环境    </li><li>conda env list：列出当前环境</li><li>mac下进入环境，前面加 source</li></ul><p>心得：Anaconda也用了一段时间，感觉并没有网上说的那么强大，对于一些科学计算，或者说是由其它语言编写，Python来调用的那种包，对，就是那种很高端的，是可以用conda安装管理的，但是像一些小包，尤其是纯Python写的，只有pip才能安装，这样你还是摆脱不了pip，重点软件非常大，太大了，比较适合做开发用，数据分析方向用。</p><h2 id="pipenv"><a href="#pipenv" class="headerlink" title="pipenv"></a>pipenv</h2><p>又是一个新的虚拟环境工具，相比virtualenv功能上更加强大，由于是较新的工具，设计上考虑就比较全面。通过pip install来安装，在项目对应目录执行 <code>pipenv install --dev</code> 使用系统Python版本来为此项目创建虚拟环境，生成Pipfile，Pipfile.lock文件。使用 <code>pipenv python 3.6</code> 的形式指定版本。通过帮助可以查看更多命令。</p><p>Pipfile &amp; Pipfile.lock：</p><p>Pipfile是用来代替原来的requirements.txt的，source部分用来设置仓库地址，packages部分用来指定项目依赖的包，dev-packages部分用来指定开发环境需要的包，这样分开便于管理。而Pipfile.lock中记录了当前环境中安装的依赖的版本号以及哈希，以保证每次装出来的依赖都是一致的。</p><p><code>pipenv install --dev</code> 用来安装当前项目中dev-packages中的包，没有环境的会创建虚拟环境。</p><p>在 Dockerfile 中安装依赖，加–system参数表示使用 pip 直接安装相应依赖，不创建虚拟环境。</p><p><code>RUN pipenv install --deploy --system</code></p><p><code>pipenv install --dev django</code>，<code>pipenv install django</code> 安装django包，第一种安装在dev-packages里面，这样在部署的时候通过 <code>pipenv install</code> 安装，只会安装packages里面的，把开发环境的包过滤了，这很有用，要全部安装，应该 <code>pipenv insyall --dev</code></p><p><code>pipenv --venv</code> 来查看环境所在目录</p><p>在项目目录中编写 <code>.env</code>，可以在进入虚拟环境后，把env文件中的环境变量加载，这个就很有用了</p><p>关于IDE支持：pycharm中，最新版本已经支持了，然而我用的mac版试了还是不行，而且我看源码的执行文件，明确说明不能直接执行此文件，这就很尴尬了，从使用virtualenv的经验来看，配置操作是没问题的，而且我查了官方文档，发现官方的情况和我的不符合。我推测是Windows环境的版本才支持，可能mac版还不行（但是软件中是有配置项，这就很尴尬了，暂时使用常规虚拟环境配置吧）。</p><p>无敌的环境还是有bug，在安装amqp的时候，生成Pipfile文件是叫pyamqp，而且我看有些书上也是叫pyamqp的，不过官方的包库中，找不到pyamqp，这导致了锁定版本的时候出了问题，估计是改了名字pipenv没有反应过来。</p><blockquote><p>关于Pipfile的问题，在我查阅了很多资料后，发现这就是个弟弟，并没有完全实现作者的构思的蓝图，因为你只要有一个包有问题，操作就不是全自动的，乖乖用pip来安装吧</p></blockquote><h2 id="autoenv"><a href="#autoenv" class="headerlink" title="autoenv"></a>autoenv</h2><p>通俗讲，就是用来在进入目录时，执行<code>.env</code>里面的命令，这样可以实现进入目录就自动进入虚拟环境。</p><ol><li>git clone git://github.com/kennethreitz/autoenv.git ~/.autoenv  克隆项目到用户目录</li><li>echo ‘source ~/.autoenv/activate.sh’ &gt;&gt; ~/.zshrc  写入用户环境变量</li><li>在项目下创建.env文件，并写入命令，如果是用pipenv，那么命令为pipenv shell</li></ol><h2 id="pip-导出当前项目依赖"><a href="#pip-导出当前项目依赖" class="headerlink" title="pip 导出当前项目依赖"></a>pip 导出当前项目依赖</h2><ol><li><p>导出<br>pip freeze &gt; requirements.txt</p></li><li><p>安装<br>pip install -r requirements.txt</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-multiprocessing 多进程</title>
      <link href="/2018/10/22/Python-multiprocessing/base/"/>
      <url>/2018/10/22/Python-multiprocessing/base/</url>
      
        <content type="html"><![CDATA[<p>python多进程学习笔记</p><a id="more"></a><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>Python标准库为我们提供了 <code>threading</code> 和 <code>multiprocessing</code> 模块编写相应的多线程/多进程代码。从Python3.2开始，标准库为我们提供了 <code>concurrent.futures</code> 模块，它提供了 <code>ThreadPoolExecutor</code> 和 <code>ProcessPoolExecutor</code> 两个类，实现了对 <code>threading</code> 和 <code>multiprocessing</code> 的更高级的抽象，对编写线程池/进程池提供了直接的支持。 </p><p>concurrent.futures基础模块是executor和future。future是concurrent.futures模块和asyncio模块的重要组件</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><p>pid=os.fork()</p><ol><li>只用在Unix系统中有效，Windows系统中无效</li><li>fork函数调用一次，返回两次：在父进程中返回值为子进程id，在子进程中返回值为0</li></ol><h3 id="和线程的区别"><a href="#和线程的区别" class="headerlink" title="和线程的区别"></a>和线程的区别</h3><p>进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</p><h3 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h3><p>python中，进程池内部会维护一个进程序列。当需要时，程序会去进程池中获取一个进程。如果进程池序列中没有可供使用的进程，那么程序就会等待，直到进程池中有可用进程为止。</p><p>进程池支持同步，异步，映射方式添加任务到进程池。</p><h3 id="预创建"><a href="#预创建" class="headerlink" title="预创建"></a>预创建</h3><p>预先创建一组子进程，当有新任务来时，系统通过 调配 该组进程中的某个 子进程 完成此任务。</p><p>为什么需要？</p><ol><li>进程创建，销毁需要消耗cpu时间</li><li>预先创建，以空间换时间，提升性能。时间是唯一稀缺资源，空间不足加内存，能够用钱解决的问题，都不是问题，钱都解决不了的问题才是问题</li><li>通过系统合理分配任务，提高性能。尽量实现真正的并行处理，提升系统处理效率</li></ol><h3 id="关于GIL"><a href="#关于GIL" class="headerlink" title="关于GIL"></a>关于GIL</h3><p>多进程，一个进程就有一个GIL</p><h3 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h3><p>我们知道现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操心系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核，保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。每个进程可以通过系统调用进入内核，因此，Linux内核由系统内的所有进程共享。于是，从具体进程的角度来看，<strong>每个进程可以拥有4G字节的虚拟空间</strong>。我们常说的陷入内核态，就是当前进程进入内核，去访问更高权限的东西。</p><p>需要注意的细节问题：</p><ul><li>内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。不管是内核空间还是用户空间，它们都处于虚拟空间中。 </li><li>Linux使用两级保护机制：0级供内核使用，3级供用户程序使用。</li><li>当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。</li><li>当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。</li></ul><h3 id="windows中创建进程"><a href="#windows中创建进程" class="headerlink" title="windows中创建进程"></a>windows中创建进程</h3><p>在windows中创建进程，相当于导入模块，所以要把进行放在 <code>if __name__ == '__main__':</code> 后面来执行，而且子进程会把代码再跑一次，如果你在代码块最外层有打印等执行语句，也会被执行（所以一般外层的代码都封装在函数里面，在linux上不会这样，由于外层代码不一定全是函数，只要是会被执行的都要执行，这和想像的情况相差太多，所以我建议多进程只在linux上使用，在windos上的多进程，只有演示学习的意义，过于复杂的程序受到太多的限制）</p><p>这是 Windows 上多进程的实现问题。在 Windows 上，子进程会自动 import 启动它的这个文件，而在 import 的时候是会执行这些语句的。如果你这么写的话就会无限递归创建子进程报错。但是在multiprocessing.Process的源码中是对子进程再次产生子进程是做了限制的，是不允许的，于是出现如上的错误提示。所以必须把创建子进程的部分用那个 if 判断保护起来，import 的时候 name 不是 main ，就不会递归运行了。</p><h3 id="操作系统的设计"><a href="#操作系统的设计" class="headerlink" title="操作系统的设计"></a>操作系统的设计</h3><ol><li>以多进程形式，允许多个任务同时运行；</li><li>以多线程形式，允许单个任务分成不同的部分运行；</li><li>提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。</li></ol><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>标准库提供了队列模块queue，在py2中，通过 <code>import Queue</code> 使用队列，在py3中通过 <code>from queue import Queue</code> 来使用队列。<br>在multiprocessing模块中，通过了Queue类来实现队列。queue.Queue是进程内非阻塞队列，multiprocess.Queue是跨进程通信队列。</p><ol><li><p>from queue import Queue<br>这个是普通的队列模式，类似于普通列表，先进先出模式，get方法会阻塞请求，直到有数据get出来为止</p></li><li><p>from multiprocessing.Queue import Queue（各子进程共有）<br>这个是多进程并发的Queue队列，用于解决多进程间的通信问题。普通Queue实现不了</p></li></ol><h3 id="multiprocessing-Queue"><a href="#multiprocessing-Queue" class="headerlink" title="multiprocessing.Queue"></a>multiprocessing.Queue</h3><p>queue = Queue(5) 初始化Queue()对象时（ 例如：q=Queue() ），若括号中没有指定最大可接收的消息数量，或数量为负值，那么就代表可接受的消息数量没有上限（直到内存的尽头）</p><p>Queue.qsize()：返回当前队列包含的消息数量，结果不可靠，理由同q.empty()和q.full()一样</p><p>Queue.empty()：如果队列为空，返回True，反之False。该结果不可靠，比如在返回True的过程中，如果队列中又加入了项目。</p><p>Queue.full()：如果队列满了，返回True，反之False。该结果不可靠，比如在返回True的过程中，如果队列中的项目被取走。</p><p>Queue.get([block[, timeout]])：获取队列中的一条消息，然后将其从列队中移除，block默认值为True；这里的block代表阻塞。</p><ul><li><p>如果block使用默认值，且没有设置timeout（单位秒），消息列队如果为空，此时程序将被阻塞（停在读取状态），直到从消息列队读到消息为止，如果设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出”Queue.Empty”异常</p></li><li><p>如果block值为False，消息列队如果为空，则会立刻抛出”Queue.Empty”异常</p></li></ul><p>Queue.get_nowait()：相当Queue.get(False)</p><p>Queue.put(item,[block[, timeout]])：将item消息写入队列，block默认值为True</p><ul><li><p>如果block使用默认值，且没有设置timeout（单位秒），消息列队如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息列队腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛出”Queue.Full”异常</p></li><li><p>如果block值为False，消息列队如果没有空间可写入，则会立刻抛出”Queue.Full”异常</p></li></ul><p>Queue.put_nowait(item)：相当Queue.put(item, False)</p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>进程间通信（IPC）方式二：管道</p><p>创建管道的类：<code>Pipe([duplex])</code>，在进程之间创建一条管道，并返回元组（conn1,conn2），其中conn1，conn2表示管道两端的连接对象，强调一点：<strong>必须在产生Process对象之前产生管道</strong></p><p>参数介绍：</p><p>duplex:默认值是True，管道是全双工的，如果将duplex改成False，conn1只能用于接收，conn2只能用于发送。</p><p>方法介绍：（详情参考文档：multiprocessing.connection.Connection类）</p><ul><li>conn1.recv()：接收conn2.send(obj)发送的对象。如果没有消息可接收，recv方法会一直阻塞。如果连接的另外一端已经关闭，那么recv方法会抛出EOFError</li><li>conn1.send(obj)：将一个对象发送到应该使用recv()读取的连接的另一端。obj必须是与序列化兼容的任意对象。非常大的pickle(大约32 MiB+，尽管这取决于操作系统)可能会引发ValueError异常</li><li>conn1.close()：关闭连接。如果conn1被垃圾回收，将自动调用此方法</li><li>conn1.fileno()：返回连接使用的整数文件描述符</li><li>conn1.poll([timeout])：返回是否有任何数据可供读取(如果连接上的数据可用，返回True)。timeout指定等待的最长时限。如果省略此参数，方法将立即返回结果。如果将timeout射成None，操作将无限期地等待数据到达</li><li>conn1.recv_bytes([maxlength])：接收c.send_bytes()方法发送的一条完整的字节消息。maxlength指定要接收的最大字节数。如果进入的消息，超过了这个最大值，将引发IOError异常，并且在连接上无法进行进一步读取。如果连接的另外一端已经关闭，再也不存在任何数据，将引发EOFError异常</li><li>conn.send_bytes(buffer [, offset [, size]])：通过连接发送字节数据缓冲区，buffer是支持缓冲区接口的任意对象，offset是缓冲区中的字节偏移量，而size是要发送字节数。结果数据以单条消息的形式发出，然后调用c.recv_bytes()函数进行接收    </li><li>conn1.recv_bytes_into(buffer [, offset])：接收一条完整的字节消息，并把它保存在buffer对象中，该对象支持可写入的缓冲区接口（即bytearray对象或类似的对象）。offset指定缓冲区中放置消息处的字节位移。返回值是收到的字节数。如果消息长度大于可用的缓冲区空间，将引发BufferTooShort异常。</li></ul><p>代码举例：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process<span class="token punctuation">,</span> Pipe<span class="token keyword">import</span> time<span class="token keyword">def</span> <span class="token function">consumer</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>    left_conn<span class="token punctuation">,</span> right_conn <span class="token operator">=</span> p    left_conn<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            data <span class="token operator">=</span> right_conn<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%s 消费产品:%s'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">except</span> EOFError<span class="token punctuation">:</span>            right_conn<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token keyword">def</span> <span class="token function">producer</span><span class="token punctuation">(</span>sequence<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>    left_conn<span class="token punctuation">,</span> right_conn <span class="token operator">=</span> p    right_conn<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> sequence<span class="token punctuation">:</span>        left_conn<span class="token punctuation">.</span>send<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%s 生产产品:%s'</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token string">'c2'</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        left_conn<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    left<span class="token punctuation">,</span> right <span class="token operator">=</span> Pipe<span class="token punctuation">(</span><span class="token punctuation">)</span>    c1 <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>consumer<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'c1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    c1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    seq <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    producer<span class="token punctuation">(</span>seq<span class="token punctuation">,</span> <span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">)</span>    right<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    left<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    c1<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'主进程'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：生产者和消费者都没有使用管道的某个端点，就应该将其关闭，如在生产者中关闭管道的右端，在消费者中关闭管道的左端。如果忘记执行这些步骤，程序可能再消费者中的recv()操作上挂起。管道是由操作系统进行引用计数的，必须在所有进程中关闭管道后才能生产EOFError异常。因此在生产者中关闭管道不会有任何效果，付费消费者中也关闭了相同的管道端点。</p><p>管道可以用于双向通信，利用通常在客户端/服务器中使用的请求／响应模型或远程过程调用，就可以使用管道编写与进程交互的程序（代码略）</p><h2 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Processp <span class="token operator">=</span> Process<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>创建实例的参数：</p><ul><li><p>group参数未使用，值始终为None</p></li><li><p>target表示调用对象，即子进程要执行的任务</p></li><li><p>args表示调用对象的位置参数元组，args=(1,2,’hexin’,)</p></li><li><p>kwargs表示调用对象的字典，kwargs={‘name’:’hexin’,’age’:18}</p></li><li><p>name为子进程的名称</p></li></ul><p>Process()由该类实例化得到的对象，表示一个子进程中的任务（尚未启动）</p><p>方法介绍：</p><ul><li>p.start()：启动进程，并调用该子进程中的p.run() </li><li>p.run()：进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法  </li><li>p.terminate()：强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁</li><li>p.is_alive()：如果p仍然运行，返回True</li><li>p.join([timeout])：主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程</li></ul><p>实例属性：</p><ul><li>p.daemon：默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置<br>— p.name：进程的名称</li><li>p.pid：进程的pid</li><li>p.exitcode：进程在运行时为None、如果为–N，表示被信号N结束(了解即可)</li><li>p.authkey：进程的身份验证键，默认是由os.urandom()随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可）</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-异步与协程</title>
      <link href="/2018/10/22/Python-asyncio/base/"/>
      <url>/2018/10/22/Python-asyncio/base/</url>
      
        <content type="html"><![CDATA[<p>异步编程是一个很难的点，不同于同步编程，编程模型将变得复杂。下文引用理查德·史蒂文斯（William Richard (Rich) Stevens，1951年2月5日－1999年9月1日）所编写的《UNIX网络编程》关于I/O Models 部分内容，并结合个人以及网络上的内容做的整理，关于Linux编程遇到的函数，由于没有太多的接触，先做个理解。</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h3><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p><h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p><p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p><ul><li>保存处理机上下文，包括程序计数器和其他寄存器。</li><li>更新PCB信息。</li><li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li><li>选择另一个进程执行，并更新其PCB。</li><li>更新内存管理的数据结构。</li><li>恢复处理机上下文。<br>注：总而言之就是很耗资源，具体的可以参考这篇文章：进程切换。</li></ul><h3 id="进程的阻塞"><a href="#进程的阻塞" class="headerlink" title="进程的阻塞"></a>进程的阻塞</h3><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。</p><h3 id="文件描述符fd"><a href="#文件描述符fd" class="headerlink" title="文件描述符fd"></a>文件描述符fd</h3><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p><p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p><h3 id="缓存-IO"><a href="#缓存-IO" class="headerlink" title="缓存 IO"></a>缓存 IO</h3><p>缓存 IO 又被称作标准 IO，大多数文件系统的默认 IO 操作都是缓存 IO。在 Linux 的缓存 IO 机制中，操作系统会将 IO 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p><p>缓存 IO 的缺点：</p><p>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p><h3 id="recvfrom-recv"><a href="#recvfrom-recv" class="headerlink" title="recvfrom() recv()"></a>recvfrom() recv()</h3><p>本函数用于从（已连接）套接口上接收数据，并捕获数据发送源的地址。recv也是差不多的功能，不过不能知道对端地址信息（由谁发来的）</p><h2 id="同步、异步"><a href="#同步、异步" class="headerlink" title="同步、异步"></a>同步、异步</h2><ul><li><p>概念：消息的通知机制</p></li><li><p>解释：涉及到IO通知机制；所谓同步，就是发起调用后，被调用者处理消息，必须等处理完才直接返回结果，没处理完之前是不返回的，调用者主动等待结果；所谓异步，就是发起调用后，被调用者直接返回，但是并没有返回结果，等处理完消息后，通过状态、通知或者回调函数来通知调用者，调用者被动接收结果。</p></li></ul><p>反应到编程模型中：同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，两个任务的状态可以保持一致。所谓异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。</p><h2 id="阻塞、非阻塞"><a href="#阻塞、非阻塞" class="headerlink" title="阻塞、非阻塞"></a>阻塞、非阻塞</h2><ul><li><p>概念：程序等待调用结果时的状态</p></li><li><p>解释：涉及到CPU线程调度；所谓阻塞，就是调用结果返回之前，该执行线程会被挂起，不释放CPU执行权，线程不能做其它事情，只能等待，只有等到调用结果返回了，才能接着往下执行；所谓非阻塞，就是在没有获取调用结果时，不是一直等待，线程可以往下执行，如果是同步的，通过轮询的方式检查有没有调用结果返回，如果是异步的，会通知回调。</p></li></ul><p>反应到编程模型中：阻塞调用是指调用结果返回之前，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务。函数只有在得到结果之后才会返回。</p><p>有人也许会把阻塞调用和同步调用等同起来，实际上它们是不同的。</p><p>对于同步调用来说，很多时候当前线程可能还是激活的，只是从逻辑上当前函数没有返回而已，此时，这个线程可能也会处理其他的消息。还有一点，在这里先扩展下：</p><ol><li>如果这个线程在等待当前函数返回时，仍在执行其他消息处理，那这种情况就叫做同步非阻塞；</li><li>如果这个线程在等待当前函数返回时，没有执行其他消息处理，而是处于挂起等待状态，那这种情况就叫做同步阻塞；</li></ol><p>所以同步的实现方式会有两种：<code>同步阻塞</code>、<code>同步非阻塞</code>；同理，异步也会有两种实现：<code>异步阻塞</code>、<code>异步非阻塞</code></p><p>对于阻塞调用来说，则当前线程就会被挂起等待当前函数返回</p><p>非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。虽然表面上看非阻塞的方式可以明显的提高CPU的利用率，但是也带了另外一种后果就是系统的线程切换增加。增加的CPU执行时间能不能补偿系统的切换成本需要好好评估。</p><p>场景举例：</p><p>去银行营业厅办业务员，不论是排队还是使用号码等待通知，如果在这个等待的过程中，等待者除了等待消息通知之外不能做其它的事情，那么该机制就是阻塞的，表现在程序中，也就是该程序一直阻塞在该函数调用处不能继续往下执行。</p><p>相反，有的人喜欢在银行办理这些业务的时候一边打打电话发发短信一边等待，这样的状态就是非阻塞的，因为他(等待者)没有阻塞在这个消息通知上，而是一边做自己的事情一边等待。</p><p>也就是说，你去排队，要时不时留意有没有排队排到你了，这是同步机制（如果是等叫号就是异步机制），然后你在排队的时候如果不做其它事情，就是阻塞（如果排队的时候玩手机，就是非阻塞），共可以组合出4种情况，也就是对应<code>同步阻塞</code>、<code>同步非阻塞</code>、<code>异步阻塞</code>、<code>异步非阻塞</code></p><p>但是需要注意了，同步非阻塞形式实际上是效率低下的，想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有。如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的；而异步非阻塞形式却没有这样的问题，因为打电话是你(等待者)的事情，而通知你则是柜台(消息触发机制)的事情，程序没有在两种不同的操作中来回切换。</p><p><strong>1. 同步阻塞形式</strong><br>效率是最低的，拿上面的例子来说，就是你专心排队，什么别的事都不做。</p><p><strong>2. 异步阻塞形式</strong><br>如果在银行等待办理业务的人采用的是异步的方式去等待消息被触发（通知），也就是领了一张小纸条，假如在这段时间里他不能离开银行做其它的事情，那么很显然，这个人被阻塞在了这个等待的操作上面。</p><p><code>异步操作是可以被阻塞住的</code>，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞。</p><p>比如select 函数，假如传入的最后一个timeout参数为NULL，那么如果所关注的事件没有一个被触发，程序就会一直阻塞在这个select 调用处。</p><p><strong>3. 同步非阻塞形式</strong><br>实际上是效率低下的，想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有，如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的。</p><p>很多人会写阻塞的read/write 操作，但是别忘了可以对fd设置O_NONBLOCK 标志位，这样就可以将同步操作变成非阻塞的了。</p><p><strong>4. 异步非阻塞形式</strong><br>效率更高，因为打电话是你(等待者)的事情，而通知你则是柜台(消息触发机制)的事情，程序没有在两种不同的操作中来回切换。<br>比如说，这个人突然发觉自己烟瘾犯了，需要出去抽根烟，于是他告诉大堂经理说，排到我这个号码的时候麻烦到外面通知我一下(注册一个回调函数)，那么他就没有被阻塞在这个等待的操作上面，自然这个就是异步+非阻塞的方式了。</p><p>如果使用异步非阻塞的情况，比如aio_*组的操作，当发起一个aio_read操作时，函数会马上返回不会被阻塞，当所关注的事件被触发时会调用之前注册的回调函数进行处理。</p><p>很多人会把同步和阻塞混淆，我想是因为很多时候同步操作会以阻塞的形式表现出来，比如很多人会写阻塞的read/write操作，但是别忘了可以对fd设置O_NONBLOCK标志位，这样就可以将同步操作变成非阻塞的了。但最根本是因为没有区分这两个概念，比如阻塞的read/write操作中，其实是把消息通知机制和等待消息通知的状态结合在了一起，在这里所关注的消息就是fd是否可读/写，而等待消息通知的状态则是对fd可读/写等待过程中程序（线程）的状态。当我们将这个fd设置为非阻塞的时候，read/write操作就不会在等待消息通知这里阻塞，如果fd不可读/写则操作立即返回。</p><p>同样的，很多人也会把异步和非阻塞混淆，因为异步操作一般都不会在真正的IO操作处被阻塞，比如如果用select函数，当select返回可读时再去read一般都不会被阻塞，而是在select函数调用处阻塞。</p><h2 id="五种IO模型"><a href="#五种IO模型" class="headerlink" title="五种IO模型"></a>五种IO模型</h2><ul><li>blocking IO （阻塞IO）</li><li>nonblocking IO （非阻塞IO）</li><li>IO multiplexing （IO多路复用）</li><li>signal driven IO （信号驱动IO）</li><li>asynchronous IO （异步IO）</li></ul><p>以上五种IO模型不仅在操作系统中存在，也可以引申到编程模型中，有些框架的原理就是其中的一种。</p><p>再说一下IO发生时涉及的对象和步骤。</p><p>网络IO的本质是socket的读取，socket在linux系统被抽象为流，IO可以理解为对流的操作。对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p><p>对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，它会经历两个阶段：</p><ol><li>等待数据准备 (Waiting for the data to be ready)</li><li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)<br>对于socket流而言，<br>第一步：通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。<br>第二步：把数据从内核缓冲区复制到应用进程缓冲区。<br>网络应用需要处理的无非就是两大类问题，网络IO，数据计算。相对于后者，网络IO的延迟，给应用带来的性能瓶颈大于后者。</li></ol><p>最后，记住这两点很重要，因为这些IO Model的区别就是在两个阶段上各有不同的情况。</p><h3 id="blocking-IO"><a href="#blocking-IO" class="headerlink" title="blocking IO"></a>blocking IO</h3><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：</p><p><img src="/images/Python-async/blocking-io.png" alt="image"></p><p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p><p>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</p><h3 id="non-blocking-IO"><a href="#non-blocking-IO" class="headerlink" title="non-blocking IO"></a>non-blocking IO</h3><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p><p><img src="/images/Python-async/noblocking-io.png" alt="image"></p><p>从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p><p>所以，用户进程其实是需要不断的主动询问kernel数据好了没有。</p><h3 id="IO-multiplexing"><a href="#IO-multiplexing" class="headerlink" title="IO multiplexing"></a>IO multiplexing</h3><p>IO multiplexing这个词可能有点陌生，但是如果我说select，epoll，大概就都能明白了。有些地方也称这种IO方式为event driven IO。我们都知道，select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图：</p><p><img src="/images/Python-async/io-multiplexing.png" alt="image"></p><p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p><p>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。（多说一句。所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。</p><p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p><p>IO多路复用是需要特别理解的，因为在很多框架中都有运用，再多啰嗦几句：</p><p>网络模型：</p><p>由于同步非阻塞方式需要不断主动轮询，轮询占据了很大一部分过程，轮询会消耗大量的CPU时间，而 “后台” 可能有多个任务在同时进行，人们就想到了循环查询多个任务的完成状态，只要有任何一个任务完成，就去处理它。如果轮询不是进程的用户态，而是有人帮忙就好了。那么这就是所谓的 “IO 多路复用”。UNIX/Linux 下的 select、poll、epoll 就是干这个的（epoll 比 poll、select 效率高，做的事情是一样的。</p><p>IO多路复用有两个特别的系统调用select、poll、epoll函数。select调用是内核级别的，select轮询相对非阻塞的轮询的区别在于—前者可以等待多个socket，能实现同时对多个IO端口进行监听，当其中任何一个socket的数据准好了，就能返回进行可读，然后进程再进行recvform系统调用，将数据由内核拷贝到用户进程，当然这个过程是<code>阻塞</code>的。select或poll调用之后，会<code>阻塞进程</code>，与blocking IO阻塞不同在于，此时的select不是等到socket数据全部到达再处理, 而是有了一部分数据就会调用用户进程来处理。如何知道有一部分数据到达了呢？监视的事情交给了内核，内核负责数据到达的处理。也可以理解为”非阻塞”吧。</p><p>I/O复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这两个函数可以同时阻塞多个I/O操作。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时（注意不是全部数据可读或可写），才真正调用I/O操作函数。</p><p>对于多路复用，也就是轮询多个socket。多路复用既然可以处理多个IO，也就带来了新的问题，多个IO之间的顺序变得不确定了，当然也可以针对不同的编号。</p><p>:sunny:<strong>总结</strong>：blocking IO只处理一个IO，IO multiplexing通过系统调用函数，处理多个IO。no-blocking IO 的轮询是用户态的（由当前进程来执行），多路复用的轮询由系统调用来执行，可以等待多个socket，能实现同时对多个IO端口进行监听。</p><p>I/O多路复用的主要应用场景如下：</p><ul><li>服务器需要同时处理多个处于监听状态或者多个连接状态的套接字。</li><li>服务器需要同时处理多种网络协议的套接字。</li></ul><p>了解了前面三种IO模式，在用户进程进行系统调用的时候，他们在等待数据到来的时候，处理的方式不一样，直接等待，轮询，select或poll轮询，两个阶段过程：</p><ul><li>第一个阶段有的阻塞，有的不阻塞，有的可以阻塞又可以不阻塞。</li><li>第二个阶段都是阻塞的。</li></ul><p>从整个IO过程来看，他们都是顺序执行的，因此可以归为同步模型(synchronous)。都是进程主动等待且向内核检查状态</p><p>高并发的程序一般使用同步非阻塞方式而非多线程 + 同步阻塞方式。要理解这一点，首先要扯到并发和并行的区别。比如去某部门办事需要依次去几个窗口，办事大厅里的人数就是并发数，而窗口个数就是并行度。也就是说并发数是指同时进行的任务数（如同时服务的 HTTP 请求），而并行数是可以同时工作的物理资源数量（如 CPU 核数）。通过合理调度任务的不同阶段，并发数可以远远大于并行度，这就是区区几个 CPU 可以支持上万个用户并发请求的奥秘。在这种高并发的情况下，为每个任务（用户请求）创建一个进程或线程的开销非常大。而同步非阻塞方式可以把多个 IO 请求丢到后台去，这就可以在一个进程里服务大量的并发 IO 请求。</p><p>注意：IO多路复用是同步阻塞模型还是异步阻塞模型：</p><p>同步是需要主动等待消息通知，而异步则是被动接收消息通知，通过回调、通知、状态等方式来被动获取消息。IO多路复用在阻塞到select阶段时，用户进程是主动等待并调用select函数获取数据就绪状态消息，并且其进程状态为阻塞。所以，把IO多路复用归为同步阻塞模式。</p><h3 id="signal-driven-IO"><a href="#signal-driven-IO" class="headerlink" title="signal-driven IO"></a>signal-driven IO</h3><p>信号驱动式I/O：首先我们允许Socket进行信号驱动IO,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。</p><p><img src="/images/Python-async/signal-io.png" alt="image"></p><h3 id="Asynchronous-I-O"><a href="#Asynchronous-I-O" class="headerlink" title="Asynchronous I/O"></a>Asynchronous I/O</h3><p>linux下的asynchronous IO其实用得很少。先看一下它的流程：</p><p><img src="/images/Python-async/asynchronous-io.png" alt="image"></p><p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p><p>blocking和non-blocking的区别在哪，synchronous IO和asynchronous IO的区别在哪：</p><p>先回答最简单的这个：blocking vs non-blocking。前面的介绍中其实已经很明确的说明了这两者的区别。调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p><p>在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。Stevens给出的定义（其实是POSIX的定义）是这样子的：</p><pre><code>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;An asynchronous I/O operation does not cause the requesting process to be blocked; </code></pre><p>两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。有人可能会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p><p>各个IO Model的比较如图所示：</p><p><img src="/images/Python-async/io-models.png" alt="image"></p><p>经过上面的介绍，会发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p><p>最后，再举几个不是很恰当的例子来说明这四个IO Model:</p><p>有A，B，C，D四个人在钓鱼：</p><ul><li>A用的是最老式的鱼竿，所以呢，得一直守着，等到鱼上钩了再拉杆；</li><li>B的鱼竿有个功能，能够显示是否有鱼上钩，所以呢，B就和旁边的MM聊天，隔会再看看有没有鱼上钩，有的话就迅速拉杆；</li><li>C用的鱼竿和B差不多，但他想了一个好办法，就是同时放好几根鱼竿，然后守在旁边，一旦有显示说鱼上钩了，它就将对应的鱼竿拉起来；</li><li>D是个有钱人，干脆雇了一个人帮他钓鱼，一旦那个人把鱼钓上来了，就给D发个短信。 </li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>同步，异步，阻塞，非阻塞</p><p>同步和异步说的是消息通知的机制</p><p>同步调用，调用者要一直等待消息返回，编程模型就是由A向B发起了请求，B要把本次请求的任务做完成，然后返回数据给A（通知A任务完成了）。</p><p>这里对于任务的调用又会有<code>阻塞</code>和<code>非阻塞</code>，阻塞的编程模型就是在B中，数据还没准备好，但是它不会返回给你，A没有得到返回，要一直等着。如果是非阻塞，编程模型就是在B中，可能会去查数据，没查到（说明内核没有准备好数据），就返回，A收到返回了（假设是一个错误信息，即数据没准备好），A的请求不被B影响，它不需要等待，但是你是同步的，如果A没得到数据，虽然没阻塞A调用，A可以去做其它事情，但是A仍然要再次去请求B，整个调用是同步的，A不去请求B，没人会通知A，所以同步非阻塞是效率低下的编程模型。</p><p>异步就是B不需要立即通知A，A可以马上得到返回，B通过回调机制来通知A，这个回调机制就是通知A的手段，可以比喻成发短信，打电话，编程模型就是要准备回调函数，这个回调函数内去通知A。</p><ul><li>异步阻塞，A调用B，A不会得到返回，等着回调函数来通知A，A的调用被阻塞了</li><li>异步操作是可以被阻塞住的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞</li><li>异步非阻塞，A调用B，A不会被阻塞，等待回调函数来通知A</li></ul><p>同步和阻塞，异步和非阻塞，很容易混淆概念，把同步当成是阻塞的，同样的，很多人也会把异步和非阻塞混淆，因为异步操作一般都不会在真正的IO操作处被阻塞，比如如果用select函数，当select返回可读时再去read一般都不会被阻塞，而是在select函数调用处阻塞。</p><p>一般情况，我们不会自己处理这么复杂的编程模型，都是使用现成的模型，linux中的5种IO模型，再比如webserver中，利用gunicorn+django的方式部署项目，理解此时的IO模型是什么样的，gunicorn使用不同的worker模式，IO模型是什么样的。更加细的理解要结合内核态和用户态，操作系统的机制来。理解好概念，当真的需要编写相关代码的时候，理解好整个编程模型，知道什么操作被阻塞，是同步机制还是异步机制。</p><p>理解“消息通知机制”和“等待消息通知时的状态（程序等待调用结果时的状态）”这两个概念，这是理解四个概念的关键所在。</p><p>关于异步阻塞：</p><p>业务逻辑需要的是做完一件事后做另一件事，例如数据库连接初始化后才能开始接受用户的 HTTP 请求。这样的业务逻辑就需要调用者是以阻塞方式来工作。另外一种使用阻塞方式的理由是降低响应延迟。如果采用非阻塞方式，一个任务 A 被提交到后台，就开始做另一件事 B，但 B 还没做完，A 就完成了，这时要想让 A 的完成事件被尽快处理（比如 A 是个紧急事务），要么丢弃做到一半的 B，要么保存 B 的中间状态并切换回 A，任务的切换是需要时间的（不管是从磁盘载入到内存，还是从内存载入到高速缓存），这势必降低 A 的响应速度。因此，对实时系统或者延迟敏感的事务，有时采用阻塞方式比非阻塞方式更好。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        v <span class="token operator">=</span> <span class="token keyword">yield</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'consume: {v}'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">producer</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        c<span class="token punctuation">.</span>send<span class="token punctuation">(</span>i<span class="token punctuation">)</span>c <span class="token operator">=</span> consumer<span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>send<span class="token punctuation">(</span>None<span class="token punctuation">)</span>producer<span class="token punctuation">(</span>c<span class="token punctuation">)</span>c<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    r <span class="token operator">=</span> <span class="token string">''</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        v <span class="token operator">=</span> <span class="token keyword">yield</span> r        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'consume: {v}'</span><span class="token punctuation">)</span>        r <span class="token operator">=</span> f<span class="token string">'Result : {v * 2}'</span><span class="token keyword">def</span> <span class="token function">producer</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'Producing... {i}'</span><span class="token punctuation">)</span>        r <span class="token operator">=</span> c<span class="token punctuation">.</span>send<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'Consumer return: {r}'</span><span class="token punctuation">)</span>c <span class="token operator">=</span> consumer<span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>send<span class="token punctuation">(</span>None<span class="token punctuation">)</span>producer<span class="token punctuation">(</span>c<span class="token punctuation">)</span>c<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">framework</span><span class="token punctuation">(</span>logic<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        it <span class="token operator">=</span> logic<span class="token punctuation">(</span><span class="token punctuation">)</span>        s <span class="token operator">=</span> next<span class="token punctuation">(</span>it<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'[FX] logic: {s}'</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'[FX] do something...'</span><span class="token punctuation">)</span>        it<span class="token punctuation">.</span>send<span class="token punctuation">(</span>f<span class="token string">'async: {s}'</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> StopIteration<span class="token punctuation">:</span>        <span class="token keyword">pass</span><span class="token keyword">def</span> <span class="token function">logic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    s <span class="token operator">=</span> <span class="token string">'Logic'</span>    r <span class="token operator">=</span> <span class="token keyword">yield</span> s    <span class="token keyword">print</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>framework<span class="token punctuation">(</span>logic<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-threading 多线程</title>
      <link href="/2018/10/22/Python-threading/Python-threading/"/>
      <url>/2018/10/22/Python-threading/Python-threading/</url>
      
        <content type="html"><![CDATA[<p>python多线程相关笔记</p><a id="more"></a><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>使用标准库threading来创建线程。threading 库可以在单独的线程中执行任何的在 Python 中可以调用的对象。你可 以创建一个 Thread 对象并将你要执行的对象以 target 参数的形式提供给该对象。虽然python GIL 的存在，导致多线程同一时刻只能有一个线程获得解释器（在py2中，大概执行1000行字节码后，会释放解释器，当线程被阻塞的时候，会让出解释器，释放GIL）</p><p>可以通过time.sleep(3)来阻塞线程</p><p>一个简单例子：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token comment" spellcheck="true"># 计算密集型任务</span><span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    a <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1111</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span>t <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>func<span class="token punctuation">)</span>t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'sleep'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 此时创建列表a占用了解释器，先hello world 再 sleep</span><span class="token comment" spellcheck="true"># 计算密集型任务</span><span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    a <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">11111111111</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span>t <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>func<span class="token punctuation">)</span>t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'sleep'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 这种情况，先打印sleep再是hello world（执行一定的字节码后，释放了解释器）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="threading的属性和方法"><a href="#threading的属性和方法" class="headerlink" title="threading的属性和方法"></a>threading的属性和方法</h2><ul><li>current_thread()  # 返回当前线程对象.</li><li>main_thread()  # 返回主线程对象.</li><li>active_count()  # 当前处于alive状态的线程个数.</li><li>enumerate()  # 返回所有活着的线程的列表，不包括已经终止的线程和未开始的线程.</li><li>get_ident()  # 返回当前线程ID，非0整数.</li></ul><p>看一个例子：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># a = [i for i in range(1111)]</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'current thread = {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'main thread = {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>threading<span class="token punctuation">.</span>main_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'"主线程对象"'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'active count = {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>threading<span class="token punctuation">.</span>active_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'"alive"'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span>t <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>func<span class="token punctuation">)</span>t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'sleep'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'current thread = {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'main thread = {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>threading<span class="token punctuation">.</span>main_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'"主线程对象"'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'active count = {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>threading<span class="token punctuation">.</span>active_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'"alive"'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行以上代码，每次的执行结果是不一样的，而且是print是线程不安全的。要解释这个问题，需要再了解一些线程相关的概念。</p><h2 id="thread实例的属性和方法"><a href="#thread实例的属性和方法" class="headerlink" title="thread实例的属性和方法"></a>thread实例的属性和方法</h2><ul><li>name: 只是一个名称标识，可以重名，getName()、setName()来获取、设置这个名词。</li><li>ident: 线程ID，它是非0整数。线程启动后才会有ID，否则为None。线程退出，此ID依旧可以访问。此ID可以重复使用。</li><li>is_alive(): 返回线程是否活着。</li></ul><p>通过threading.Thread()  我们创建了线程类的实例，像面向对象一样，可以有对应的方法，属性</p><p><code>t = threading.Thread(target=func, name='my_thread', args=('1', ), kwargs={'a': 2})</code></p><ul><li>start(): 启动线程。每一个线程必须且只能执行该方法一次。</li></ul><p>开始线程活动。</p><p>对每一个线程对象来说它只能被调用一次，它安排对象在一个另外的单独线程中调用run()方法（而非当前所处线程）。<br>当该方法在同一个线程对象中被调用超过一次时，会引发RuntimeError(运行时错误)。</p><ul><li>run(): 运行线程函数。</li></ul><p>代表了线程活动的方法。</p><p>你可以在子类中重写此方法。标准run()方法调用了传递给对象的构造函数的可调对象作为目标参数，如果有这样的参数的话，顺序和关键字参数分别从args和kargs取得。</p><p>start() 后，还会执行run。如果你重写线程类，在调用start和run的时候，加入打印代码，start执行的线程，会派生出子线程，在子线程中去执行run，配合threading.current_thread()可以看到整个过程。</p><p>而run只在当前线程中执行。</p><h2 id="多线程情况"><a href="#多线程情况" class="headerlink" title="多线程情况"></a>多线程情况</h2><p>继承Thread类，使用Extender的形式扩展start和run方法，观察执行情况。我们开启两个线程，然后start他们，利用threading.current_thread()获取当前线程，main_thread()返回主线程对象</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token keyword">import</span> time<span class="token keyword">import</span> logginglogging<span class="token punctuation">.</span>basicConfig<span class="token punctuation">(</span>level<span class="token operator">=</span>logging<span class="token punctuation">.</span>NOTSET<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> count <span class="token operator">></span> <span class="token number">5</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true"># print("worker running")</span>        logging<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">"{} {} 主线程：{}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ident<span class="token punctuation">,</span>                                        threading<span class="token punctuation">.</span>main_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># print(threading.current_thread().name, threading.current_thread().ident)</span><span class="token keyword">class</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">start</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'start~~~~~~~~~~~~~'</span><span class="token punctuation">)</span>        super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'run~~~~~~~~~~~~~~~'</span><span class="token punctuation">)</span>        super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>main_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>t <span class="token operator">=</span> MyThread<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'worker'</span><span class="token punctuation">,</span> target<span class="token operator">=</span>worker<span class="token punctuation">)</span>t2 <span class="token operator">=</span> MyThread<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'not worker'</span><span class="token punctuation">,</span> target<span class="token operator">=</span>worker<span class="token punctuation">)</span>t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>t2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>t<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>t2<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 输出结果</span><span class="token comment" spellcheck="true"># &lt;_MainThread(MainThread, started 4587271616)></span><span class="token comment" spellcheck="true"># start~~~~~~~~~~~~~</span><span class="token comment" spellcheck="true"># run~~~~~~~~~~~~~~~</span><span class="token comment" spellcheck="true"># start~~~~~~~~~~~~~</span><span class="token comment" spellcheck="true"># run~~~~~~~~~~~~~~~</span><span class="token comment" spellcheck="true"># INFO:root:worker 123145369858048 主线程：&lt;_MainThread(MainThread, started 4587271616)></span><span class="token comment" spellcheck="true"># INFO:root:not worker 123145375113216 主线程：&lt;_MainThread(MainThread, started 4587271616)></span><span class="token comment" spellcheck="true"># INFO:root:worker 123145369858048 主线程：&lt;_MainThread(MainThread, started 4587271616)></span><span class="token comment" spellcheck="true"># INFO:root:not worker 123145375113216 主线程：&lt;_MainThread(MainThread, started 4587271616)></span><span class="token comment" spellcheck="true"># INFO:root:worker 123145369858048 主线程：&lt;_MainThread(MainThread, started 4587271616)></span><span class="token comment" spellcheck="true"># INFO:root:not worker 123145375113216 主线程：&lt;_MainThread(MainThread, started 4587271616)></span><span class="token comment" spellcheck="true"># INFO:root:worker 123145369858048 主线程：&lt;_MainThread(MainThread, started 4587271616)></span><span class="token comment" spellcheck="true"># INFO:root:not worker 123145375113216 主线程：&lt;_MainThread(MainThread, started 4587271616)></span><span class="token comment" spellcheck="true"># INFO:root:worker 123145369858048 主线程：&lt;_MainThread(MainThread, started 4587271616)></span><span class="token comment" spellcheck="true"># INFO:root:not worker 123145375113216 主线程：&lt;_MainThread(MainThread, started 4587271616)></span><span class="token comment" spellcheck="true"># INFO:root:worker 123145369858048 主线程：&lt;_MainThread(MainThread, started 4587271616)></span><span class="token comment" spellcheck="true"># INFO:root:not worker 123145375113216 主线程：&lt;_MainThread(MainThread, started 4587271616)></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到两个线程交替运行，如果使用print，你跑多次这个结果是不一样的。</p><p>打印前可以加入threading.main_thread()，这样可以看到俩个线程都是主线程派生出来的子线程。</p><p>换成run()方法后，结果如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token keyword">import</span> time<span class="token keyword">import</span> logginglogging<span class="token punctuation">.</span>basicConfig<span class="token punctuation">(</span>level<span class="token operator">=</span>logging<span class="token punctuation">.</span>NOTSET<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> count <span class="token operator">></span> <span class="token number">5</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true"># print("worker running")</span>        <span class="token comment" spellcheck="true"># print(threading.main_thread().name, threading.current_thread().name, threading.current_thread().ident)</span>        logging<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">"{} {} 主线程：{}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ident<span class="token punctuation">,</span>                                        threading<span class="token punctuation">.</span>main_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">start</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'start~~~~~~~~~~~~~'</span><span class="token punctuation">)</span>        super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'run~~~~~~~~~~~~~~~'</span><span class="token punctuation">)</span>        super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span>t <span class="token operator">=</span> MyThread<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'worker'</span><span class="token punctuation">,</span> target<span class="token operator">=</span>worker<span class="token punctuation">)</span>t2 <span class="token operator">=</span> MyThread<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'not worker'</span><span class="token punctuation">,</span> target<span class="token operator">=</span>worker<span class="token punctuation">)</span>t<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span>t2<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># run~~~~~~~~~~~~~~~</span><span class="token comment" spellcheck="true"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)></span><span class="token comment" spellcheck="true"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)></span><span class="token comment" spellcheck="true"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)></span><span class="token comment" spellcheck="true"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)></span><span class="token comment" spellcheck="true"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)></span><span class="token comment" spellcheck="true"># run~~~~~~~~~~~~~~~</span><span class="token comment" spellcheck="true"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)></span><span class="token comment" spellcheck="true"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)></span><span class="token comment" spellcheck="true"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)></span><span class="token comment" spellcheck="true"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)></span><span class="token comment" spellcheck="true"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)></span><span class="token comment" spellcheck="true"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)></span><span class="token comment" spellcheck="true"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，run就是去调用函数，谁来调用呢？当然是<code>当前线程</code>了，可以看到 <code>print(threading.main_thread().name, threading.current_thread().name, threading.current_thread().ident)</code> 打印出来的都是主线程。</p><p><strong>没有开新的线程，这就是普通函数调用，所以执行完t1.run()，然后执行t2.run()，这里就不是多线程。</strong></p><p>当使用start方法启动线程后，进程内有多个活动的线程并行的工作，就是多线程。</p><p>一个进程中至少有一个线程，并作为程序的入口，这个线程就是主线程。一个进程至少有一个<code>主线程</code>。其他线程称为<code>工作线程</code>。</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>使用print来运行上面的两个例子，本应该是一行行打印，但很多字符串打印在了一起，这说明print函数被打断了，被线程切换打断了。</p><p>print函数分两步，第一步打印字符串，第二部换行，就在这之间，发生了线程的切换。</p><p>说明print函数不是线程安全函数。</p><p>print函数还没执行换行符，就被其它线程打断了，在python3中：</p><p><code>def print(self, *args, sep=' ', end='\n', file=None)</code></p><p>print变成了函数，结尾默认加‘\n’，你可以去改变这个参数，比如改成’’, 打印结果就是一行的一串字符</p><p>线程安全: 线程执行一段代码，不会产生不确定的结果，那这段代码就是线程安全的。在开发中，我们会使用标准库的logging来，打印信息，这个是线程安全的。</p><h2 id="线程daemon"><a href="#线程daemon" class="headerlink" title="线程daemon"></a>线程daemon</h2><p>线程可以被标识为”Daemon线程”，<strong>Daemon线程表明整个Python主程序只有在Daemon子线程运行时可以退出</strong>。该属性值继承自父线程，可通过setDaemon()函数设定该值。</p><p>daemon线程和non-daemon线程(注：这里的daemon不是Linux中的守护进程)：</p><ul><li>进程靠线程执行代码，至少有一个主线程，其他线程是工作线程。</li><li>主线程是第一个启动的线程。</li><li>父线程：如果线程A中启动了一个线程B，A就是B的父线程。</li><li>子线程：B就是A的子线程。</li><li>python中构造线程的时候可以设置daemon属性，这个属性必须在start方法之前设置好。</li></ul><p>daemon属性：表示线程是否是daemon线程，这个值必须在start()之前设置，否则引发RuntimeError异常。</p><blockquote><p>daemon=False 运行发现子线程依然执行，主线程已经执行完，但是主线程会一直等着子线程执行完<br>daemon=True 运行发现主线程执行完程序立即结束了</p></blockquote><p>实例方法：</p><p>isDaemon()：是否是daemon线程。<br>setDaemon()：设置为daemon线程，必须在start方法之前设置。</p><p>总结:</p><p>线程具有一个daemon属性，可以显式设置为True或False，也可以不设置，不设置则取默认值None。</p><p>如果不设置daemon，就取当前线程的daemon来设置它。子线程继承父线程的daemon值，作用和设置None一样。</p><p>主线程是non-daemon线程，即daemon=False。</p><p>从主线程创建的所有线程不设置daemon属性，则默认都是daemon=False，也就是non-daemon线程。</p><p>python程序在没有活着的non-daemon线程运行时退出，也就是剩下的只能是daemon线程，主线程才能退出，否则主线程就只能等待。</p><ul><li>如果有non-daemon线程的时候，主线程退出时，也不会杀掉所有daemon线程，直到所有non-daemon线程全部结束</li><li>如果还有daemon线程，主线程需要退出，会结束所有 daemon线程，退出。</li></ul><p>线程创建的时候<code>t = threading.Thread(target=func, daemon=False)</code>这个daemon不设置就是False</p><p>子线程也是non-daemon，只要有线程是non-daemon，python程序就不会退出，如果还未执行完成的线程是daemon的，主线程执行完，就会退出，并杀掉所有daemon线程。</p><p>Daemon线程会被粗鲁的直接结束，它所使用的资源（已打开文件、数据库事务等）无法被合理的释放。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">import</span> threading<span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>t1 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>foo<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span> daemon<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>t1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># t1.join()  # 设置join.</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Main Thread Exiting'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，子线程开始执行，然后主线程执行了打印，由于主线程执行完成了，而剩下的线程是daemon的，所以程序退出。把daemon = False或者不设置，结果就是打印了Main Thread Exiting后，子线程继续，打印1，2，3…..</p><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><ul><li>使用了join方法后，daemon线程执行完了，主线程才退出。</li><li>join(timeout=None)，是线程的标准方法之一。</li><li>一个线程中调用另一个线程的join方法，调用者将被阻塞，直到被调用线程终止。</li><li>一个线程可以被join多次。</li><li>timeout参数指定调用者等待多久，没有设置超时，就一直等待被调用线程结束。</li><li>调用谁的join方法，就是join谁，就要等谁。</li></ul><p>把上面例子的 <code>t1.join()  # 设置join.</code> 放开，<code>print('Main Thread Exiting')</code> 要等子线程执行完成才执行。</p><p>join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行，那么在调用这个线程时可以使用被调用线程的join方法。</p><p>总结：</p><p>主要理解daemon join，不做处理的多线程，线程是并发的，daemon控制了主线程是否等待子线程执行完成，join控制了线程是否要组赛，主线程被阻塞了，就不会因为还剩daemon线程退出，因为主线程被阻塞了，他还没有执行完，所以这两个概念是互不冲突的（你可以设置超时时间，超时到了，主线程不再阻塞，就会杀掉daemon线程）。</p><p>在主线程中创建了3个线程，3个线程执行了join，就是说主线程要等着3个线程完成才执行，3个线程中的A线程创建了线程a，那么a就是A的子线程，a中join A就要等a执行完成，主线程也被阻塞，在等A，即主线程等A，A等a。</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>python的大部分操作是原子性的，比如你对列表执行反向，排序，它不会被其它线程打断。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> disdis<span class="token punctuation">.</span>dis<span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>利用标准库的dis可以看python代码的字节码实现，一般操作由一条指令来完成，那么就是原子性，如果一个操作（对应python的一行或几行代码）需要多个指令（入栈，出栈，调用寄存器等），可能在入栈等某个指令的时候被其它线程打断，出现和预期不一样的效果。</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>标准库queue提供了队列支持，在py2中，通过import Queue来使用队列，在py3中，通过from queue import Queue，py3中，除了Queue类，还增加了queue.LifoQueue（LIFO后进先出队列），queue.PriorityQueue（优先级队列）</p><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p><code>q = queue.Queue(3) # 创建队列，队列最大元素3个，默认为0，此时队列长度没有限制</code></p><ul><li>queue.qsize() 返回队列的大小</li><li>queue.empty() 如果队列为空，返回True，反之False</li><li>queue.full() 如果队列满了，返回True，反之False</li><li>queue.full 与 maxsize 大小对应</li><li>queue.get([block[, timeout]])获取队列，timeout等待时间</li><li>queue.get_nowait() 相当queue.get(False)</li><li>queue.put(item) 写入队列，timeout等待时间</li><li>queue.put_nowait(item) 相当queue.put(item, False)</li><li>queue.task_done() 在完成一项工作之后，queue.task_done()函数向任务已经完成的队列发送一个信号</li><li>queue.join() 实际上意味着等到队列为空，再执行别的操作</li></ul><h2 id="本地线程"><a href="#本地线程" class="headerlink" title="本地线程"></a>本地线程</h2><p>不同的线程对内容的修改只在线程内发挥作用，线程之间互相不影响，在flask框架中有使用到</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> threadingmy_data <span class="token operator">=</span> threading<span class="token punctuation">.</span>local<span class="token punctuation">(</span><span class="token punctuation">)</span>my_data<span class="token punctuation">.</span>number <span class="token operator">=</span> <span class="token number">42</span><span class="token keyword">print</span><span class="token punctuation">(</span>my_data<span class="token punctuation">.</span>number<span class="token punctuation">)</span>log <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    my_data<span class="token punctuation">.</span>number <span class="token operator">=</span> <span class="token number">11</span>    log<span class="token punctuation">.</span>append<span class="token punctuation">(</span>my_data<span class="token punctuation">.</span>number<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>id<span class="token punctuation">(</span>my_data<span class="token punctuation">.</span>number<span class="token punctuation">)</span><span class="token punctuation">)</span>thread <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>f<span class="token punctuation">)</span>thread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>thread<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>log<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>my_data<span class="token punctuation">.</span>number<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>id<span class="token punctuation">(</span>my_data<span class="token punctuation">.</span>number<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 42</span><span class="token comment" spellcheck="true"># 4559721904</span><span class="token comment" spellcheck="true"># [11]</span><span class="token comment" spellcheck="true"># 42</span><span class="token comment" spellcheck="true"># 4559722896</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="同步原语"><a href="#同步原语" class="headerlink" title="同步原语"></a>同步原语</h2><p>控制多线程同时访问资源，包括互斥锁，信号量，条件变量，事件</p><p>以房间为例子举例：</p><p>有些房间最多只能容纳一个人。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。</p><p>一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫互斥锁（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。</p><p>还有些房间，可以同时容纳n个人。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。</p><p>这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做信号量（Semaphore），用来保证多个线程不会互相冲突。</p><p>不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>使用信号量做为同步机制，使用with进入上下文管理器，省略了acquire和release，信号量通过计数器来管理，这里计数器初始是3，获取acquire操作，计数器减1，release操作，计数器加1，当计数器为0的时候，阻塞其它线程的操作。</p><p>通过执行结果可以看到，创建了5个线程，前3个线程 0，1，2 执行了 acquire操作，使得信号量为0，阻塞了其它线程，通过sleep模拟<br>线程阻塞，等到线程 2 release的时候，线程 3 才执行 acquire 操作，4 线程也是等待 3 线程release后才执行 acquire。</p><p>通过使用信号量，实现了只能有3个线程并发，而锁其实就是信号量为1的情况。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">from</span> random <span class="token keyword">import</span> random<span class="token keyword">from</span> threading <span class="token keyword">import</span> Thread<span class="token punctuation">,</span> Semaphoresema <span class="token operator">=</span> Semaphore<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 创建信号量</span><span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span>tid<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">with</span> sema<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'{tid} acquire sema'</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'{tid} release sema'</span><span class="token punctuation">)</span>threads <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    t <span class="token operator">=</span> Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>foo<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    threads<span class="token punctuation">.</span>append<span class="token punctuation">(</span>t<span class="token punctuation">)</span>    t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> threads<span class="token punctuation">:</span>    i<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 0 acquire sema</span><span class="token comment" spellcheck="true"># 1 acquire sema</span><span class="token comment" spellcheck="true"># 2 acquire sema</span><span class="token comment" spellcheck="true"># 2 release sema</span><span class="token comment" spellcheck="true"># 3 acquire sema</span><span class="token comment" spellcheck="true"># 3 release sema</span><span class="token comment" spellcheck="true"># 4 acquire sema</span><span class="token comment" spellcheck="true"># 1 release sema</span><span class="token comment" spellcheck="true"># 0 release sema</span><span class="token comment" spellcheck="true"># 4 release sema</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以线程的执行结果是有很多因素影响的，在你用默认操作的时候，如果进行了IO密集任务或是CPU密集任务，IO密集在等待时会释放GIL，CPU密集也会执行一定数量的字节码后释放一下GIL，由于线程并发的切换是操作系统控制的，所以有这样的编程需求的时候，务必配合join，daemon等控制程序，不然什么时候切换，这是说不准的。</p><p>线程何时切换？一个线程无论何时开始睡眠或等待网络 I/O，其他线程总有机会获取 GIL 执行 Python 代码。这是协同式多任务处理。CPython 也还有抢占式多任务处理。如果一个线程不间断地在 Python 2 中运行 1000 字节码指令，或者不间断地在 Python 3 运行15 毫秒，那么它便会放弃 GIL，而其他线程可以运行。把这想象成旧日有多个线程但只有一个 CPU 时的时间片。</p><ol><li><p>协同式多任务处理<br>当一项任务比如网络 I/O启动，而在长的或不确定的时间，没有运行任何 Python 代码的需要，一个线程便会让出GIL，从而其他线程可以获取 GIL 而运行 Python。这种礼貌行为称为协同式多任务处理，它允许并发；多个线程同时等待不同事件。</p></li><li><p>抢占式多任务处理<br>Python线程可以主动释放 GIL，也可以先发制人抓取 GIL 。</p></li></ol><p>让我们回顾下 Python 是如何运行的。你的程序分两个阶段运行。首先，Python文本被编译成一个名为字节码的简单二进制格式。第二，Python解释器的主回路，一个名叫 pyeval_evalframeex() 的函数，流畅地读取字节码，逐个执行其中的指令。当解释器通过字节码时，它会定期放弃GIL，而不需要经过正在执行代码的线程允许，这样其他线程便能运行。默认情况下，检测间隔是1000 字节码。所有线程都运行相同的代码，并以相同的方式定期从他们的锁中抽出。在 Python 3 GIL 的实施更加复杂，检测间隔不是一个固定数目的字节码，而是15 毫秒。然而，对于你的代码，这些差异并不显著。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Core-python-programming 读书笔记</title>
      <link href="/2018/10/22/ReadBook/Core-python-programming/"/>
      <url>/2018/10/22/ReadBook/Core-python-programming/</url>
      
        <content type="html"><![CDATA[<p>Python 核心编程 读书笔记，节选部分内容</p><a id="more"></a><h2 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h2><p>CGI：</p><p>对于静态资源（文件图片等，或者静态的HTML页面），利用web服务器就可以处理了（比如nginx），而动态资源（计算出来的数据）就要用CGI应用程序来处理。python可以用命令就在本地创建一个服务器，接着导入CGI模块，编写如何渲染页面的应用程序，就实现了CGI了。但是这种方式已经被淘汰了，一个弊端例如：</p><p>这种方式无法扩展，CGI 进程（类似 Python 解释器）针对每个请求进行创建，用完就抛弃。</p><p>如果应用程序接收数千个请求，创建大量的语言解释器进程很快就会导致服务器停机。<br>有两种方法可以解决这个问题，一是服务器集成，二是外部进程。因此CGI被框架或新的东西代替了。</p><p>web服务器一般用C写，而应用程序用各种语言都可以。</p><p>CGI是web服务器与应用程序（CGI程序）接口标准，两个直接信息传递的规程。这个规范运行web服务器执行外部程序，就是CGI程序，这样就实现了获取动态资源。这种方式每次来一个请求就要创建一个子进程，处理完成再结束这个子进程，就是fork-and-execute模式。后来又设计出了wsgi，成为web网关服务接口，也是在web服务器和应用程序之间提供一个通用的API标准。</p><p>好了，我们来做一个总结，CGI是标准，WSGI也是标准，我们用CGI标准实现一个应用程序，用于处理动态数据并返回渲染后的HTML页面（其中一种情况），可以用python来实现这个程序。一个请求来的时候，用CGI方式的话，就会创建一个CGI子进程（我们不要管是谁来创建这个子进程的），然后子进程调用CGI程序得到返回数据传给客户端。  WSGI也是一个标准，我们会实现一个服务，这个服务负责处理请求，并将请求分配到对应的应用程序上。看起来有点类似，这个处理请求和分配到应用程序上的基于WSGI标准的程序不用像CGI那样每次都要创建子进程。在django的默认处理里面，就有wsgi程序。</p><p>WSGI,实现这一标准的服务器，比如uWSGI, Gunicorn 。称为wsgi服务器，也就是server，这个服务器需要和一个实现WSGI规范的接口相配合，一般定义一个函application(environ,start_response)。</p><h2 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h2><p>核心提示：搜索和匹配的比较</p><p>本章通篇会使用搜索和匹配两个术语。当严格讨论与字符串中模式相关的正则表达式时，我们会用术语“匹配”（matching），指的是术语“模式匹配”（pattern-matching）。在Python 术语中，主要有两种方法完成模式匹配：“搜索”（searching），即在字符串任意部分中搜索匹配的模式；而“匹配”（matching）是指判断一个字符串能否从起始处全部或者部分地匹配某个模式。搜索通过 search()函数或方法来实现，而匹配通过调用 match()函数或方法实现。总之，当涉及模式时，全部使用术语“匹配”；我们按照 Python 如何完成模式匹配的方式来区分“搜索”和“匹配”。</p><ol><li>如何写出灵活的re是关键，比如  .+  就可以匹配任意长度的字符串，再和其它元字符等配合，可以实现高效的组合</li><li>理解re表达式，结合模块的方法即可使用RE（可以概况为RE表达式和python语言）</li><li>理解返回的结果</li></ol><p>预编译：re.compile()</p><p>匹配  ： 一般指模式匹配。如何完成模式匹配？主要使用“搜索”和“匹配”两种方法实现</p><p>re的组成：通用文本，如hello。特殊符号和字符，称为元字符</p><p>元字符表：</p><p><img src="/images/ReadBook/py-code-re_1.png" alt="image"></p><p><img src="/images/ReadBook/py-code-re_2.png" alt="image"></p><p>择一匹配   “|”       re=’hello|world’</p><p>匹配任意单个字符串  “.”  re = ‘fa.b’  可以匹配a和b之间可以是任意字符（换行除外，修改编译标记可以解除这个限制）。可以使用多个点  ..   则匹配任意两个  .灵活用在文本的前面后面，中间。</p><p>数量词的贪婪模式与非贪婪模式</p><ul><li>贪婪     总是尝试匹配尽可能多的字符</li><li>非贪婪   总是尝试匹配尽可能少的字符</li></ul><p>正则表达式通常用于在文本中查找匹配的字符串。Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符；非贪婪的则相反，总是尝试匹配尽可能少的字符。例如：正则表达式”ab*”如果用于查找”abbbc”，将找到”abbb”。而如果使用非贪婪的数量词”ab*?”，将找到”a”。</p><p>compile  标记参数：</p><ul><li>re.I(re.IGNORECASE): 忽略大小写（括号内是完整写法，下同）</li><li>M(MULTILINE): 多行模式，改变’^’和’$’的行为（参见上图）</li><li>S(DOTALL): 点任意匹配模式，改变’.’的行为</li><li>L(LOCALE): 使预定字符类 \w \W \b \B \s \S 取决于当前区域设定</li><li>U(UNICODE): 使预定字符类 \w \W \b \B \s \S \d \D 取决于unicode定义的字符属性</li><li>X(VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。</li></ul><p>字符集 [abc]</p><p>限定范围和否定 [a-b] </p><p>常用符号</p><ul><li>*   o次或者多次</li><li>+   1次或者多次</li><li>？  0次或者一次</li></ul><p>o次就是允许没有，比如z?  分析它是一个通用文本   “？”  号将前面的通用文本进行一次或0次匹配。</p><p>比如zz, zx都是可以匹配到的，如此 *  + 也就理解了。</p><p>{0，1} 前一个正则匹配的次数0次或1次，使用符号为{}</p><p>注意：这些符号是对通用文本的扩充，比如原来的re=aa, 如果你想匹配8个a,好的做法是a{8}, 而不是写8个a.</p><p>表示字符集的特殊字符：\d 数字  \w字母（大小写） 他们的大写如  \D  表示不匹配，即非十进制数字。</p><p>分组：提取任何已经成功匹配的特定字符串或者子字符串</p><p>使用（）包裹re表达式，可以进行分组或匹配子组，注意这两个的区别：</p><ul><li>分组：被包裹的re表达式会是一个整体，一般在后面接上量词。每一个括号得到分组为组1，后面的分组累加 <code>(a(b))   组1  ab   组2   b</code></li><li>子组：上面得到的组1就是子组了，可以称为子组1</li></ul><p>扩展表示法：通常形式（?…） 尽管圆括号使用这些符号，但是只有（?P&lt;name&gt;）表述一个分组匹配。所有其他的都没有创建一个分组。</p><p>边界匹配 ： 符号   \b  \B     \b是一个单词的边界匹配，  r’\ber’   能匹配   ‘a er’  不能匹配  ‘aer’<br>要匹配  ’aer‘  re=r’er\b’</p><p>闭合操作符是非贪婪的</p><p>语言</p><p>re可以先进行预编译，用得到的编译对象再去操作函数或方法，也可以用模块（re）直接调用方法，这个时候需要传入pattern参数，即一个re表达式。</p><p>理解搜索和匹配，匹配是从头开始，如果第一个字符串就不匹配，则匹配模式失败，如果用搜索模式，则会把被匹配对象从头到尾都匹配一编，中间有符合条件的就可以得到匹配结果。</p><p>findall() 该函数返回正则表达式模式全部的非重复情况，结果是一个列表，没有匹配就是空列表。</p><p>这个函数的结果就是一个列表了，它没有group等属性了。</p><p>finditer()和上面的类似，结果是一个迭代器。</p><p>sub()和 subn()搜索与替换  功能就是将字符串能匹配到的都替换成其它字符串，subn会返回替换计数。</p><p>split()分隔字符串：匹配成功的时候进行，号分割，返回的是分割后结果的列表。即一个字符串，左到右，满足条件就进行分割。</p><p>扩展表示：</p><p>在分组的时候重新起一个名字‘z’   re = r’ns(?P&lt;z&gt;\d+)’   re.match(ns7).group(‘z’)    out:  7</p><p>数量词组合：+， *  这两个是贪婪的，可以在后面加上？ 变成非贪婪。</p><p>re = ‘.+c’    str=’abcabc’   out=’abcabc’   如果re=’.+?’  out=’abc’</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ReadBook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReadBook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-util 工具</title>
      <link href="/2018/10/22/PythonUtil/base/"/>
      <url>/2018/10/22/PythonUtil/base/</url>
      
        <content type="html"><![CDATA[<p>python 偷懒小工具，通过编写脚本实现日常功能</p><a id="more"></a><h2 id="markdown-table-语法生成"><a href="#markdown-table-语法生成" class="headerlink" title="markdown table 语法生成"></a>markdown table 语法生成</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token triple-quoted-string string">"""markdown 的table语法格式 自动生成代码，错误的地方需要手动处理一下，中文因为字符占位问题，无法做到统一格式化"""</span>op_str <span class="token operator">=</span> <span class="token triple-quoted-string string">'''v-bind ：动态绑定数据。简写为“:” 。=> 以后的:class="{red:boolean}"v-on ：绑定时间监听器。简写为“@”，例：@click="xxx"；v-text ：更新数据，会覆盖已有结构。类似{{ msg }} ；v-show ：根据值的真假，切换元素的display属性；v-if ：根据值的真假，切换元素会被销毁、重建； => 在dom中已消失v-else-if ：多条件判断，为真则渲染；v-else ：条件都不符合时渲染；v-for ：基于源数据多次渲染元素或模块；v-model ：在表单控件元素（input等）上创建双向数据绑定（数据源）；v-pre ：跳过元素和子元素的编译过程；v-once ：只渲染一次，随后数据更新也不重新渲染；v-cloak ：隐藏未编译的Mustache语法，在css中设置[v-cloak]{display:none;}'''</span>_op_str <span class="token operator">=</span> op_str<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span>_op_str<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>out_str <span class="token operator">=</span> <span class="token string">''</span>max_str_len <span class="token operator">=</span> len<span class="token punctuation">(</span><span class="token string">'v-else-if'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># pop(key[, default])</span>space <span class="token operator">=</span> <span class="token string">' '</span><span class="token keyword">for</span> item <span class="token keyword">in</span> _op_str<span class="token punctuation">:</span>    tmp <span class="token operator">=</span> item<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">''</span><span class="token punctuation">:</span>        tmp_str <span class="token operator">=</span> <span class="token string">"| Command{space} | Description \n"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>space<span class="token operator">=</span>space <span class="token operator">*</span> <span class="token punctuation">(</span>max_str_len <span class="token operator">-</span> len<span class="token punctuation">(</span><span class="token string">'Command'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        tmp_str <span class="token operator">+=</span> <span class="token string">"| {a} | :{b}: \n"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token string">'-'</span> <span class="token operator">*</span> max_str_len<span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token string">'-'</span> <span class="token operator">*</span> <span class="token punctuation">(</span>max_str_len <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        tmp_str <span class="token operator">=</span> <span class="token string">"| {a}{space} | {b} \n"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>a<span class="token operator">=</span>tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> space<span class="token operator">=</span>space <span class="token operator">*</span> <span class="token punctuation">(</span>max_str_len <span class="token operator">-</span> len<span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    out_str <span class="token operator">+=</span> tmp_str<span class="token keyword">print</span><span class="token punctuation">(</span>out_str<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># print(len('Inheritor'))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python常用方法</title>
      <link href="/2018/10/22/PythonUtil/common_tool/"/>
      <url>/2018/10/22/PythonUtil/common_tool/</url>
      
        <content type="html"><![CDATA[<p>记录python常用方法</p><a id="more"></a><h2 id="获取文件所在目录"><a href="#获取文件所在目录" class="headerlink" title="获取文件所在目录"></a>获取文件所在目录</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> ospath <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>dirname<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>abspath<span class="token punctuation">(</span>__file__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="dict扩展"><a href="#dict扩展" class="headerlink" title="dict扩展"></a>dict扩展</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">AttrDict</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    不继承dict，实现一个dict，实例化使用关键字参数的形式：AttrDict(a=1, b=2)    __getitem__，__setitem__，__delitem__称为容器方法，就是_dict['a']这种操作的    拦截，而__getattribute__（访问属性先执行这个，然后执行__getattr__），    __setattr__这种才是属性拦截，通过把关键字参数赋值给__dict__，实现了可以通过    _dict.a 或 _dict['a'] 的形式访问字典键值    """</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>__dict__<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__getitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__getattribute__<span class="token punctuation">(</span>item<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__setitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__setattr__<span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__delitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__delattr__<span class="token punctuation">(</span>key<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__len__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>__dict__<span class="token punctuation">)</span>attr_dict <span class="token operator">=</span> AttrDict<span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>attr_dict<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>attr_dict<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># print(attr_dict.get('a')) 报错的，这是字典的方法，这个类没有继承字典</span><span class="token keyword">class</span> <span class="token class-name">AttrDict2</span><span class="token punctuation">(</span>dict<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    继承dict，扩展链式操作    """</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'init a dict'</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># dict.__init__(self, *args, **kwargs) # 同下super的效果</span>        super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 继承dict的对象，对象的实例就是一个字典，print(_dict)可以看到，既然如此，把这个</span>        <span class="token comment" spellcheck="true"># 字典给到__dict__，那么对象的属性就有了</span>        self<span class="token punctuation">.</span>__dict__ <span class="token operator">=</span> self_dict <span class="token operator">=</span> AttrDict2<span class="token punctuation">(</span><span class="token punctuation">)</span>_dict<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">33</span><span class="token keyword">print</span><span class="token punctuation">(</span>_dict<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>_dict<span class="token punctuation">.</span>__dict__<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 如果再次执行_dict['b'] = 44，已经不执行__init__方法了，但是self.__dict__ = self已经关联了，</span><span class="token comment" spellcheck="true"># dict做为可变变量类型，同样更新了__dict__</span>_dict<span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">44</span><span class="token keyword">print</span><span class="token punctuation">(</span>_dict<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>_dict<span class="token punctuation">.</span>__dict__<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>_dict<span class="token punctuation">.</span>a<span class="token punctuation">,</span> _dict<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-definitive-guide 读书笔记</title>
      <link href="/2018/10/22/ReadBook/javascript-definitive-guide/"/>
      <url>/2018/10/22/ReadBook/javascript-definitive-guide/</url>
      
        <content type="html"><![CDATA[<p>JavaScript 权威指南 读书笔记，节选部分内容</p><a id="more"></a><h2 id="关于分号"><a href="#关于分号" class="headerlink" title="关于分号"></a>关于分号</h2><p>关于分号，分号可以不要，如果你不要分号，语句会被解释器连起来。</p><p>比如：</p><pre class="line-numbers language-js"><code class="language-js">  <span class="token keyword">var</span> x <span class="token operator">=</span> y <span class="token operator">+</span> z  <span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>实际是 <code>var x = y + z(a+b).result()</code> 分号是语句的结束，你不加分号解释器会自己来处理，它处理不了的语句会自己加分号，等等一些规则，所以养成加分号是好习惯，避免前面的语句改了，没有分号语句被解释器组合了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ReadBook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReadBook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客迁移</title>
      <link href="/2018/10/22/Water/UseHexo/"/>
      <url>/2018/10/22/Water/UseHexo/</url>
      
        <content type="html"><![CDATA[<p>关于博客迁移，最开始是在有道上做笔记，学习记录，后来萌生了写类似博客网站的想法，于是用element-UI框架写了一个，整体的效果还不错，还有一个后台管理，使用Django作为web服务，每篇文章存储在数据库，但是想要的功能太多了，设计的功能也显得格格不入（完全按照自己的想法来），后来放弃了，转用了VuePress，后来又看到Hexo，还是迁移到Hexo吧。开始使用VuePress，也是因为作者说会在后续添加博客的功能，结果没有后续了，Hexo作为博客提供了很全面的功能</p><a id="more"></a><h1 id="博客迁移"><a href="#博客迁移" class="headerlink" title="博客迁移"></a>博客迁移</h1><p>关于博客迁移，最开始是在有道上做笔记，学习记录，后来萌生了写类似博客网站的想法，于是用element-UI框架写了一个，整体的效果还不错，还有一个后台管理，使用Django作为web服务，每篇文章存储在数据库，但是想要的功能太多了，设计的功能也显得格格不入（完全按照自己的想法来），后来放弃了，转用了VuePress，后来又看到Hexo，还是迁移到Hexo吧。开始使用VuePress，也是因为作者说会在后续添加博客的功能，结果没有后续了，Hexo作为博客提供了很全面的功能</p><h2 id="迁移脚本"><a href="#迁移脚本" class="headerlink" title="迁移脚本"></a>迁移脚本</h2><p>大概扫描了一下Hexo的官方，马上起了一个项目，发现这个文件结构和VuePress差的有点多啊，不怕，写个迁移脚本就行了，这样就把原来文件结构都取出来放到通用目录下，顺便生成一下Hexo的yaml-Front-matter，对README的文件做一下重命名。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python</span><span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-</span><span class="token triple-quoted-string string">"""@author:   LiuZhi@file:     hexo_change.py@time:     2019-10-22 23:48@contact:  vanliuzhi@qq.com@software: PyCharm"""</span><span class="token keyword">import</span> ospath <span class="token operator">=</span> <span class="token string">'/Users/liuzhi/PycharmProjects/test_code/zh/'</span>op_list <span class="token operator">=</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>path<span class="token punctuation">)</span>write_data2 <span class="token operator">=</span> <span class="token triple-quoted-string string">'''---title: %sdate: 2018-10-22 00:00:00updated: 2018-10-22 00:00:00tags:categories:---'''</span><span class="token keyword">def</span> <span class="token function">write_data</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span><span class="token punctuation">:</span>    a <span class="token operator">=</span> write_data2 <span class="token operator">%</span> title    <span class="token keyword">return</span> a<span class="token keyword">def</span> <span class="token function">get_absolute_path</span><span class="token punctuation">(</span>dir_name<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> path <span class="token operator">+</span> dir_name<span class="token keyword">def</span> <span class="token function">get_dir_file</span><span class="token punctuation">(</span>_dir<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> _dir <span class="token operator">!=</span> <span class="token string">'/Users/liuzhi/PycharmProjects/test_code/zh/.DS_Store'</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> item <span class="token keyword">in</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>_dir<span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">=</span> _dir <span class="token operator">+</span> <span class="token string">'/'</span> <span class="token operator">+</span> item            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">loop_file_path</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    dir_list <span class="token operator">=</span> map<span class="token punctuation">(</span>get_absolute_path<span class="token punctuation">,</span> op_list<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> list<span class="token punctuation">(</span>dir_list<span class="token punctuation">)</span><span class="token punctuation">:</span>        get_dir_file<span class="token punctuation">(</span>i<span class="token punctuation">,</span> result<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>    <span class="token keyword">return</span> result<span class="token keyword">def</span> <span class="token function">save_name</span><span class="token punctuation">(</span>_dir<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>    _list <span class="token operator">=</span> _dir<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>    name <span class="token operator">=</span> _list<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">if</span> name <span class="token operator">==</span> <span class="token string">'README.md'</span><span class="token punctuation">:</span>        name <span class="token operator">=</span> _list<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">'.md'</span>    <span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'/Users/liuzhi/PycharmProjects/test_code/result/'</span> <span class="token operator">+</span> name<span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">get_name</span><span class="token punctuation">(</span>_dir<span class="token punctuation">)</span><span class="token punctuation">:</span>    _list <span class="token operator">=</span> _dir<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>    name <span class="token operator">=</span> _list<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">if</span> name <span class="token operator">==</span> <span class="token string">'README.md'</span><span class="token punctuation">:</span>        name <span class="token operator">=</span> _list<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">'.md'</span>    <span class="token keyword">return</span> name<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">hexo_change</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    实现在文件头写入，不能使用a+模式，需要截断成0字节    总体来说，要实现任意位置写入，只能是通过读取整个文件，然后将    需要写入的插入，然后把整个结果写入    :param file_name:    :return:    """</span>    <span class="token keyword">for</span> file_name <span class="token keyword">in</span> loop_file_path<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">with</span> open<span class="token punctuation">(</span>file_name<span class="token punctuation">,</span> <span class="token string">'r+'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> _file<span class="token punctuation">:</span>            old <span class="token operator">=</span> _file<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>            _file<span class="token punctuation">.</span>seek<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>            _file<span class="token punctuation">.</span>write<span class="token punctuation">(</span>write_data<span class="token punctuation">(</span>get_name<span class="token punctuation">(</span>file_name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            _file<span class="token punctuation">.</span>write<span class="token punctuation">(</span>old<span class="token punctuation">)</span>    <span class="token keyword">for</span> file_name <span class="token keyword">in</span> loop_file_path<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">with</span> open<span class="token punctuation">(</span>file_name<span class="token punctuation">,</span> <span class="token string">'r+'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> _file<span class="token punctuation">:</span>            old <span class="token operator">=</span> _file<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>            save_name<span class="token punctuation">(</span>file_name<span class="token punctuation">,</span> old<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">insert_content_to_file</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    file <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">"a.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span>    file_add <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">"a.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span>    content <span class="token operator">=</span> file<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>    content_add <span class="token operator">=</span> file_add<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>    pos <span class="token operator">=</span> content<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">"buildTypes"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> pos <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>        content <span class="token operator">=</span> content<span class="token punctuation">[</span><span class="token punctuation">:</span>pos<span class="token punctuation">]</span> <span class="token operator">+</span> content_add <span class="token operator">+</span> content<span class="token punctuation">[</span>pos<span class="token punctuation">:</span><span class="token punctuation">]</span>        file <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">"a.txt"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span>        file<span class="token punctuation">.</span>write<span class="token punctuation">(</span>content<span class="token punctuation">)</span>        file<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>        file_add<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    cp_cmd <span class="token operator">=</span> <span class="token string">'cp -rf ~/JavaScriptProjects/my-notebook/docs/zh/ ~/PycharmProjects/test_code/zh'</span>    rm_zh <span class="token operator">=</span> <span class="token string">'rm -rf ~/PycharmProjects/test_code/zh/'</span>    mark_dir <span class="token operator">=</span> <span class="token string">'mkdir ~/PycharmProjects/test_code/zh'</span>    cmd_list <span class="token operator">=</span> <span class="token punctuation">[</span>rm_zh<span class="token punctuation">,</span> mark_dir<span class="token punctuation">,</span> cp_cmd<span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> cmd_list<span class="token punctuation">:</span>        os<span class="token punctuation">.</span>system<span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># map(lambda x: os.system(x), cmd_list)</span><span class="token keyword">def</span> <span class="token function">cp_new_file</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    cp_cmd <span class="token operator">=</span> <span class="token string">'cp -rf ~/PycharmProjects/test_code/result/ /Users/liuzhi/JavaScriptProjects/hexo_blog/source/_posts'</span>    os<span class="token punctuation">.</span>system<span class="token punctuation">(</span>cp_cmd<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># init()</span>    <span class="token comment" spellcheck="true"># hexo_change()</span>    cp_new_file<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>浏览过一遍文档，如果不着急搞分享，评论什么的，上手会很快，开始我的图片资源也是没有问题了，直到我看了官方的<code>资源文件夹</code>功能，它提出了一个顾虑（我真的没感觉到会有这个问题，分类和主页的资源，怎么会有路径问题呢？难道是历史原因），推荐使用此功能，需要进行对应的配置，使用<code>{% asset_img example.jpg This is an example image %}</code>，坑就坑在这么用完全没效果，然后我Google，发现别人都是装插件的，查了我的package.json，没插件啊，官方这文档不负责啊。</p><p>然而坑还没结束，装了插件仍然没用，于是我去看了GitHub对插件的用法，需要使用Markdown语法，我真是哔了狗了，Hexo的文档英文也是明确说明不要使用Markdown语法，用插件语法，这完全没用啊，看了别人的用法也是用Markdown语法。</p><p>最后，经过我的测试，使用Markdown语法，配合插件可以使用相对路径，如果这样用，你的每篇博客不能创建独立的文件夹，只能放在_posts下，不知道是BUG还是什么问题，总之一点官方文档给的用法没有效果，插件的作者都没这么用，个人猜测框架扩展了插件后，使用插件语法应该是没问题的，Hexo支持这么多插件，然而在这个插件上出了问题估计是BUG了。</p><p>解决方案：使用Markdown语法，图片放在<code>_posts/images</code>下，由于这是绝对路径，部署和本地都是正常的，另外不一定要把文章放在_posts下，可以再创建一个父级目录，虽然编译后文章被分类了，但是原始项目这么搞就太混乱了，这让我觉得使用命令创建文章有点鸡肋了。</p><h2 id="常用命令补充"><a href="#常用命令补充" class="headerlink" title="常用命令补充"></a>常用命令补充</h2><ol><li><p><code>hexo generate</code> 生成静态文件，不会去执行部署</p></li><li><p>监视文件变动<br>Hexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。</p></li></ol><p><code>hexo generate --watch</code></p><ol start="3"><li><code>hexo server</code><br>参数：</li></ol><p>-p, –port    重设端口<br>-s, –static    只使用静态文件<br>-l, –log    启动日记记录，使用覆盖记录格式</p><ol start="4"><li>hexo –debug 调试模式，会记录日志</li></ol><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>开始还在研究用什么应用服务器，最好使用hexo自带的，然后反向代理过去，结果502了，也不说是什么问题，后来发现直接用静态文件处理就行了，<br>不用这么麻烦。</p><pre><code>location / {    # 将blog目录下的全路径public复制进来       root   /root/blog/public;         }     }</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Water </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Water </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>svn 版本控制工具</title>
      <link href="/2018/10/22/SVN/svn-base/"/>
      <url>/2018/10/22/SVN/svn-base/</url>
      
        <content type="html"><![CDATA[<p>SVN版本控制</p><a id="more"></a><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ol><li>查看日志</li></ol><p>svn log –search liuzhi -l 100  -v .<br>svn log –search liuzhi -l 100  查看特定用户的提交日志和修改文件(注意这里的100条是全部的提交记录，是在这100条中过滤用户)</p><pre class="line-numbers language-s"><code class="language-s">参数: --search liuzhi 筛选结果，这里筛选用户-l 筛选条数-v 查看修改文件，后面的参数为查看的目录，在项目根目录执行就可以看到所有的文件修改日志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其它用法</p><p>svn log -r 4:5;  #只看版本4和版本5的日志信息;<br>svn log test.c -v;  #查看文件test.c的日志修改信息;<br>svn list <a href="http://svn.test.com/svn" target="_blank" rel="noopener">http://svn.test.com/svn</a>  #查看目录中的文件;</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Web </tag>
            
            <tag> Svn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 学习笔记</title>
      <link href="/2018/10/22/Web/Nginx/"/>
      <url>/2018/10/22/Web/Nginx/</url>
      
        <content type="html"><![CDATA[<p>Nginx (engine x) 是一个高性能的HTTP和反向代理服务，也是一个IMAP/POP3/SMTP服务，静态文件应该交由 Web 服务器来处理，动态内容由应用服务器来处理。另外编译安装可以定制很多东西，有些包管理器安装的版本不能支持HTTPS，需要编译安装才行。关于HTTPS服务，由于自己创建的证书不被认可，浏览器会识别有风险，这就比较尴尬了，可以使用免费的SSL证书服务 <a href="https://www.jianshu.com/p/3ae2f024c291" target="_blank" rel="noopener">申请Let’s Encrypt永久免费SSL证书</a></p><a id="more"></a><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ul><li>nginx -s reload  ：修改配置后重新加载生效</li><li>nginx -s reopen  ：重新打开日志文件</li><li>nginx -c 配置文件路径 ：使用指定配置文件运行Nginx</li><li>nginx -t 测试nginx配置文件是否正确</li></ul><p>输出如下，可以知道配置文件所在位置</p><blockquote><p>nginx: the configuration file /etc/nginx/nginx.conf syntax is ok<br>nginx: configuration file /etc/nginx/nginx.conf test is successful</p></blockquote><ul><li>nginx -s stop  ：快速停止nginx</li><li>nginx -s quit  ：完整有序的停止nginx</li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><blockquote><p>记得配置后面需要 <code>;</code> 结尾，修改配置后通过 nginx -t 测试配置正确性再启动Nginx</p></blockquote><p>nginx的配置, 一般就是配server模块，该模块的全局定义，location 定义了正则的解析（向服务器请求各种资源，nginx应该如何处理），然后配合各种指令，理解各种指令很重要。默认的nginx配置会使用模块的方式，即一个基本配置文件，加上导入的其它配置文件。</p><pre><code>...   #全局块events {  #events块   ...}http      #http块{    ...   #http全局块    server        #server块    {         ...       #server全局块        location [PATTERN]   #location块        {            ...        }        location [PATTERN]         {            ...        }    }    server    {      ...    }    ...     #http全局块}</code></pre><p>每一个server块就是一个虚拟主机，如果使用官方的模块化的配置，那么就是主配置文件定义全局的，通过include导入各个server，整体的结果就是通过增加server，比如有站点A，站点B，那么配置a.conf，b.conf，它们都导入到主配置文件中，整体就连接起来了。</p><h2 id="mime-types"><a href="#mime-types" class="headerlink" title="mime.types"></a>mime.types</h2><p>在官方的配置文件中，导入了这个文件，跟进去查看，其实就是对文件类型的定义，配置文件内容如下：</p><pre><code>include       /etc/nginx/mime.types;default_type  application/octet-stream;</code></pre><p>这里还定义了默认类型，如果不写，默认为text/plain，web开发中，对于请求的资源都是有定义的，资源类型的定义决定了浏览器应该如果处理它</p><h3 id="location-配置"><a href="#location-配置" class="headerlink" title="location 配置"></a>location 配置</h3><p>location 后面通过正则来匹配路由，将匹配到的请求交由该location来处理。</p><p><strong>1. root</strong>：root指令指明了被匹配的路由要去查询的地址，以官方默认配置为例</p><pre><code>location / {        root   /usr/share/nginx/html;        index  index.html index.htm;    }</code></pre><p>当路由是 / 的时候，搜索路径为 <code>/usr/share/nginx/html</code>，这里的html其实是个文件夹，就是去html下查找，文件夹内容为</p><pre><code>root@8c67bbe80ff5:/usr/share/nginx/html# ls -ltotal 8-rw-r--r-- 1 root root 494 Dec 25 09:56 50x.html-rw-r--r-- 1 root root 612 Dec 25 09:56 index.html</code></pre><p>如果不是 <code>/</code> 而是 <code>/img</code>，搜索路径为 <code>/usr/share/nginx/html/img</code></p><p><strong>2. alias</strong>：是用来取别名，假设设置的匹配为 <code>/img</code>，<code>alias /usr/share/nginx/html</code>，url为 <code>http://www.hello.com/img/a.jpg</code> 搜索路径为<code>/usr/share/nginx/html/a.jpg</code>，可以看到没像root一样在html后面加路径，就是因为alias是取别名，访问 <code>/img</code> 变成访问取的别名。</p><h2 id="关于监听端口"><a href="#关于监听端口" class="headerlink" title="关于监听端口"></a>关于监听端口</h2><p>这也是一个容易被忽视的概念，但也是web开发很基础的概念。</p><p>首先要知道，通过域名解析，只能到ip，默认的端口是80，这是由http服务默认的，因为HTTP默认端口是80，HTTPS默认端口是443。</p><p>假设域名是 <a href="http://www.liuzhidream.com">www.liuzhidream.com</a> 解析到ip 123.123.1.1 由浏览器发起的http请求 <a href="http://www.liuzhidream.com">www.liuzhidream.com</a> 实际是 <a href="http://www.liuzhidream.com:80，对应ip就是">www.liuzhidream.com:80，对应ip就是</a> 123.123.1.1:80。</p><p>所以要在nginx上监听80端口，如果你想要监听其它端口，那么通过域名访问就要显示的指定端口了，或者通过其它方法：</p><ol><li>CDN </li><li>url转发</li></ol><p>总之80是默认的HTTP端口，不想使用这个端口就要手动处理请求。</p><h2 id="配置文件参考"><a href="#配置文件参考" class="headerlink" title="配置文件参考"></a>配置文件参考</h2><p>主配置文件</p><pre><code>user nginx;          # nginx运行的用户及用户组worker_processes 1; # worker进程个数error_log /var/log/nginx/error.log warn; # 错误日志目录pid       /var/run/nginx.pid;            # nginx启动后进程pid写入这个文件events {    worker_connections 65536; # 每个worker进行的最大连接数}http {    include       /etc/nginx/mime.types; # 导入解析文件类型    default_type  application/octet-stream;    log_format main '$remote_addr - $remote_user [$time_local] "$request" '                    '$status $body_bytes_sent "$http_referer" '                    '"$http_user_agent" "$http_x_forwarded_for"'; # 日志格式    access_log  /var/log/nginx/access.log  main; # 访问日志    upstream frontends {         server app:5000; # 反向代理配置    }    include /etc/nginx/conf.d/*.conf; # 导入其它配置}</code></pre><p>server 部分</p><pre><code>server { listen 80; # 监听端口server_name test.liuzhi.com;keepalive_timeout 5; # keepalive超时时间，默认是75秒location ^~ /static/ { # /static/ 这种路径通常放了静态文件，由nginx直接serveroot /web/flask_starlight; # 静态文件存储的位置}location ~* \.(woff|eot|ttf|svg|mp4|webm|jpg|jpeg|png|gif|ico|css|js)$ {expires 30d; # 静态文件由于变化很小，超时时间设置的很长}location / {proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;proxy_set_header Host $host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Scheme $scheme;proxy_redirect off;proxy_pass http://frontends;}}</code></pre><pre><code>server {    listen       80;    server_name  www.liuzhidream.com;    location / {        root   /root/blog/public;    }    error_page   500 502 503 504  /50x.html;    location = /50x.html {        root   /usr/share/nginx/html;    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Note </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Celery 在 web 开发中的运用</title>
      <link href="/2018/10/22/Web/Celery/"/>
      <url>/2018/10/22/Web/Celery/</url>
      
        <content type="html"><![CDATA[<p>Celery - Distributed Task Queue。要理解 Celery 本身不是任务队列，它是管理分布式任务队列的工具，或者换一种说法，它封装好了操作常见任务队列的各种操作，我们用它可以快速进行任务队列的使用与管理，当然你也可以自己看 rabbitmq 等队列的文档然后自己实现相关操作都是没有问题的。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>通过Python的包管理工具来安装，在我查到的一些资料中，celery和docker的配合不是很好，建议不要在单一容器中使用celery了。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul><li>生产者(Celery client)。生产者(Celery client)发送消息。在Flask上工作时，生产者(Celery client)在Flask应用内运行。</li><li>消费者(Celery workers)。消费者用于处理后台任务。消费者(Celery client)可以是本地的也可以是远程的。我们可以在运行Flask的server上运行一个单一的消费者(Celery workers)，当业务量上涨之后再去添加更多消费者(Celery workers)。</li><li>消息传递者(message broker)。生产者(Celery client)和消费者(Celery workers)的信息的交互使用的是消息队列(message queue)。Celery支持若干方式的消息队列，其中最常用的是RabbitMQ和Redis.</li></ul><p>以上是最基本的架构，完整的组件还包括：</p><ol><li>Celery Beat：任务调度器</li><li>Celery Worker：执行任务的消费者</li><li>Broker：消息代理</li><li>Product：任务生产者（通过API，装饰器等产生任务并交个任务队列处理）</li><li>Result Backend：任务处理完成后，保存状态信息，以供查询</li></ol><p>1，4都是任务的生产者，只是方式不一样，1的方式是Beat进程读取配置文件，周期性的将到期的任务发给任务队列执行，就是定时任务。</p><h2 id="在flask中使用celery"><a href="#在flask中使用celery" class="headerlink" title="在flask中使用celery"></a>在flask中使用celery</h2><p>如何集成，并且很好的解耦模块是celery运用的关键。你总不能把代码都堆叠在一起吧。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>flask_celery不能支持celery4.0，所以弃用扩展模块，直接使用celery模块。使用扩展的好处是在扩展模块在一个文件初始化，并且全局保持一个实例对象，所以你的celery需要在app创建后才能创建，需要考虑是否使用了全局的celery对象</li><li>创建celery的实例对象的名字使用flask应用程序app的名字，通过 <code>app.name</code> 获取，如果你使用扩展插件，建议不要修改此名称，否则创建失败，不使用扩展插件也不建议修改</li><li>当有多个装饰器的时候，celery.task一定要在最外层</li></ul><p>init代码</p><pre class="line-numbers language-python"><code class="language-python">app <span class="token operator">=</span> create_app<span class="token punctuation">(</span>CONFIG<span class="token punctuation">)</span>celery <span class="token operator">=</span> CeleryApp<span class="token punctuation">(</span>app<span class="token punctuation">.</span>name<span class="token punctuation">)</span>celery<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>update<span class="token punctuation">(</span>app<span class="token punctuation">.</span>config<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>首先创建Flask app的实例app，然后创建Celery的实例celery，这里需要传递一个名称，这个名称会作为celery task的前缀，例如 <code>flask_app.celery_app.task.long_task</code>，long_task是我们定义的任务，你要改创建实例的参数也可以，建议不要修改。这里的CeleryApp是自己编写的，继承Celery的一个类，目的是实现单实例，让其它模块通过CeleryApp创建的实例保持一样，然后调用celery.conf.update更新参数，<code>flask app.config</code> 是继承dict的Config类，这样就把需要的参数配置通过flask配置，作用于celery。</p><p>flask大多数的插件做的事情就是在单独的扩展文件中，先不传递参数实例化扩展，然后在创建app的时候初始化它，估计flask_celery也是做差不多的事情，不过实例化Celery必须要先传递参数，现在插件没有在更新了(有一些其他名称的扩展可以支持)，主要还是为了工程化。</p><p>这里记录一下扩展包的情况吧，在py3中，有：</p><p>Flask-Celery：这个其实不是扩展，而是装这个就把Celery相关的给安装了，这个是Celery的作者写的，他也说在4.0版本不再需要了，我也没看出来这个有什么用</p><p>Flask-Celery-Helper：这个就是扩展了，导入用flask_celery，不支持4.0</p><p>Flask-Celery-py3，Flask-Celery3：好像都是不支持4.0的</p><p>Flask-CeleryExt：在文档中写明可以支持4.0了，和大部分扩展使用方法一样，用懒加载的方式实例化</p><h3 id="数据序列化"><a href="#数据序列化" class="headerlink" title="数据序列化"></a>数据序列化</h3><table><thead><tr><th>Command</th><th align="center">Description</th></tr></thead><tbody><tr><td>pickle:</td><td align="center">二进制序列化方式；是标准库的一个模块，支持Python的内置数据结构，但是他是Python的专有协议，在celery3.2开始，出于安全考虑，不再采用此方案；</td></tr><tr><td>json:</td><td align="center">json支持多种语言，可用于跨语言方案，但好像不支持自定义的类对象；</td></tr><tr><td>XML:</td><td align="center">类似标签语言；</td></tr><tr><td>msgpack:</td><td align="center">二进制的类json序列化方案，但比json的数据结构更小，更快；</td></tr><tr><td>yaml:</td><td align="center">yaml表达能力更强，支持的数据类型较json多，但是python客户端的性能不如json;</td></tr></tbody></table><p>在自定义对象上，序列化方案我也出现过问题，pickle用了不行，可能就是不支持了，有待解决</p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol><li><code>celery = Celery(app.name)</code> 创建celery实例</li><li><code>celery.conf.update(app.config)</code> 更新配置</li><li>在需要后台运行的任务使用@celery.task</li></ol><pre class="line-numbers language-python"><code class="language-python">@celery<span class="token punctuation">.</span>task<span class="token keyword">def</span> <span class="token function">hello_world</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token string">"hello_world"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>需要注意的是，被装饰的任务需要调用才会加到任务队列，也就是通过hello_world.delay()调用，在官方的例子中，通过继承的方式，增加 <code>__call__</code> 方法，内部调用run，这样装饰器@celery.task()便会直接加入任务队列了，不过这样的功能应该是不需要的。</p><p>通过 <code>r = hello_world.delay()</code> 方法，返回的对象拥有以下方法：</p><table><thead><tr><th>Command</th><th align="center">Description</th></tr></thead><tbody><tr><td>r.ready()</td><td align="center">#查看任务状态，返回布尔值，任务执行完成，返回True，否则返回False.</td></tr><tr><td>r.wait()</td><td align="center">#等待任务完成,返回任务执行结果，很少使用；</td></tr><tr><td>r.get(timeout=1)</td><td align="center">#获取任务执行结果，可以设置等待时间</td></tr><tr><td>r.result</td><td align="center">#任务执行结果.</td></tr><tr><td>r.state</td><td align="center">#PENDING,START,SUCCESS，任务当前的状态</td></tr><tr><td>r.status</td><td align="center">#PENDING,START,SUCCESS，任务当前的状态</td></tr><tr><td>r.successful</td><td align="center">#任务成功返回true</td></tr><tr><td>r.traceback</td><td align="center">#如果任务抛出了一个异常，你也可以获取原始的回溯信息</td></tr></tbody></table><h3 id="装饰器参数"><a href="#装饰器参数" class="headerlink" title="装饰器参数"></a>装饰器参数</h3><p><code>@celery.task()</code></p><ol><li><p>name：可以显示指定任务的名字；</p></li><li><p>serializer：指定序列化的方法；</p></li><li><p>bind：一个bool值，设置是否绑定一个task的实例，如果把绑定，task实例会作为参数传递到任务方法中，可以访问task实例的所有的属性，具体属性可参照 <code>celery--app--task.py</code> 中的Task类，通过<code>self.request.__dict__</code>打印相关属性；</p></li><li><p>base：指定任务的基类，可以定义一个类，继承celery.Task，利用重写或扩展的类接口技术制定需求，例如on_success方法，默认是没有返回值的，就是提供这个钩子让开发者自定义的；</p></li></ol><h3 id="调用任务"><a href="#调用任务" class="headerlink" title="调用任务"></a>调用任务</h3><p>任务被装饰器装饰后，通过task.delay()，task.apply_async()把任务加入到队列中，send_task()，可以发送未被注册的异步任务，即没有被celery.task装饰的任务</p><h3 id="apply-async的参数"><a href="#apply-async的参数" class="headerlink" title="apply_async的参数"></a>apply_async的参数</h3><table><thead><tr><th>Command</th><th align="left">Description</th></tr></thead><tbody><tr><td>countdown</td><td align="left">设置该任务等待一段时间再执行，单位为s；</td></tr><tr><td>eta</td><td align="left">定义任务的开始时间；eta=time.time()+10;</td></tr><tr><td>expires</td><td align="left">设置任务时间，任务在过期时间后还没有执行则被丢弃；</td></tr><tr><td>retry</td><td align="left">如果任务失败后,是否重试;使用true或false，默认为true</td></tr><tr><td>shadow</td><td align="left">重新指定任务的名字str，覆盖其在日志中使用的任务名称；</td></tr><tr><td>retry_policy</td><td align="left">重试策略，为一个字典，各个键值配置：<code>max_retries</code>-最大重试次数，默认为 3 次. <code>interval_start</code>-重试等待的时间间隔秒数，默认为 0 ，表示直接重试不等待. <code>interval_step</code>-每次重试让重试间隔增加的秒数，可以是数字或浮点数，默认为 0.2. <code>interval_max</code>-重试间隔最大的秒数,即通过 interval_step 增大到多少秒之后，就不在增加了，可以是数字或者浮点数，默认为 0.2 .</td></tr><tr><td>routing_key</td><td align="left">自定义路由键；</td></tr><tr><td>queue</td><td align="left">指定发送到哪个队列；</td></tr><tr><td>exchang</td><td align="left">指定发送到哪个交换机；</td></tr><tr><td>priority</td><td align="left">任务队列的优先级，0-9之间；</td></tr><tr><td>serializer</td><td align="left">任务序列化方法；通常不设置；</td></tr><tr><td>compression</td><td align="left">压缩方案，通常有zlib,bzip2</td></tr><tr><td>headers</td><td align="left">为任务添加额外的消息；</td></tr><tr><td>link</td><td align="left">任务成功执行后的回调方法；是一个signature对象；可以用作关联任务；</td></tr><tr><td>link_error</td><td align="left">任务失败后的回调方法，是一个signature对象；</td></tr></tbody></table><p>自定义发布者,交换机,路由键, 队列, 优先级,序列方案和压缩方法:</p><pre class="line-numbers language-python"><code class="language-python">task<span class="token punctuation">.</span>apply_async<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>     compression<span class="token operator">=</span><span class="token string">'zlib'</span><span class="token punctuation">,</span>    serialize<span class="token operator">=</span><span class="token string">'json'</span><span class="token punctuation">,</span>    queue<span class="token operator">=</span><span class="token string">'priority.high'</span><span class="token punctuation">,</span>    routing_key<span class="token operator">=</span><span class="token string">'web.add'</span><span class="token punctuation">,</span>    priority<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>    exchange<span class="token operator">=</span><span class="token string">'web_exchange'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 注意，celery4版本后，CELERY_BROKER_URL改为BROKER_URL</span>BROKER_URL <span class="token operator">=</span> <span class="token string">'amqp://username:passwd@host:port/虚拟主机名'</span><span class="token comment" spellcheck="true"># 指定结果的接受地址</span>CELERY_RESULT_BACKEND <span class="token operator">=</span> <span class="token string">'redis://username:passwd@host:port/db'</span><span class="token comment" spellcheck="true"># 指定任务序列化方式</span>CELERY_TASK_SERIALIZER <span class="token operator">=</span> <span class="token string">'msgpack'</span> <span class="token comment" spellcheck="true"># 指定结果序列化方式</span>CELERY_RESULT_SERIALIZER <span class="token operator">=</span> <span class="token string">'msgpack'</span><span class="token comment" spellcheck="true"># 任务过期时间,celery任务执行结果的超时时间</span>CELERY_TASK_RESULT_EXPIRES <span class="token operator">=</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">20</span>   <span class="token comment" spellcheck="true"># 指定任务接受的序列化类型.</span>CELERY_ACCEPT_CONTENT <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"msgpack"</span><span class="token punctuation">]</span>   <span class="token comment" spellcheck="true"># 任务发送完成是否需要确认，这一项对性能有一点影响     </span>CELERY_ACKS_LATE <span class="token operator">=</span> <span class="token boolean">True</span>  <span class="token comment" spellcheck="true"># 压缩方案选择，可以是zlib, bzip2，默认是发送没有压缩的数据</span>CELERY_MESSAGE_COMPRESSION <span class="token operator">=</span> <span class="token string">'zlib'</span> <span class="token comment" spellcheck="true"># 规定完成任务的时间</span>CELERYD_TASK_TIME_LIMIT <span class="token operator">=</span> <span class="token number">5</span>  <span class="token comment" spellcheck="true"># 在5s内完成任务，否则执行该任务的worker将被杀死，任务移交给父进程</span><span class="token comment" spellcheck="true"># celery worker的并发数，默认是服务器的内核数目,也是命令行-c参数指定的数目</span>CELERYD_CONCURRENCY <span class="token operator">=</span> <span class="token number">4</span> <span class="token comment" spellcheck="true"># celery worker 每次去rabbitmq预取任务的数量</span>CELERYD_PREFETCH_MULTIPLIER <span class="token operator">=</span> <span class="token number">4</span> <span class="token comment" spellcheck="true"># 每个worker执行了多少任务就会死掉，默认是无限的</span>CELERYD_MAX_TASKS_PER_CHILD <span class="token operator">=</span> <span class="token number">40</span> <span class="token comment" spellcheck="true"># 设置默认的队列名称，如果一个消息不符合其他的队列就会放在默认队列里面，如果什么都不设置的话，数据都会发送到默认的队列中</span>CELERY_DEFAULT_QUEUE <span class="token operator">=</span> <span class="token string">"default"</span> <span class="token comment" spellcheck="true"># 设置详细的队列</span>CELERY_QUEUES <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">"default"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true"># 这是上面指定的默认队列</span>        <span class="token string">"exchange"</span><span class="token punctuation">:</span> <span class="token string">"default"</span><span class="token punctuation">,</span>        <span class="token string">"exchange_type"</span><span class="token punctuation">:</span> <span class="token string">"direct"</span><span class="token punctuation">,</span>        <span class="token string">"routing_key"</span><span class="token punctuation">:</span> <span class="token string">"default"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token string">"topicqueue"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true"># 这是一个topic队列 凡是topictest开头的routing key都会被放到这个队列</span>        <span class="token string">"routing_key"</span><span class="token punctuation">:</span> <span class="token string">"topic.#"</span><span class="token punctuation">,</span>        <span class="token string">"exchange"</span><span class="token punctuation">:</span> <span class="token string">"topic_exchange"</span><span class="token punctuation">,</span>        <span class="token string">"exchange_type"</span><span class="token punctuation">:</span> <span class="token string">"topic"</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token string">"task_eeg"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true"># 设置扇形交换机</span>        <span class="token string">"exchange"</span><span class="token punctuation">:</span> <span class="token string">"tasks"</span><span class="token punctuation">,</span>        <span class="token string">"exchange_type"</span><span class="token punctuation">:</span> <span class="token string">"fanout"</span><span class="token punctuation">,</span>        <span class="token string">"binding_key"</span><span class="token punctuation">:</span> <span class="token string">"tasks"</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><code>celery worker -A auto_app.celery --loglevel=info</code> 启动Worker</p><h2 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h2><table><thead><tr><th>Command</th><th align="center">Description</th></tr></thead><tbody><tr><td>PENDING</td><td align="center">任务等待中</td></tr><tr><td>STARTED</td><td align="center">任务已开始</td></tr><tr><td>SUCCESS</td><td align="center">任务执行成功</td></tr><tr><td>FAILURE</td><td align="center">任务执行失败</td></tr><tr><td>RETRY</td><td align="center">任务将被重试</td></tr><tr><td>REVOKED</td><td align="center">任务取消</td></tr></tbody></table><p>通过 <code>r.get('status') == 'PENDING'</code> 获取状态</p><h2 id="设置任务调度器"><a href="#设置任务调度器" class="headerlink" title="设置任务调度器"></a>设置任务调度器</h2><p>配置文件:</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> datetime <span class="token keyword">import</span> timedelta<span class="token keyword">from</span> celery<span class="token punctuation">.</span>schedules <span class="token keyword">import</span> crontabConfig <span class="token operator">=</span> dict<span class="token punctuation">(</span>    CELERYBEAT_SCHEDULE<span class="token operator">=</span><span class="token punctuation">{</span>        <span class="token string">'ptask'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>            <span class="token string">'task'</span><span class="token punctuation">:</span> <span class="token string">'flask_app.celery_app.task.period_task'</span><span class="token punctuation">,</span>            <span class="token string">'schedule'</span><span class="token punctuation">:</span> timedelta<span class="token punctuation">(</span>seconds<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    CELERY_TIMEZONE<span class="token operator">=</span><span class="token string">'Asia/Shanghai'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置中 schedule 就是间隔执行的时间，这里可以用 datetime.timedelta 或者 crontab，如果定时任务涉及到 datetime 需要在配置中加入时区信息，否则默认是以 utc 为准。例如中国可以加上：</p><p><code>CELERY_TIMEZONE = 'Asia/Shanghai'</code></p><p>task的任务路径不能出错，在启动Worker进程的时候，可以看到task列表，这里指的的定时任务和其对应即可。</p><p>启动命令：</p><p>需要执行两个进程，一个是Worker进程，用来处理生成的任务，一个就是beat进程，启动任务调度器进程，定时生成任务</p><ul><li><code>celery beat -A auto_app.celery --loglevel=info</code></li><li><code>celery worker -A auto_app.celery --loglevel=info</code></li></ul><blockquote><p>任务调度会有需要动态添加任务，管理任务的情况，Django框架通过djang-celery实现在管理后台创建，删除，更新任务，它通过自定义调度类来实现，如果有类似的需求，可以参考源码实现</p></blockquote><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>Signature 对象，把任务通过签名的方法传递给其它任务，成为一个子任务</p><pre><code>In [6]: task = signature('flask_app.celery_app.task.add', args=(2, 2), countdown=5)In [7]: taskOut[7]: flask_app.celery_app.task.add(2, 2)In [8]: task.apply_async()Out[8]: &lt;AsyncResult: 0cbe319e-c3f6-48b9-b1e4-6a034711cf3a&gt;</code></pre><p><code>from celery import signature</code> 导入signature，可以看到，传递的第一个参数是已经存在的任务，也可以先把add导入，通过 <code>add.subtask((2, 2), countdown=5)</code>，或使用subtask的缩写s，add.s()。</p><p>子任务能支持偏函数的方式，利用它实现工作流。</p><p>支持原语实现工作流，原语表示由若干条指令组成的，用于完成一定功能的过程</p><p>1.chain - 调用链，任务的链式执行，前面的执行结果作为参数传递给后面，直到任务完成</p><p>chain 函数接受一个任务的列表，Celery 保证一个 chain 里的子任务会依次执行，在 AsynResult 上执行 get 会得到最后一个任务的返回值。和 link 功能类似，每一个任务执行结果会当作参数传入下一个任务，所以如果你不需要这种特性，采用 immutable signature 来取消。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">subtask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">from</span> celery <span class="token keyword">import</span> chain    part <span class="token operator">=</span> add<span class="token punctuation">.</span>s<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">|</span> add<span class="token punctuation">.</span>s<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">|</span> add<span class="token punctuation">.</span>s<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># or part = (add.s(1, 2), add.s(3), add.s(5))</span>    res <span class="token operator">=</span> chain<span class="token punctuation">(</span>part<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.group - 任务的并发执行</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">subtask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">from</span> celery <span class="token keyword">import</span> group    res <span class="token operator">=</span> group<span class="token punctuation">(</span><span class="token punctuation">[</span>add<span class="token punctuation">.</span>s<span class="token punctuation">(</span>i<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>group 函数也接受一个任务列表，这些任务会同时加入到任务队列中，且执行顺序没有任何保证。在 AsynResult 上执行 get 会得到一个包含了所有返回值的列表。<code>意参数必须是list对象</code></p><ol start="3"><li>chord - 带回调的 group</li></ol><p>chord 基本功能和 group 类似，只是有一个额外的回调函数。回调函数会在前面的任务全部结束时执行，其参数是一个包含了所有任务返回值的列表。在 AsynResult 上执行 get 会得到回调函数的返回值。</p><ol start="4"><li><p>map/starmap - 每个参数都作为任务的参数执行一遍</p></li><li><p>chunks - 将任务分块</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在启动Worker进程后，可以看到被装饰的任务已经被列出来了，这说明Celery有读取文件的机制(你可以在任务模块的最外层使用print测试)，被装饰的函数应该要在最外层，而且，创建实例后，再去修改配置，似乎没有生效（在我的测试中是这样的），其实这也符合逻辑，在进程被创建了，却又动态的去修改配置，与之对应的风险也很高。</p><p>celery是队列管理工具，真正的队列是Broker，更深入一点要了解RabbitMQ，AMQP协议，一般在celery上关注Worker，可以使用多个Worker，任务的生成使用定时器或触发的机制，任务本身就要由Python来编写，也包括对执行结果的处理。</p><p>任务生成，处理有了，还有队列的管理，默认使用名为celery的队列，可以配置队列，比如队列A，队列B，进入A队列的任务优先级要高，会被先处理。可以在启动worker进程的时候指明队列(通过-Q指定队)，这样这个Worker只会处理指定的队列。</p><p>后续扩展内容：celery信号，分析任务执行情况。Worker管理，监控和管理celery。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Middleware </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RESTFulAPI</title>
      <link href="/2018/10/22/Web/RESTFulAPI/"/>
      <url>/2018/10/22/Web/RESTFulAPI/</url>
      
        <content type="html"><![CDATA[<p>一种接口风格，使用一种通用的风格，在团队开发中，也便于沟通。</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>REST风格5个约束：客户端-服务端，无状态，缓存，统一接口，分层系统</p><ol><li><p>使用名词表示资源，动词通过HTTP方法来实现，比如删除资源使用DELETE方法。</p></li><li><p>关注请求头，比如请求头Accept要求返回application/xml，如果服务器只能放回json格式的，应该返回406错误。</p></li><li><p>使用正确的请求方法和状态码</p></li></ol><p>不能一味的使用POST和GET方法，HTTP方法表</p><table><thead><tr><th>Name</th><th align="left">Description</th></tr></thead><tbody><tr><td>OPTIONS</td><td align="left">用于获取资源支持的所以HTTP方法</td></tr><tr><td>HRAD</td><td align="left">用于只获取请求某个资源返回的头信息</td></tr><tr><td>GET</td><td align="left">用于从服务器获取某个资源的信息：1.完成请求后，返回状态码200 OK 2.完成请求后，需要返回被请求的资源详细信息</td></tr><tr><td>POST</td><td align="left">用于创建新资源：1.创建完成后，返回状态码201 Created 2.完成请求后，需要返回被创建的资源详细信息</td></tr><tr><td>PUT</td><td align="left">用于完整的替换资源或者创建指定身份的资源：1.如果是创建了资源，则返回201 Created 2.如果是替换了资源，则返回200 OK</td></tr><tr><td>PATCH</td><td align="left">用于局部更新资源：1.完成请求后，返回状态码200 OK 2.完成请求后，需要返回被修改的资源详细信息 3.完成请求后，需返回被修改的资源详细信息</td></tr><tr><td>DELETE</td><td align="left">用于删除某个资源，完成请求后返回状态码204 No Content</td></tr></tbody></table><p>对输出结果不在封装：通过状态码来判断请求，不应该把信息写在响应体中</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis在web开发中的运用</title>
      <link href="/2018/10/22/Web/Redis/"/>
      <url>/2018/10/22/Web/Redis/</url>
      
        <content type="html"><![CDATA[<p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。<br>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><a id="more"></a><h2 id="Database-Number"><a href="#Database-Number" class="headerlink" title="Database Number"></a>Database Number</h2><p>Redis 使用 DB number 实现类似关系型数据库中 schema 的功能。不同 DB number 表示的数据库是隔离的，但是目前只能使用数字来表示一个数据库，Ubuntu 默认的配置文件配置了16个数据库，DB number 是从0开始的，并且默认连接0号数据库。</p><p><code>redis-cli -n &lt;dbnumber&gt;</code> 连接指定数据库</p><h2 id="在docker-compose中使用Redis"><a href="#在docker-compose中使用Redis" class="headerlink" title="在docker-compose中使用Redis"></a>在docker-compose中使用Redis</h2><p>进入交互环境 <code>docker-compose exec redis redis-cli</code><br>清除缓存 <code>docker-compose exec redis redis-cli flushall</code></p><p>其它命令类似</p><h2 id="redis-和-Python"><a href="#redis-和-Python" class="headerlink" title="redis 和 Python"></a>redis 和 Python</h2><p>一般简单使用redis，只需要安装redis的Python包，如果是使用Redis作为数据库的话，可以使用 <code>walrus(海象)</code> 来处理，这样就可以设置模型，序列化返回数据，如果是一般的设置键值，查询的操作，使用原生的redis包即可，walrus是对redis包的扩展</p><h2 id="python-操作-redis"><a href="#python-操作-redis" class="headerlink" title="python 操作 redis"></a>python 操作 redis</h2><p>首先要创建连接<code>rdb = Database.from_url(REDIS_URL)</code></p><p>使用rdb提供的方法去设置key_value数据即可，一个很重要的概念就是数据类型，不同的数据类型要使用对应的方法来操作，要使用什么数据类型取决于业务。</p><p>无论是什么类型的数据，它必须有唯一key，而value就是数据类型</p><ol><li>string 最基本的数据类型，使用极其简单，调用set，get方法，也可以使用对对象进行序列化的方式来存储类似dict，list这样的数据结构</li><li>Hash 用来存储Python的dict类型数据</li><li>List 同样用来存储Python的list类型数据</li><li>set 存储集合</li><li>有序集合 zset，这种类型的数据在存储的时候需要制定排序值</li></ol><p>redis包的各个类型的数据结构都要使用对应的操作方法，根据我使用的经验来看，文档很少，官方文档直接指向Redis数据库的操作，要是看源码无法理解，可以直接看官方命令操作Redis数据库</p><h2 id="缓存命中率"><a href="#缓存命中率" class="headerlink" title="缓存命中率"></a>缓存命中率</h2><p>这是一个很重要的概念，如果你的系统不谈这个概念，那么说明你的访问量还是很小的。缓存服务作为Web架构的核心部分，充当着很重要的角色，那么什么是缓存命中率呢？这里就涉及到为什么会有没访问到缓存的情况，假如有一个接口A获取特定的数据，这个接口是被缓存的，无需通过数据库，但是你的数据总有更新的时候，如果需要更新数据了，就要重建缓存，从原始数据库取，就会出现没有访问到缓存的情况。</p><p>缓存粒度越大，缓存命中率就会随之降低。</p><h2 id="Redis查询当前库有多少个-key"><a href="#Redis查询当前库有多少个-key" class="headerlink" title="Redis查询当前库有多少个 key"></a>Redis查询当前库有多少个 key</h2><p>info可以看到所有库的key数量</p><p>dbsize则是当前库key的数量<br>keys *这种数据量小还可以，大的时候可以直接搞死生产环境</p><p>dbsize和keys *统计的key数可能是不一样的，如果没记错的话，keys *统计的是当前db有效的key，而dbsize统计的是所有未被销毁的key（有效和未被销毁是不一样的，具体可以了解redis的过期策略）</p><p>redis-cli -a hccx!0528  直接输入密码进入<br>redis-cli -a qweEX123</p><p>redis-cli -n 1   进去之后 auth  输入密码</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Web </tag>
            
            <tag> Python </tag>
            
            <tag> DataBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ 消息队列</title>
      <link href="/2018/10/22/Web/RabbitMQ/"/>
      <url>/2018/10/22/Web/RabbitMQ/</url>
      
        <content type="html"><![CDATA[<p>MQ全称为Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。应用程序通过读写出入队列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>需要了解一个协议：AMQP协议，协议的流程由消息发布者，交换机，队列，到消息订阅者。交换机做路由分发，将收到的消息根据路由规则分发给绑定的队列。</p><ol><li><p>消息：消息实际包含两部分内容，1是有效载荷，就是要传输的数据，数据类型可以是纯文本或JSON。2是标签，它包含交换机的名字和可选的主题(topic)标记等，AMQP仅仅描述了标签，而RabbitMQ决定了把这个消息发给哪个消费者。</p></li><li><p>发布者：也就是生产者，创建消息并设置标签</p></li><li><p>消费者：消费者连接到代理服务器上，接受有效载荷，消费者不需要消息中的标签</p></li></ol><p>消息投递失败会重发，保证消息正确取出和执行，AMQP模块包含了消息确认的概念，在收到消费者的确认回执前，消息代理不会将消息从队列中删除。</p><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机拿到消息后，将路由给队列，使用哪种路由算法是由交换机类型和被称作“绑定（queue_bind）”的规则决定的。</p><p>可配置的队列如下：</p><ol><li>直连交换机（direct exchange）</li></ol><p>根据消息携带的<code>路由键(routing key)</code>将消息投递给对应的队列。将一个队列绑定到某个交换机的同时赋予该绑定一个路由键，当一个携带者路由键为XXX的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为XXX的队列。直连交换机用来处理消息的单播路由。</p><ol start="2"><li>主题交换机（topic exchange）</li></ol><p>通过对消息的<code>路由键</code>和队列到交换机的<code>绑定模式</code>之间的匹配，将消息路由给一个或多个队列。主题交换机通常用来实现消息的<code>多播路由</code>。发送到主题交换机的消息的路由键，必须是一个由 “.” 分隔的词语列表，这些词语应该和对应的业务关联，词语的个数可以随意，但是不要超过255字节。绑定键支持通配符：“*” 用来表示一个单词；“#” 用来表示任意数量(零个或多个)单词。</p><ol start="3"><li>扇形交换机（fanout exchange）</li></ol><p>将消息路由给绑定到它身上的所有队列，且不理会绑定的路由键。用来做消息的<code>广播路由</code>。它允许你对单条消息做不同的处理，在开发中一个操作可能要多个连带工作，比如用户创建一篇新的日记，需要更新用户的创建日记数，清除相关缓存，给关注这个用户的其他用户推消息，日记进审核后台，日记进最新日记池等等。可以使用扇形交换机把一个消息分发给多个任务队列，执行不一样的工作。尤其是业务改变时，使用扇形交换机<code>直接为新的消费者添加声明</code>，并绑定进来就可以了，否则需要修改发送方的代码来添加接收方。所以，使用扇形交换机可以有效地<code>解耦</code>发送者和消费者。</p><ol start="4"><li>头交换机（headers exchange）</li></ol><p>允许匹配AMQP的头而非路由键，其实使用起来和直接交换机差不多，但是性能却差很多，一般用不到这种类型。</p><h2 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h2><p>通过创建新的虚拟主机，实现隔离，不同的虚拟主机直接完全隔离，拥有自己的队列，绑定和交换机。就像创建了一个新用户，服务A做订单的，链接对应的虚拟主机，服务B做消息推送的，链接对应的虚拟主机。默认是虚拟主机是 <code>/</code>，使用guest做默认用户和密码，通过命令创建新的虚拟主机：</p><pre class="line-numbers language-sh"><code class="language-sh">sudo rabbitmqctl add_user dongwm 123456sudo rabbitmqctl add_vhost web_developsudo rabbitmqctl set_permissions -p web_develop dongwm ".*" ".*" ".*"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>rabbitmqctl set_permissions</code> 是配置权限，三个对应的权限是：配置（队列和交换的创建和删除）、写（发布消息）、读（消费消息）的权限。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li>sudo rabbitmqctl list_vhosts</li><li>sudo rabbitmqctl list_queue -p web_develop</li><li>sudo rabbitmqctl list_users</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Middleware </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Note </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http-protocol 协议</title>
      <link href="/2018/10/22/Web/http-protocol/"/>
      <url>/2018/10/22/Web/http-protocol/</url>
      
        <content type="html"><![CDATA[<p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。</p><a id="more"></a><h2 id="http-action"><a href="#http-action" class="headerlink" title="http action"></a>http action</h2><p>HTTP协议中GET、POST和HEAD的介绍  2008-05-10 14:15 </p><table><thead><tr><th>Name</th><th align="center">Description</th></tr></thead><tbody><tr><td>GET</td><td align="center">请求指定的页面信息，并返回实体主体。</td></tr><tr><td>HEAD</td><td align="center">只请求页面的首部。</td></tr><tr><td>POST</td><td align="center">请求服务器接受所指定的文档作为对所标识的URI的新的从属实体。</td></tr><tr><td>PUT</td><td align="center">从客户端向服务器传送的数据取代指定的文档的内容。</td></tr><tr><td>DELETE</td><td align="center">请求服务器删除指定的页面。</td></tr><tr><td>OPTIONS</td><td align="center">允许客户端查看服务器的性能。</td></tr><tr><td>TRACE</td><td align="center">请求服务器在响应中的实体主体部分返回所得到的内容。</td></tr><tr><td>PATCH</td><td align="center">实体中包含一个表，表中说明与该URI所表示的原内容的区别。</td></tr><tr><td>MOVE</td><td align="center">请求服务器将指定的页面移至另一个网络地址。</td></tr><tr><td>COPY</td><td align="center">请求服务器将指定的页面拷贝至另一个网络地址。</td></tr><tr><td>LINK</td><td align="center">请求服务器建立链接关系。</td></tr><tr><td>UNLINK</td><td align="center">断开链接关系。</td></tr><tr><td>WRAPPED</td><td align="center">允许客户端发送经过封装的请求。</td></tr><tr><td>Extension-mothed</td><td align="center">在不改动协议的前提下，可增加另外的方法。</td></tr></tbody></table><h2 id="三次握手，四次挥手"><a href="#三次握手，四次挥手" class="headerlink" title="三次握手，四次挥手"></a>三次握手，四次挥手</h2><p>三次握手：A向B发起连接，B收到，回一个给A，A也收到，连接确定</p><ol><li>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</li><li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li><li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li></ol><p>完成三次握手，客户端与服务器开始传送数据。</p><p>建立连接是三次握手，释放连接是四次挥手（关闭连接）</p><ol><li>第一步，当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。</li><li>第二步，主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）。</li><li>第三步，主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段。</li><li>第四步，主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放。</li></ol><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><table><thead><tr><th>Name</th><th align="center">Description</th></tr></thead><tbody><tr><td>2xx</td><td align="center">成功</td></tr><tr><td>3xx</td><td align="center">重定向</td></tr><tr><td>4xx</td><td align="center">客户端问题</td></tr><tr><td>5xx</td><td align="center">服务端问题</td></tr></tbody></table><h2 id="get-和-post"><a href="#get-和-post" class="headerlink" title="get 和 post"></a>get 和 post</h2><ol><li>get是从服务器上获取数据，post是向服务器传送数据。</li><li>get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。</li><li>对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。</li><li>get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。</li><li>get安全性非常低，post安全性较高。但是执行效率却比Post方法好。 </li></ol><p>建议：<br>1、get方式的安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式；<br>2、在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式；</p><h2 id="302响应"><a href="#302响应" class="headerlink" title="302响应"></a>302响应</h2><p>当ajax请求响应302的时候，得到的响应会先由浏览器去请求302响应体中headers里面的location的地址，这个地址的响应才会是ajax请求得到的东西</p><p>就是接口302的时候，浏览器最终反馈是去请求重定向地址的响应</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Https SSL 证书</title>
      <link href="/2018/10/22/Web/ssl-credential/"/>
      <url>/2018/10/22/Web/ssl-credential/</url>
      
        <content type="html"><![CDATA[<p>使用https协议需要证书，可以自己创建，不足之处是不被认可，加密效果是一样的。本文记录一次ssh自生成的步骤，由于已经有免费且可以被认可的证书了，推荐使用该种方式</p><a id="more"></a><h1 id="https-ssl-证书"><a href="#https-ssl-证书" class="headerlink" title="https ssl 证书"></a>https ssl 证书</h1><p>使用https协议需要证书，可以自己创建，不足之处是不被认可，加密效果是一样的。以下内容截取自网络。</p><p>需要依次输入国家，地区，组织，email。最重要的是有一个common name，可以写你的名字或者域名。如果为了https申请，这个必须和域名吻合，否则会引发浏览器警报。生成的csr文件交给CA签名后形成服务端自己的证书。</p><p>创建自签名证书的步骤<br>注意：以下步骤仅用于配置内部使用或测试需要的SSL证书。<br>第1步：生成私钥使用openssl工具生成一个RSA私钥<br>$ openssl genrsa -des3 -out server.key 2048<br>说明：生成rsa私钥，des3算法，2048位强度，server.key是秘钥文件名。<br>注意：生成私钥，需要提供一个至少4位的密码。<br>第2步：生成CSR（证书签名请求）生成私钥之后，便可以创建csr文件了。<br>此时可以有两种选择。理想情况下，可以将证书发送给证书颁发机构（CA），CA验证过请求者的身份之后，会出具签名证书（很贵）。另外，如果只是内部或者测试需求，也可以使用OpenSSL实现自签名，具体操作如下：</p><p>$ openssl req -new -key server.key -out server.csr<br>说明：需要依次输入国家，地区，城市，组织，组织单位，Common Name和Email。其中Common Name，可以写自己的名字或者域名，如果要支持https，Common Name应该与域名保持一致，否则会引起浏览器警告。</p><p>Country Name (2 letter code) [AU]:CN<br>State or Province Name (full name) [Some-State]:Beijing<br>Locality Name (eg, city) []:Beijing<br>Organization Name (eg, company) [Internet Widgits Pty Ltd]:joyios<br>Organizational Unit Name (eg, section) []:info technology<br>Common Name (e.g. server FQDN or YOUR name) []:demo.joyios.com<br>Email Address []:<a href="mailto:liufan@joyios.com" target="_blank" rel="noopener">liufan@joyios.com</a></p><p>第3步：删除私钥中的密码在第1步创建私钥的过程中，由于必须要指定一个密码。而这个密码会带来一个副作用，那就是在每次Apache启动Web服务器时，都会要求输入密码，这显然非常不方便。要删除私钥中的密码，操作如下：</p><p>cp server.key server.key.org<br>openssl rsa -in server.key.org -out server.key</p><p>第4步：生成自签名证书如果你不想花钱让CA签名，或者只是测试SSL的具体实现。那么，现在便可以着手生成一个自签名的证书了。</p><p>$ openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt<br>说明：crt上有证书持有人的信息，持有人的公钥，以及签署者的签名等信息。当用户安装了证书之后，便意味着信任了这份证书，同时拥有了其中的公钥。证书上会说明用途，例如服务器认证，客户端认证，或者签署其他证书。当系统收到一份新的证书的时候，证书会说明，是由谁签署的。如果这个签署者确实可以签署其他证书，并且收到证书上的签名和签署者的公钥可以对上的时候，系统就自动信任新的证书。<br>第5步：安装私钥和证书将私钥和证书文件复制到Apache的配置目录下即可，在Mac 10.10系统中，复制到/etc/apache2/目录中即可。<br>需要注意的是，在使用自签名证书时，浏览器会提示证书不受信任，如果你是对外网站使用，建议还是去CA机构申请可信的SSL证书，现在证书也很便宜，沃通CA超快SSL Pre才488元/年。</p><p>一般情况下，如果能找到可用的证书，就可以直接使用，只不过会因证书的某些信息不正确或与部署证书的主机不匹配而导致浏览器提示证书无效，但这并不影响使用。<br>需要手工生成证书的情况有：<br>找不到可用的证书<br>需要配置双向SSL，但缺少客户端证书<br>需要对证书作特别的定制<br>首先，无论是在Linux下还是在Windows下的Cygwin中，进行下面的操作前都须确认已安装OpenSSL软件包。</p><ol><li>创建根证书密钥文件(自己做CA)root.key：<br>openssl genrsa -des3 -out root.key<br>输出内容为：<br>[lenin@archer ~]$ openssl genrsa -des3 -out root.key<br>Generating RSA private key, 512 bit long modulus<br>……………..++++++++++++<br>..++++++++++++<br>e is 65537 (0×10001)<br>Enter pass phrase for root.key: ← 输入一个新密码<br>Verifying – Enter pass phrase for root.key: ← 重新输入一遍密码</li><li>创建根证书的申请文件root.csr：<br>openssl req -new -key root.key -out root.csr<br>输出内容为：<br>[lenin@archer ~]$ openssl req -new -key root.key -out root.csr<br>Enter pass phrase for root.key: ← 输入前面创建的密码<br>You are about to be asked to enter information that will be incorporated<br>into your certificate request.<br>What you are about to enter is what is called a Distinguished Name or a DN.<br>There are quite a few fields but you can leave some blank<br>For some fields there will be a default value,<br>If you enter ‘.’, the field will be left blank.<br>—–<br>Country Name (2 letter code) [AU]:CN ← 国家代号，中国输入CN<br>State or Province Name (full name) [Some-State]:BeiJing ← 省的全名，拼音<br>Locality Name (eg, city) []:BeiJing ← 市的全名，拼音<br>Organization Name (eg, company) [Internet Widgits Pty Ltd]:MyCompany Corp. ← 公司英文名<br>Organizational Unit Name (eg, section) []: ← 可以不输入<br>Common Name (eg, YOUR name) []: ← 此时不输入<br>Email Address []:<a href="mailto:admin@mycompany.com" target="_blank" rel="noopener">admin@mycompany.com</a> ← 电子邮箱，可随意填<br>Please enter the following ‘extra’ attributes<br>to be sent with your certificate request<br>A challenge password []: ← 可以不输入<br>An optional company name []: ← 可以不输入</li><li>创建一个自当前日期起为期十年的根证书root.crt：<br>openssl x509 -req -days 3650 -sha1 -extensions v3_ca -signkey root.key -in root.req -out root.crt<br>输出内容为：<br>[lenin@archer ~]$ openssl x509 -req -days 3650 -sha1 -extensions v3_ca -signkey root.key -in root.csr -out root.crt<br>Signature ok<br>subject=/C=CN/ST=BeiJing/L=BeiJing/O=MyCompany Corp./emailAddress=admin@mycompany.com<br>Getting Private key<br>Enter pass phrase for root.key: ← 输入前面创建的密码</li><li>创建服务器证书密钥server.key：<br>openssl genrsa –des3 -out server.key 2048<br>输出内容为：<br>[lenin@archer ~]$ openssl genrsa -out server.key 2048<br>Generating RSA private key, 2048 bit long modulus<br>….+++<br>…………………………………………..+++<br>e is 65537 (0×10001)<br>运行时会提示输入密码,此密码用于加密key文件(参数des3便是指加密算法,当然也可以选用其他你认为安全的算法.),以后每当需读取此文件(通过openssl提供的命令或API)都需输入口令.如果觉得不方便,也可以去除这个口令,但一定要采取其他的保护措施!<br>去除key文件口令的命令:<br>openssl rsa -in server.key -out server.key</li><li>创建服务器证书的申请文件server.csr：<br>openssl req -new -key server.key -out server.csr<br>输出内容为：<br>[lenin@archer ~]$ openssl req -new -key server.key -out server.req<br>You are about to be asked to enter information that will be incorporated<br>into your certificate request.<br>What you are about to enter is what is called a Distinguished Name or a DN.<br>There are quite a few fields but you can leave some blank<br>For some fields there will be a default value,<br>If you enter ‘.’, the field will be left blank.<br>—–<br>Country Name (2 letter code) [AU]:CN ← 国家名称，中国输入CN<br>State or Province Name (full name) [Some-State]:BeiJing ← 省名，拼音<br>Locality Name (eg, city) []:BeiJing ← 市名，拼音<br>Organization Name (eg, company) [Internet Widgits Pty Ltd]:MyCompany Corp. ← 公司英文名<br>Organizational Unit Name (eg, section) []: ← 可以不输入<br>Common Name (eg, YOUR name) []:<a href="http://www.mycompany.com" target="_blank" rel="noopener">www.mycompany.com</a> ← 服务器主机名，若填写不正确，浏览器会报告证书无效，但并不影响使用<br>Email Address []:<a href="mailto:admin@mycompany.com" target="_blank" rel="noopener">admin@mycompany.com</a> ← 电子邮箱，可随便填<br>Please enter the following ‘extra’ attributes<br>to be sent with your certificate request<br>A challenge password []: ← 可以不输入<br>An optional company name []: ← 可以不输入</li><li>创建自当前日期起有效期为期两年的服务器证书server.crt：<br>openssl x509 -req -days 730 -sha1 -extensions v3_req -CA root.crt -CAkey root.key -CAserial root.srl -CAcreateserial -in server.csr -out server.crt<br>输出内容为：<br>[lenin@archer ~]$ openssl x509 -req -days 730 -sha1 -extensions v3_req -CA root.crt -CAkey root.key -CAcreateserial -in server.csr -out server.crt<br>Signature ok<br>subject=/C=CN/ST=BeiJing/L=BeiJing/O=MyCompany Corp./CN=<a href="http://www.mycompany.com/emailAddress=admin@mycompany.com" target="_blank" rel="noopener">www.mycompany.com/emailAddress=admin@mycompany.com</a><br>Getting CA Private Key<br>Enter pass phrase for root.key: ← 输入前面创建的密码</li><li>创建客户端证书密钥文件client.key：<br>openssl genrsa -des3 -out client.key 2048<br>输出内容为：<br>[lenin@archer ~]$ openssl genrsa -des3 -out client.key 2048<br>Generating RSA private key, 2048 bit long modulus<br>……………………………………………………………………………..+++<br>……………………………………………………………………………………………………….+++<br>e is 65537 (0×10001)<br>Enter pass phrase for client.key: ← 输入一个新密码<br>Verifying – Enter pass phrase for client.key: ← 重新输入一遍密码</li><li>创建客户端证书的申请文件client.csr：<br>openssl req -new -key client.key -out client.csr<br>输出内容为：<br>[lenin@archer ~]$ openssl req -new -key client.key -out client.csr<br>Enter pass phrase for client.key: ← 输入上一步中创建的密码<br>You are about to be asked to enter information that will be incorporated<br>into your certificate request.<br>What you are about to enter is what is called a Distinguished Name or a DN.<br>There are quite a few fields but you can leave some blank<br>For some fields there will be a default value,<br>If you enter ‘.’, the field will be left blank.<br>—–<br>Country Name (2 letter code) [AU]:CN ← 国家名称，中国输入CN<br>State or Province Name (full name) [Some-State]:BeiJing ← 省名称，拼音<br>Locality Name (eg, city) []:BeiJing ← 市名称，拼音<br>Organization Name (eg, company) [Internet Widgits Pty Ltd]:MyCompany Corp. ← 公司英文名<br>Organizational Unit Name (eg, section) []: ← 可以不填<br>Common Name (eg, YOUR name) []:Lenin ← 自己的英文名，可以随便填<br>Email Address []:<a href="mailto:admin@mycompany.com" target="_blank" rel="noopener">admin@mycompany.com</a> ← 电子邮箱，可以随便填<br>Please enter the following ‘extra’ attributes<br>to be sent with your certificate request<br>A challenge password []: ← 可以不填<br>An optional company name []: ← 可以不填</li><li>创建一个自当前日期起有效期为两年的客户端证书client.crt：<br>openssl x509 -req -days 730 -sha1 -extensions v3_req -CA root.crt -CAkey root.key -CAserial root.srl -CAcreateserial -in client.csr -out client.crt<br>输出内容为：<br>[lenin@archer ~]$ openssl x509 -req -days 730 -sha1 -extensions v3_req -CA root.crt -CAkey root.key -CAcreateserial -in client.csr -out client.crt<br>Signature ok<br>subject=/C=CN/ST=BeiJing/L=BeiJing/O=MyCompany Corp./CN=<a href="http://www.mycompany.com/emailAddress=admin@mycompany.com" target="_blank" rel="noopener">www.mycompany.com/emailAddress=admin@mycompany.com</a><br>Getting CA Private Key<br>Enter pass phrase for root.key: ← 输入上面创建的密码</li><li>将客户端证书文件client.crt和客户端证书密钥文件client.key合并成客户端证书安装包client.pfx：<br>openssl pkcs12 -export -in client.crt -inkey client.key -out client.pfx<br>输出内容为：<br>[lenin@archer ~]$ openssl pkcs12 -export -in client.crt -inkey client.key -out client.pfx<br>Enter pass phrase for client.key: ← 输入上面创建的密码<br>Enter Export Password: ← 输入一个新的密码，用作客户端证书的保护密码，在客户端安装证书时需要输入此密码<br>Verifying – Enter Export Password: ← 确认密码</li><li>保存生成的文件备用，其中server.crt和server.key是配置单向SSL时需要使用的证书文件，client.crt是配置双向SSL时需要使用的证书文件，client.pfx是配置双向SSL时需要客户端安装的证书文件<br> .crt文件和.key可以合到一个文件里面，把2个文件合成了一个.pem文件（直接拷贝过去就行了）<br>参考：<a href="http://sinolog.it/?p=1460" target="_blank" rel="noopener">http://sinolog.it/?p=1460</a><br>//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////<br>//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////<br><a href="http://blog.sina.com.cn/s/blog_4fd50c390101891c.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_4fd50c390101891c.html</a><br>x509证书一般会用到三类文，key，csr，crt。<br>Key是私用密钥openssl格，通常是rsa算法。<br>Csr是证书请求文件，用于申请证书。在制作csr文件的时，必须使用自己的私钥来签署申，还可以设定一个密钥。<br>crt是CA认证后的证书文，（windows下面的，其实是crt），签署人用自己的key给你签署的凭证。 </li></ol><p>1.key的生成<br>opensslgenrsa -des3 -out server.key 2048<br>这样是生成rsa私钥，des3算法，openssl格式，2048位强度。server.key是密钥文件名。为了生成这样的密钥，需要一个至少四位的密码。可以通过以下方法生成没有密码的key:<br>opensslrsa -in server.key -out server.key </p><p>server.key就是没有密码的版本了。 </p><p>2.生成CA的crt<br>opensslreq -new -x509 -key server.key -out ca.crt -days3650<br>生成的ca.crt文件是用来签署下面的server.csr文件。 </p><p>3.csr的生成方法<br>opensslreq -new -key server.key -outserver.csr<br>需要依次输入国家，地区，组织，email。最重要的是有一个common name，可以写你的名字或者域名。如果为了https申请，这个必须和域名吻合，否则会引发浏览器警报。生成的csr文件交给CA签名后形成服务端自己的证书。 </p><p>4.crt生成方法<br>CSR文件必须有CA的签名才可形成证书，可将此文件发送到verisign等地方由它验证，要交一大笔钱，何不自己做CA呢。<br>opensslx509 -req -days 3650 -in server.csr -CA ca.crt -CAkey server.key-CAcreateserial -out server.crt<br>输入key的密钥后，完成证书生成。-CA选项指明用于被签名的csr证书，-CAkey选项指明用于签名的密钥，-CAserial指明序列号文件，而-CAcreateserial指明文件不存在时自动生成。<br>最后生成了私用密钥：server.key和自己认证的SSL证书：server.crt<br>证书合并：<br>catserver.key server.crt &gt; server.pem</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Web </tag>
            
            <tag> Http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ORID 焦点呈现法（Focused Conversation Method）</title>
      <link href="/2018/10/22/blog/ORID/"/>
      <url>/2018/10/22/blog/ORID/</url>
      
        <content type="html"><![CDATA[<p>ORID，即焦点呈现法（Focused Conversation Method），是一种通过催化师（主持人、引导讲师）引导来开展的结构化汇谈（会议、交谈）形式。该方法常被用作对事实进行分析和感觉某一工具和方法（O实践-客观事实、R感受-客观反射、I意义-事实分析，D行动-基于事实的下一步行动）。</p><a id="more"></a><h2 id="ORID"><a href="#ORID" class="headerlink" title="ORID"></a>ORID</h2><p>Objective 你对今天学的记得什么？</p><p>Reflective 一句话形容今天的情绪（今天的高峰、低峰）。</p><p>Interpretive 今天你学到了啥？重要的领悟是什么？</p><p>Decisional 一句话形容今天的工作，明天要继续哪些工作。</p><p>Objective：The Objective Level of Thinking：这个方法就是通过引导的方法，对团队成员都着眼于客观事实，引导师让大家先说看到了什么、听到了什么，一方面是比较容易让大家回答，参与，同时让大家从事实入手看问题。</p><p>Reflective：The Reflective Level of Thinking：引导师会问大家对此事情的感受是怎么的？比较适合让人们打开感性的一面？多用来描述心情，如“喜、怒、哀、乐”等。</p><p>Interpretive：The Interpretive Level of Thinking ：思考这件事带给我们的思考、意义、启发是什么？</p><p>Decisional：The Decisional Level of Thinking：给我们带来的行动是什么？未来我要怎么做？</p><p>焦点表述法（ORID）可以用于很多的场合，例如课堂提问学员引导，职场上级与下级的沟通，以及日常的写作都可以应用。</p><p>举例：在某件事中，你看到印象最深刻的一幕是什么？（O）你的第一感觉是什么？(R)对这件事，你是怎么想的？(I)能不能把这个经验用在未来的工作中？(D)</p><p>如：我今天上班途中突然遇到一条狗（O），我很害怕（R），为什么这里会有一条狗？因为这条路太偏僻(I)，明天我要选择其它人多的路(D)</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Causerie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Causerie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Docker快速构建开发环境</title>
      <link href="/2018/10/22/blog/docker-dev/"/>
      <url>/2018/10/22/blog/docker-dev/</url>
      
        <content type="html"><![CDATA[<p>Docker是很不错的容器技术，利用Docker可用快速构建一个开发环境，这样的好处在于一台新的电脑，只要安装了Docker软件，搭建环境就是几个命令的事，这样整个开发团队都会在同样的环境下进行，而且部署的时候，运维的同学只需要针对安全性做一些调整即可上线。</p><a id="more"></a><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>以Python语言为例，一个小团队的技术栈差不多会用到以下的东西：</p><ol><li>Python环境，包括各种需要的包</li><li>数据库，包括MySQL、MongoDB等</li><li>缓存服务，使用Redis等</li><li>任务队列，使用celery，RabbitMQ</li><li>Http服务器，Nginx</li><li>WSGI服务器，gunicorn，uwsgi</li></ol><h2 id="基于Dockerfile构建Python环境"><a href="#基于Dockerfile构建Python环境" class="headerlink" title="基于Dockerfile构建Python环境"></a>基于Dockerfile构建Python环境</h2><p>对于不需要定制的服务，直接使用官方的镜像即可，而需要定制的列如Python，利用Dockerfile来构建，主要是安装运行环境，已经常用的软件，因为该运行环境可能后期还需要做调整。</p><pre class="line-numbers language-Dockerfile"><code class="language-Dockerfile">FROM python:3.7LABEL author="liuzhi<1441765847.com>"# 换源，Python镜像基于Debian，使用阿里的Debian源RUN rm /etc/apt/sources.listCOPY sources.list /etc/apt/sources.list# 运行命令，安装常用软件RUN apt-get update \    # 修改时区    && ln -sf /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime \    # && apt-get install -y apt-utils \    # && apt-get install -y wget \    && apt-get install -y zsh \    && chsh -s /bin/zsh root \    && apt-get install -y curl \    && apt-get install -y git \    && apt-get install -y vim # 安装zsh的扩展RUN sh -c "$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)"  || trueENV FLASK_ENV devENV APP_DIR /codeWORKDIR /code/EXPOSE 5000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意事项：</p><ul><li><p>记得在同级目录下装备源文件 <code>sources.list</code></p></li><li><p>有时候会提示需要安装 <code>apt-utils</code>，不过我这里是基于Debian的，这东西还装不上，没有apt-utils，安装不了第三方包，wget安装失败了，可用进入容器自行安装wget</p></li><li><p>RUN命令中通过 <code>&amp;&amp;</code> 连接命令，因为在Docker中，每一个指令都会构建一层，因此尽量将命令都放在一个RUN指令中，用 &amp;&amp; 来串联。还有命令后面的 <code>\</code> 符最后就不需要写了，不然和下面的命令连起来了，如果你使用Dockerfile静态语法检查工具，有错误提示的（xcode安装插件即可编写Dockerfile，错误的地方会有提示）</p></li><li><p>这里还安装了zsh的扩展，使用了 <code>||</code> ，不用直接安装镜像创建会失败，我猜测可能是这个命令后面没接上，不用 <code>||</code> 可以看到安装信息是成功了的，但是容器创建会失败，太具体的情况不知道了，安装了zsh，启动容器的时候记得通过 <code>/bin/zsh</code> 进入</p></li></ul><p>这里使用了官方的Python镜像，体积有点大，好处是装软件一般不会出问题了，作为开发用就不在精简体积上花时间了。</p><h2 id="使用Docker-composes"><a href="#使用Docker-composes" class="headerlink" title="使用Docker-composes"></a>使用Docker-composes</h2><p>安装Docker-composes，不推荐使用Python来安装，可能因为Python版本或包依赖问题导致各种问题。</p><blockquote><p>sudo curl -L <a href="https://github.com/docker/compose/releases/download/1.22.0/docker-compose-uname" target="_blank" rel="noopener">https://github.com/docker/compose/releases/download/1.22.0/docker-compose-uname</a> -s -u name -m -o /usr/local/bin/docker-compose</p><p>sudo chmod +x /usr/local/bin/docker-compose</p><footer><strong>使用GitHub源</strong></footer></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Technology技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
            <tag> Technology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人生的意义</title>
      <link href="/2018/10/22/blog/rensheng-blog/"/>
      <url>/2018/10/22/blog/rensheng-blog/</url>
      
        <content type="html"><![CDATA[<p>胡适说，人生应该有梦，否则人生不是太不丰富吗？</p><p>现在你们都有理想，但出了社会便可能不同了。那时各奔前程，各种打击，各种现实的考虑，都可能使得你把崇高的理想收敛起来。这就是现实在考验我们的道德力，我们的理想性，我们对真对善对美的追求是否迫切。在世界上每一个角落都是如此的。我们是否能撑得住，就在这个关头。现在是考验我们的时候了。</p><a id="more"></a><h2 id="人生的意义"><a href="#人生的意义" class="headerlink" title="人生的意义"></a>人生的意义</h2><p>今天是一九六六年四月八日，我今天要跟大家谈的问题是「人生的意义」。我为什么要选这个问题呢？这有两个理由：</p><p>第一个理由是我个人是非常喜欢思考的。从少年时代到青年时代，从青年时代到中年时代，都是不停的想问题，对人生的辛酸波折也经历过一些。因此把我所想的人生的意义是什么，人生的道路是什么陈示出来，给各位参考；我只说参考，但我没有说各位一定要采取我的人生观和人生的意义。人生的意义是各人自己的。我只是把我的提供各位参考而已。</p><p>第二个理由是：就我观察所及，我们正处在一个转型的社会，我们的文化在蜕变中，而且这个世界是这样的扰攘不安，差不多的人实实在在说来心灵都失落了：失落在街头，失落在弹子房，失落在电影院，失落在会客室里，种种的失落。他们的心灵是不凝炼，不坚强的。</p><p>比如说，有些体育家，运动家，他们的个子是蛮大的，打人蛮行的，但他的心灵很脆弱。譬如说，他们稍微把一句话说错了，就怕这个人不喜欢吧，怕那个人被得罪了。这充分表现出心灵的脆弱。</p><p>假如我们具有强健的身体而心灵如此脆弱，这是很可悲的，我们只有做别人的工具。这是时代的厄运。为了免于这一厄运，所以我愿意把我自己的想法提供出来。</p><p>这就是今天讨论这个问题的基础，并以此为范围。</p><p>人生是有很多层次的，此处我只能简略的说。</p><p>首先要说的是物理层。</p><p>任何人无法不受物理定律的支配。如果有人活得不耐烦的话，他从楼上跳下来，非伤即死，毫无问题的。那就是受物理定律的支配。人是有限的动物，虽然有时觉得自己是无限的，那大概是太狂妄了。这层是用不着多说了。</p><p>第二层是生物逻辑层。</p><p>人不仅是物而且是生物，是有生命的。有生命则不能不受生物法则的支配，如呼吸，心脏的搏动，肌肉的收缩都是受生理法则的支配，没有人能例外。我们就是这种构造的。可是，在这层有一种特别的现象，这在别的生物里是不发达的──即使不是没有的话。这就是一个生物文化的界域。</p><p>我们是一种生物，有许多是需要必须满足的，如吃饭喝水，到一定的岁数要结婚，所谓「窈窕淑女，君子好逑，求之不得，辗转反侧」，那么难过，这都属生物逻辑层。固然，别的生物也都要吃东西，寻配偶。但它们与人有大不同之处：它们是赤裸裸的，没有文化，人则不同，吃东西要讲礼貌，有不同的分殊，不同的形式。就穿衣而论，我不相信任何一位小姐，本来就像孔雀般美丽，而是藉各种物质的工具来补足其美。人为了御寒有棉、皮革、尼龙、奥龙、达克龙。这都是生物文化层的东西。我们满足人类之生物文化。但人类的生存并非发展到此结束的。</p><p>人是有「意识」的。这最关重要。别的生物大概没有，至少到现在为止大概尚末发展到这地步。这在生物发展的过程中是一个很重要的关键。别的生物大概不知道自身的生死间题，人则知道，晓得有生就有死。彭祖长寿，但到了八百岁时依然要死。而且人都怕死，但上帝绝不因此多留你一天，打针吃药于事无补。由于我们有死的意识，便产生许多神话，许多礼仪。</p><p>就这样，慢慢的发展，扩充我们的界域，由单纯的物理层，进为生物逻辑层，再由此发展到生物文化界，继续发展。</p><p>然后人类有真善美的意识，有理想、有道德，这也就是价值层。</p><p>这层就是人之所以为人的层级，生物逻辑层则是凡高等生物皆有。生物文化界别的高等动物虽可分享一部份，但人最多。唯最高层是人所独有。</p><p>我们讲道德，追求理想，要创造理想杜会，从柏拉图的理想国，托马斯穆尔的乌托邦，以至我们追求真善美等等，这都是超生物逻辑的东西，借用黑格尔的话说是「精神的创造」。我想大概说来只有人类有精神的创造。这层是人所特有的。当然，人只是太空中的一种生物而已，将来星际交通发达了，在别的星球中可能有超人类存在。超人类的智慧是可能比人类发达得多。</p><p>  现在我已把我要讨论的基本架构说出。依此，我们讨论人生的意义何在，人生的道路何在。人活在这世界上，首先必须要能生存。可是不同的文化价值，对这种需要的满足方式是不同的。而且有的文化价值取向不把重点放在这上面。</p><p>例如古代圣贤说：君子谋道不谋食。当我少年时，同学间常以为问舍求田的人，是没有大志的。因为，当时大家只谈理想，只谈学问。万一有人谈钱，大家一定笑他的。这是当时一般知识分子的价值观念。这也表示文化价值的重点之所在。又如古时有人说「饿死事小，失节事大」；「饿死首阳之山，义不食周粟」。这是认为生物需要不及道德价值之重要。尤其宋明理学家就是如此的。他们的想法高得很，但也空得很的。他们从不屑谈这些经济事务。但是，我们现在重视这个了。</p><p>第二次世界大战以后，亚非地区的人众抬头了。十九世纪末叶以迄二次世界大战以前约八十年间非洲地区是白种人的殖民地，有色人种受白种人的轻视，尤其认为有色人种无论是体力、道德或天然的脑力都不如白人。可是，曾几何时，现在非洲人受白人之哄抬。这个变化真非始料所及！亚非地区的人特别多，经济落后，但是我并非认为经济落后是罪恶。</p><p>正好相反，不开发，不开马路，漫步森林之中，享受天然之乐，岂不更好？现在，亚非地区受重视，却经济落后、知识水平低、贫困、饥荒，野心份子可用他们来扰乱世界和平。于是乎，自由国家要开发落后地区了。现在世界，无论何地均拼命经济发展，刻意经营。这些努力无非在生物文化层。</p><p>我并不是说这一层是可以忽略的。在实际上，我们不可能不经此层而跳至最上层。因为，如果腾空而起的话，高等精神文化的发展和道德实践便失去支持。宋明理学的大病在此。他们的毛病在当时并不严重。因为吃饭问题不大，如朱熹、程颐、程颢等人在这方面都不成问题，顶多是有无肉吃的问题而已。因为他们有人供养，他们是士大夫阶层。据贵校金耀基先生说，我们已经不是士大夫了。我听后有股淡淡的哀愁！</p><p>但是，落花流水春去也！又有什么办法呢？</p><p>以前我是会做秋梦的，以为身为士大夫，四民之首，好神气﹗但现在不是了，一个月的收入不及华怡保的百分之一，因此你们可以说：殷海光，你的梦可以醒了！这样我们便要面对现实了。当时朱熹可不如此，好惬意哦！到山上开家书院，自任山长。But now all gone！现在时代不同了，生活的需要多了。</p><p>我们的传统文化价值取向把重点放在名教、仪制、伦序、德目的维系这一层次上，而不太注重生物文化层。于是精神文化和现实生活脱了节。到头来，我们的文化发展，像一座高楼似的，上一层的人在吹笙箫，底下一层劳动终日难得一饱，于是空了。整个文化建构都发生问题。这一历史的教训是值得今日的我们留意的。</p><p>我举一个现实的例子。经济落后的地区要人来协助。肚子被人抓住了还有什么自由哟！我们的肚子被人控制，很多志气便无法伸张，人的尊严便很难维持。有钱才能扬眉，才能吐气。否则高尚的志趣，卓越的理想，都要收起来。人到屋檐下不能不低头。所以我们必须充实生物文化层才能谈上一层的价值。现在发展外销，致力经济起飞，在这种意义下是对的。</p><p>然而，我们现在的问题是：人生的意义，人生的目的，人生的价值，人生的道路是否就停在这一层呢？你如何把你与其它高等动物分别开？丰衣足食后是否安心在此停顿？人之所以为人是否这就够了呢？</p><p>这是要我们大学生，知识分子想的大问题。今天我们都受了时代沉闷空气的压力，担心出路，许多人不爱想这类问题，视之为高调。我个人的境遇困难，但从未停止想这类问题，尤其在困难的时候更要想！前面所说的生物逻辑的条件没有满足时，固然到不了最上层。但满足之后，高尚的理想和价值都可不要吗？希腊出那么多大哲学家、科学家、思想家，为后世之基础，我们多么向往啊！因为他们的精神生活是如此丰富。显然得很，要人生完美，必须透过生物文化层再往上升。生物文化层满足了，我们还要真善美、理想、道德，这样人生的道路才算完成。</p><p>这里又生一个问题：假设我们已有很好的文化遗产，如中国的。就中国来说，我认为孟轲有气象，他可说是一个标准的道德英雄；又如韩非子，思想那么严格，观察那么锐利。如果他生在现代的话，就可能是一个逻辑家了。</p><p>我们现在进一步提出一个问题：如果我们面临一个两难式，即是：如果我们要满足衣食等生物逻辑，那么势必牺牲道德或理想；如果我们要维持道德或理想，那末势必困难以满足衣食等生物逻辑的要求而难以生存。处此困境之下，我们怎样作决定？</p><p>照现在的趋势，一般人在有意无意之间，碰到求生与顾及道德不能两全的情形，就为了求生而牺牲道德原则。有些人更因满足自己的利益而牺牲道德，陷害别人。所以，道德就「江河日下」了。人吃粗一点尚可活下去。人群没有道德来维系，势必难免为「率兽食人」的世界。如何得了！在这样的情形之下，我们怎样处理？我以为孟夫子所倡导的「义」是救药。他要人舍生而取义。这当然是一个极限原则。我们并不是说人必须动不动就牺牲生命来保全道德原则和崇高理想。</p><p>我的意思是说：</p><p>第一，我们万不可在自己的生存并末受威胁时为了换取现实利益而牺牲道德原则。</p><p>第二，在我们的生活勉强可过时万不可因要得到较佳报酬而牺牲他人。</p><p>第三，当我们因生活困难而被迫不得不放弃若干作人的原则时，我们必须尽可能作「道德的抗战」，把道德的领土放弃的愈少愈好；而且要存心待机「收复道德的失地」。</p><p>复次，我们有我们的好恶。</p><p>如果经济贫困了，我们的好恶是否就要放弃？是否就不能讲？</p><p>还有尊严问题，如人的经济不能满足，尊严是否可以不顾呢？诸如此类的问题，作为一个人，真值得想一想。</p><p>在各位现在这种年龄大家都有梦。胡适说，人生应该有梦，否则人生不是太不丰富吗？</p><p>现在你们都有理想，但出了社会便可能不同了。那时各奔前程，各种打击，各种现实的考虑，都可能使得你把崇高的理想收敛起来。这就是现实在考验我们的道德力，我们的理想性，我们对真对善对美的追求是否迫切。在世界上每一个角落都是如此的。我们是否能撑得住，就在这个关头。现在是考验我们的时候了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Causerie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Causerie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么那么多成功的人，他们每天只睡几个小时？</title>
      <link href="/2018/10/22/blog/sleep-blog/"/>
      <url>/2018/10/22/blog/sleep-blog/</url>
      
        <content type="html"><![CDATA[<p>这是个值得思考的问题</p><a id="more"></a><h1 id="为什么那么多成功的人，他们每天只睡几个小时？"><a href="#为什么那么多成功的人，他们每天只睡几个小时？" class="headerlink" title="为什么那么多成功的人，他们每天只睡几个小时？"></a>为什么那么多成功的人，他们每天只睡几个小时？</h1><p>这个世界就是一波人昼夜不停地运转,另一波人醒来后发现世界变了！</p><p>美剧都是骗人的，现实真的很累</p><p>一直有一个很大的困惑，为什么很多有名的成功人士可以睡得那么少？</p><p>第一次意识到这个问题，是刚到美国读书的时候。</p><p>相信在美国上过学的人都有体会，学习强度非常大。</p><p>每天早上8点起床去上课，晚上在图书馆待到1点，周末也基本都安排得满满的。不是因为故意用功，而是功课实在太多，让你完全没有任何喘息的时间。</p><p>拿其中一门主课来说，一周上三次课，一次三小时，每次课后教授都会在学校内网上传当天的阅读材料，都是她从各种数据库里找的论文文献和在图书馆里扫描的书籍，通常是PDF文档，可以下载后到图书馆免费打印。</p><p>每次要打印上百张A4纸（正反两面打印），偶尔打印完一看，今天的材料竟然只有六七十张，就会觉得心情一下子轻松了不少。</p><p>不要忘了这不是看休闲杂志，里面的内容都是枯燥艰深的学术论文，而且通常排版得密密麻麻并且极少插图。</p><p>你以为光看这些材料就完了吗？并没有。</p><p>在还没有开学前，教授已经发邮件给每一个学生，列出了整个学期的阅读书目，一共有30多本，都是学术书籍，要求学生自己到书店里去买，每周课上会讨论其中的一两本书。</p><p>至于统一的教材，反而是没有的。此外，每周还要写两篇文章，还得抽时间准备毕业前要交的论文。</p><p>不要忘了，这还只是其中的一门课，其他每一门课的教授都会这样像地主恶霸一样地把你榨成渣渣。</p><p>读完一年的硕士课程，每一个人都像经历了一场生死炼狱，毕业时仿佛有重生之感。</p><p>那个时候最好的纪念，就是去学院里的纪念品商店买一件上面印着“I survived J School”的T恤衫（J School是学院的简称），意思是“我读完J School竟然活了下来”。</p><p>这么高强度的工作量，正常的作息时间是绝对不可能完成的。</p><p>所以几乎每天大部分人都只能蓬头垢面地在学校和住处之间两点一线地疲于奔命。</p><p>之前设想的要多去旁听其他系有意思的课、多认识人、多参加社会活动等等美好憧憬，全部都被残酷的现实击打得粉碎。</p><p>即使现在已经几年过去了，重新回想起来仍然觉得心有余悸。</p><p>尽管当时居住的地方右转300米就是著名的中央公园，但是整整三个月愣是没有时间去瞅一眼。</p><p>总有那么几个学霸天生不用睡觉</p><p>当时班里一共9个学生，除了两人以外，其他都是美国人。大多数人也都是疲于奔命，眼睛带着血丝。但是，有一个本科在哈佛读的美国同学，却每天都一副容光焕发精力充沛的样子。</p><p>曾经以为他是偷懒没看阅读材料，所以有足够的休息时间，可后来发现并非如此，他不但把大部分功课都完成了，而且还有时间去听个讲座、参加个派对什么的。</p><p>他说，他固定在凌晨3点半睡觉，早上7点半起床。这让人很震惊，问他睡这么少为什么还能保持这么旺盛的精力？一般人每天睡6个多小时，就已经觉得到了自己的极限了。</p><p>他笑笑说，他一直都是这样，每天睡4个小时就差不多够了。他还说，在美国就是这样，工作、社交、睡觉，每个人都只能保证两样，他不想耽误学习也不想没有社交，就只能牺牲睡眠了。</p><p>其实不仅仅是在顶尖的学校，美国社会里顶尖的那一批人，几乎都是处于这样一种疯狂高速运转的状态。为了保证工作学习和社交娱乐，他们不约而同地牺牲了自己的睡眠，每天只睡四五个小时是很常见的。</p><p>比如学院里的教授，也是如此。除了教书以外，她还是好几家媒体的专栏作者，每周都要写很多文章；还经常参加各种研讨会和研究计划；在这样的情况下，她还有时间每年写一本书。</p><p>相比学生，她的工作量只多不少。不知道她每天睡几个小时，只知道每天收到的最后一封电子邮件必定是她发的，每天早上收到的第一封邮件也是她发的。</p><p>有时候学生们晚上1点写完作业用电子邮件给她发过去，第二天一大早必然会收到她回复的修改意见，而且看邮件发送时间常常是凌晨三、四点。可是每天早上9点开始的课，她从来没有迟到过一次。</p><p>再比如工作以后遇到过的几位上司，几乎都是每天半夜两三点给大家发工作邮件，第二天一大早8点不到进办公室，而且天天如此。</p><p>媒体也时不时地会写关于睡眠时间的文章，列出那些成功人士只睡三四个小时的例子——奥巴马每天只睡6个小时，雅虎的美女 CEO 玛丽莎·梅耶尔每天只睡4个小时，还有特朗普据说也只睡4个小时……</p><p>为什么他们不睡觉还有精力拼搏</p><p>在北美一个华人论坛上出现过这么一个话题：</p><p>为什么跨国公司的CEO们每天只睡四五个小时，却能有效地管理几百亿市值的公司？</p><p>当然，这个问题并没有一个明确的答案。有科学家做过研究说，有些人可以每天只睡四五个小时还精力充沛，除了他们自己很拼很努力，更主要的原因是他们体内有一种异于常人的基因。</p><p>他们还把这种基因命名为“撒切尔基因”，因为据说撒切尔夫人就是一个非常著名的“少睡者”的典型。</p><p>所以，最大的解释就是，这就是天分吧。</p><p>对于那些没有少睡基因、“输在起跑线上”的人来说，办法大概是：</p><p>一，尽可能地保证睡眠的质量；</p><p>二，提高睡眠的效率，有些事情睡觉时能办的就在睡觉时办。</p><p>三，多运动，这是补充精力的有效方法。</p><p>前方高能，再来看看这22位CEO的作息：</p><p>1、美国在线公司（AOL）首席执行官Tim Armstrong</p><p>这位前谷歌执行官并不是一位“爱好睡觉”的人，他每天都在清晨5点或5：15醒来。之后要么工作，要么阅读，或者看看自家公司的产品，回复电子邮件。</p><p>为了保证更多的思考时间，Tim Armstrong通常不会自己开车，而是请专职司机。</p><p>2、苹果公司首席执行官Tim Cook</p><p>这位科技巨擘在业界正是以早起出名，苹果的员工会在清晨、或者说接近黎明时分的4：30就收到Tim Cook的电子邮件，且每日如此，他们已经习以为常。</p><p>当然，Tim Cook会在5点钟的时候准时出现在健身房。</p><p>3、通用电气（GE）首席执行官Jeff Immelt</p><p>通用电气（GE）首席执行官Jeff Immelt每一天的5：30都会起床做有氧运动。</p><p>期间，他还会读报纸，看CNBC。</p><p>他曾经提起，自己已经连续24年每周工作100个小时了。</p><p>这就是说，按照7天的时间计算，他每天的工作时长为14个小时以上……</p><p>4、通用汽车公司（General Motors）首席执行官Mary Barra</p><p>早起大概成了通用公司的传统，现任CEO Mary Barra就像其前任Daniel Akerson一样，日日早起。</p><p>她每天准时准点地在清晨6点出现在办公室。</p><p>在这一点上，她比前任做的还要出色。</p><p>5、富士施乐（Xerox）首席执行官Ursula Burns</p><p>回复电邮是Ursula Burns每日清晨的习惯，为此，她会在5：15起床。</p><p>不过，尽管经常会工作到深夜，但Ursula Burns会保证自己每周两次的个人健康训练，这个时间定在6：00，每次一个小时。</p><p>6、菲亚特（Fiat）和克莱斯勒（Chrysler）首席执行官Sergio Marchionne</p><p>这位具有加拿大和意大利双重国籍的商人起床的时候，恐怕大部分人都还在梦乡中——3：30。</p><p>公司有位高管曾表示：“Sergio创造出了（一周里的）第八天，我们来实现它。”</p><p>还有一位高管曾在60 Minutes节目中这样说：“当意大利放假的时候，他回美国工作；当美国放假的时候，他再回意大利工作。”</p><p>7、太平洋投资管理公司（PIMCO）创始人Bill Gross</p><p>Bill Gross的早起如同他那糟糕的君王脾气，以及职业二十一点玩家的身份一样出名。</p><p>他会在4：30就起床，查看全球市场行情和消息，并在6点钟准时坐在办公桌前。</p><p>8、Twitter创始人、移动支付公司Square首席执行官Jack Dorsey</p><p>Jack Dorsey曾对媒体透露，他一般会在5：30起床，然后就开始做早课——冥想，以及一个小时的慢跑。</p><p>这样的生活方式他持续了很久，尤其是同时在Twitter和Square之间来回奔波工作的时候。</p><p>9、维珍集团（Virgin Group）创始人及董事局主席Richard Branson</p><p>Richard Branson自曝起床时间是5：45，甚至在他的私人岛屿上度假时也是如此。他会拉开窗帘睡觉，这样，第二天的阳光就会叫醒自己。</p><p>10、百事集团（PepsiCo）首席执行官Indra Nooyi</p><p>这位这位印度裔女执行官最早的起床时间是清晨4点。</p><p>她曾称：“人们说，睡眠是上帝赐予的礼物……这份礼物我从未得到过。”她透露自己每天到公司的时间不会晚于7点。</p><p>11、维珍美国首席执行官David Cush</p><p>他曾向媒体表示，自己每天会在4：15起床，然后发邮件、致电东海岸的商业伙伴。</p><p>不过，每天清晨的达拉斯体育广播是他不会错过的节目，当然，还包括读报纸和健身。</p><p>12、迪斯尼集团首席执行官Bob Iger</p><p>Bob Iger曾对纽约时报表示，他一般在4：30起床，利用上班前这段安静的时光读报纸、看电视。这段时间无人打扰，他能同时处理多项事情。</p><p>13、Hain Celestial Group首席执行官Irwin Simon</p><p>他是美国天然日用品制造商Hain Celestial集团CEO，他每天5点钟起床，之后的习惯就像上述几个CEO们一样，回复邮件、与欧洲和亚洲的商业伙伴通话。</p><p>不同的是，他还会在孩子们起来之前祈祷、遛狗、做运动。</p><p>而且，他还能在进入长岛办公室之前在曼哈顿开个早餐会。</p><p>14、前百事可乐CEO Steve Reinemund</p><p>现任Wake Forest大学商学院院长，他告诉媒体，他在5:30起床，再读报纸。他会在工作前浏览纽约时报、华尔街日报、金融时报、达拉斯晨报。</p><p>15、星巴克CEO Howard Schultz</p><p>Howard Schultz以晨练开始新的一天，一般是与妻子一同骑车。即便如此，他也会保证自己在6点之前赶到办公室。</p><p>16、Aurora Fashions首席执行官Mike Shearwood</p><p>作为一家英国时尚领域的先锋公司，Aurora Fashions首席执行官Mike Shearwood忙碌的一天开始于清晨5点。</p><p>他从诺丁汉赶到伦敦差不多是7：45了。他对这种长距离的上下班路途乐此不疲：“我会赶复邮件、赶工作，还能与团队通电话。”</p><p>17、布鲁克林篮网队首席执行官Brett Yormark</p><p>布鲁克林篮网队（Brooklyn Nets）在更名前为新泽西篮网队。Brett Yormark是全美NBA界最年轻的CEO。</p><p>他的起床时间也许会让很多人汗颜——3点半，而且他在4：30就会出现在办公室了，然后开始一天的工作，发邮件什么的。</p><p>不过，他并非铁人，周末是他放松自己的时间——7点钟才到办公室工作。</p><p>18、前氧气媒体公司 （Oxygen Channel）首席执行官Gerry Laybourne</p><p>作为二十世纪80年代有线电视界先锋人物，Gerry Laybourne总是在6点起床，半小时以后离家赶赴公司。</p><p>如果你起得够早，她可能还会带上你。</p><p>她曾对雅虎财经说：“每周一到两次，我都会在中央公园步行，并与一名寻求我的建议的年轻人同行。这是我帮助下一代人的方式。如果有人早起，我认为，他对待生活是认真的。我无法在公司做这些事，但早起让我有空健身，同时，还能和年轻人保持沟通交流。</p><p>19、私募股权投资公司Saban Capital首席执行官Haim Saban</p><p>这位埃及出生的以色列-美国籍亿万富豪也很勤奋，6：02，他就开始享用清晨咖啡了。他会在75分钟的晨练前先工作一小时。</p><p>20、Brooklyn Industries首席执行官Lexy Funk</p><p>这位时尚企业联合创始人之一曾对赫芬顿邮报如此形容她的一天：她一般在4点醒来。然后开始纠结，到底是倒头再睡，还是拿起黑莓工作呢？不过，绝大多数情况下，她在忙于回复邮件的同时，会抽空打几个和生意有关的电话。</p><p>21、喜达屋酒店（Starwood Hotels）首席执行官Frits Van Paasschen</p><p>他在5：50就开始跑步了，你可以想象他的起床时间。6：30，他会准时出现在办公桌前。</p><p>22、Cisco 首席执行官Padmasree Warrior</p><p>这位印度裔女强人4：30就起来了，发邮件、读新闻、晨练，一样不少。最晚在8：30，她就会进入公司工作了。</p><p>也正因其勤奋而卓有成效的工作，Padmasree Warrior早在作为摩托罗拉首席技术官的时候就备受赞誉了。</p><p>时间赋予每个人都是24小时，只是有些人把时间用到了极致。</p><p>这个世界最可怕事，比你牛逼的人，竟然比你还努力。</p><p>有一波人昼夜不停地运转,另一波人醒来后发现世界变了</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Causerie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Causerie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jar包结构讲解</title>
      <link href="/2018/09/07/Java/java-jar/"/>
      <url>/2018/09/07/Java/java-jar/</url>
      
        <content type="html"><![CDATA[<p>jar包结构讲解，搞懂哪些META-INF/MANIFEST.MF是什么意思</p><h2 id="官方参考"><a href="#官方参考" class="headerlink" title="官方参考"></a>官方参考</h2><p><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html</a> <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8">🎉</span> <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8">🎉</span></p><p>本文参考: <a href="https://www.cnblogs.com/applerosa/p/9736729.html" target="_blank" rel="noopener">https://www.cnblogs.com/applerosa/p/9736729.html</a></p><h2 id="什么是jar"><a href="#什么是jar" class="headerlink" title="什么是jar"></a>什么是jar</h2><p>JAR(Java Archive File)，Java 档案文件。通常jar 为压缩文件, 与 ZIP/RAR 压缩文件 一样的概念<br>区别在于 jar 文件中存在一个名为<code>META-INF/MANIFEST.MF</code>的清单文件，关于JAR包的描述信息、启动时的配置信息和安全性信息等均保存在其中，可以理解为 jar 的一个<code>配置文件</code></p><h2 id="可执行的-JAR"><a href="#可执行的-JAR" class="headerlink" title="可执行的 JAR"></a>可执行的 JAR</h2><ul><li>一个可执行的 jar 文件是一个自包含的 Java 应用程序，它存储在特别配置的JAR 文件中，可以由 JVM 直接执行它而无需事先提取文件或者设置类路径</li><li>要运行存储在非可执行的 JAR 中的应用程序，必须将它加入到你的类路径中，并用名字调用应用程序的主类。就是我们常说的”第三方类库的概念”</li><li>但是使用可执行的 JAR 文件，我们可以不用提取它或者知道主要入口点就可以运行一个应用程序。可执行 JAR 有助于方便发布和执行 Java 应用程序</li></ul><ol><li>创建可执行 JAR</li></ol><p>假设应用程序中的主类是: cn.china.demo.Application.java, 里面有个可执行的main() 函数入口,要创建一个包含应用程序代码的 JAR 文件并标识出主类。为此，在某个位置(不是在应用程序目录中)创建一个名为 manifest 的文件，并在其中加入以下一行:</p><p><code>Main-Class: cn.china.demo.Application</code></p><p>然后，像这样创建 JAR 文件：</p><p><code>jar cmf manifest example.jar application-dir</code></p><p>所要做的就是这些了 – 现在可以用 java -jar 执行这个 JAR 文件 example.jar</p><p>一个可执行的 JAR 必须通过 menifest 文件的头引用它所需要的所有其他从属 JAR</p><p>如果使用了 -jar 选项，那么环境变量 CLASSPATH 和在命令行中指定的所有类路径都被 JVM 所忽略</p><ol start="2"><li>启动可执行 JAR</li></ol><p>既然我们已经将自己的应用程序打包到了一个名为 example.jar 的可执行 JAR 中了，那么我们就可以用下面的命令直接从文件启动这个应用程序:<br><code>java -jar example.jar</code></p><ol start="3"><li>扩展打包</li></ol><p>扩展为 Java 平台增加了功能，在 JAR 文件格式中已经加入了扩展机制。扩展机制使得 JAR 文件可以通过manifest 文件中的 Class-Path 头指定所需要的其他 JAR 文件</p><p>假设 extension1.jar 和 extension2.jar 是同一个目录中的两个 JAR 文件，extension1.jar 的 manifest 文件包含以下头:</p><p><code>Class-Path: extension2.jar</code></p><p>这个头表明 extension2.jar 中的类是 extension1.jar 中的类的 扩展类。extension1.jar 中的类可以调用extension2.jar 中的类，并且不要求 extension2.jar 处在类路径中</p><p>在装载使用扩展机制的 JAR 时，JVM 会高效而自动地将在 Class-Path 头中引用的 JAR 添加到类路径中。不过，扩展 JAR 路径被解释为相对路径，所以一般来说，扩展 JAR 必须存储在引用它的 JAR 所在的同一目录中</p><p>例如，假设类 ExtensionClient 引用了类 ExtensionDemo ,它捆绑在一个名为 ExtensionClient.jar 的 JAR 文件中，而类 ExtensionDemo 则捆绑在 ExtensionDemo.jar 中</p><p>为了使 ExtensionDemo.jar 可以成为扩展，必须将ExtensionDemo.jar 列在 　　ExtensionClient.jar 的 manifest 的 Class-Path 头中，如下所示:</p><pre class="line-numbers language-sh"><code class="language-sh">Manifest-Version: 1.0Class-Path: ExtensionDemo.jar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在这个 manifest 中 Class-Path 头的值是没有指定路径的 ExtensionDemo.jar，表明 ExtensionDemo.jar 与ExtensionClient JAR 文件处在同一目录中</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>jar包含一个META-INF/MANIFEST.MF，描述jar的配置信息，一个jar可用依赖另一个jar，配置要正确，处在同一目录</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8 new语法特性</title>
      <link href="/2018/04/05/Java/Java8-new-syntax/"/>
      <url>/2018/04/05/Java/Java8-new-syntax/</url>
      
        <content type="html"><![CDATA[<p>Java8 new语法特性</p><p><img src="/images/Java/Java-base.jpg" alt="image"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>发现很多小伙伴还没有用上Java的新特性，这其实也和Java比较标准化的原因有关吧，稳定才是企业的诉求，像lambda，函数式等其它语言都过的东西，却很少在Java中看见，不过会还是要会的，跟上时代的步伐，尤其是函数式编程的思想</p><h2 id="Lambda表达式和方法引用"><a href="#Lambda表达式和方法引用" class="headerlink" title="Lambda表达式和方法引用"></a>Lambda表达式和方法引用</h2><h2 id="Stream流对象"><a href="#Stream流对象" class="headerlink" title="Stream流对象"></a>Stream流对象</h2><p>流分类:</p><ol><li>顺序流: 按照顺序对集合中的元素进行处理</li><li>并行流: 使用多线程同时对集合中多个元素进行处理(在使用并行流的时候就要注意线程安全的问题)</li></ol><p>流的过程: 元素流在管道中经过中间操作（intermediate operation）的处理，最后由终端操作 (terminal operation) 得到前面处理的结果。</p><p>中间操作(intermediate operation):  中间操作会产生另一个流，(流是一种惰性操作，所有对源数据的计算只在终止操作被初始化的时候才会执行)，而且中间操作还分无状态操作和有状态操作两种:</p><ol><li>无状态操作 : 在处理流中的元素时，会对当前的元素进行单独处理。 (例如:过滤操作).</li><li>有状态操作 : 某个元素的处理可能依赖于其他元素.( 例如:查找最小值，最大值，和排序 ).</li></ol><p>终止操作 (terminal operation):消费 Stream 流，并且会产生一个结果 . <code>如果一个 Stream 流被消费过了，那它就不能被重用的</code></p><p>Stream流一般的执行过程可概括为:</p><ol><li>源(Stream)</li><li>零个或多个中间操作(intermediate operation)</li><li>终止操作 （到这一步才会执行整个stream pipeline计算） (terminal operation)</li></ol><p>源的创建方式</p><ol><li>使用Collection下的 stream() 和 parallelStream() 方法</li><li>使用Stream中的静态方法：of()</li></ol><p>// 顺序流<br>Stream&lt; String&gt; stream = createStream.stream();<br>// 并行流<br>Stream&lt; String&gt; parallelStream = createStream.parallelStream();<br>// of()方法创建<br>Stream&lt; String&gt; stringStream = Stream.of(createStream.toArray(new String[createStream.size()]));</p><p>Intermediate操作</p><p>中间操作包括map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered等.</p><p>常用操作解析:</p><p>filter : 筛选符合条件的元素后重新生成一个新的流。<br>map : 接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。<br>flatMap:   接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。<br>distinct: 去重操作，将 Stream 流中的元素去重后，返回一个新的流。<br>sorted: 产生一个自然顺序排序或者指定排序条件的新流。<br>skip:跳过n元素，配合limit(n)可实现分页<br>peek: 生成一个包含原Stream的所有元素的新Stream，同时会提供一个消费函数（Consumer实例），新Stream每个元素被消费的时候都会执行给定的消费函数(一般用于重赋值那些)；<br>limit:  对一个Stream进行截断操作，获取其前N个元素，如果原Stream中包含的元素个数小于N，那就获取其所有的元素；</p><p>terminal操作:</p><p>终止操作包括:forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator等</p><p>常用操作解析:</p><p>forEach: 遍历了流中的元素。(终端操作)<br>collect: 接收一个Collector实例，将流中元素收集成另外一个数据结构<br>max:获得流中最大值，比较器可以由自己定义。(终端操作)<br>min: 获得流中最小值，比较器可以由自己定义。(终端操作)<br>anyMatch : 判断 Stream 流中是否有任何符合要求的元素，如果有则返回 ture,没有返回 false。（终端操作）</p><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>1、什么是Optional？</p><p>一句话概括: 它是一个容器，用来包装对象，解决NullPointerException异常的</p><p>2、如何创建Optional对象？或者说如何用Optional来包装对象或null值？</p><ul><li><p>static Optional empty() ：用来创建一个空的Optional</p></li><li><p>static Optional of(T value) ：用来创建一个非空的Optional</p></li><li><p>static Optional ofNullable(T value) ：用来创建一个可能是空，也可能非空的Optional</p></li></ul><p>其实上面这三个方法，看一下源码就很清晰了，比如of</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 方法</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Optional<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">of</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Optional</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 构造器</span><span class="token keyword">private</span> <span class="token function">Optional</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Objects对象的requireNonNull方法</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">requireNonNull</span><span class="token punctuation">(</span>T obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> obj<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>of方法创建Optional对象，并对传入值做NullPointerException异常判断，所以，当你传递一个null值的时候，就会触发异常了</p><p>再看看empty方法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 方法</span><span class="token keyword">public</span> <span class="token keyword">static</span><span class="token operator">&lt;</span>T<span class="token operator">></span> Optional<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>        Optional<span class="token operator">&lt;</span>T<span class="token operator">></span> t <span class="token operator">=</span> <span class="token punctuation">(</span>Optional<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span> EMPTY<span class="token punctuation">;</span>        <span class="token keyword">return</span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 静态常量</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Optional<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> EMPTY <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Optional</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 常量</span><span class="token keyword">private</span> <span class="token keyword">final</span> T value<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 构造器</span><span class="token keyword">private</span> <span class="token function">Optional</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一开始就定义了一个<code>Optional&lt;?&gt; EMPTY</code>的对象，并且构造函数使用默认的，value为空。empty只是做了泛型的转换</p><p>剩下的ofNullable就更简单了，通过传递的值决定使用of还是empty</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Optional<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">ofNullable</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> value <span class="token operator">==</span> null <span class="token operator">?</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">of</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Optional类的源码还是比较简单的，代码很少，通过成员变量和构造方法的解读，相信你已经理解了of，empty，ofNullable</p><p>3、如何使用Optional类？</p><p>最正确的做法就是对需要做NullPointerException异常判断的对象，把它包装成Optional类，然后指明对象不存在的时候，应该怎么做，下面来看一下几种常见的用法</p><ol><li>orElse</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OptionalTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> User<span class="token operator">></span> userHashMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userHashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"Xiao Ming"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userHashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"Xiao Zhi"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userHashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        UserUtil userUtil <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserUtil</span><span class="token punctuation">(</span>userHashMap<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这个工具类只是为了填充数据的，不要在意这些细节，getUserByUserId方法能返回User对象</span>        <span class="token comment" spellcheck="true">// 包装了User对象，并且使用orElse指明了对象不存在的时候应该返回指定的值，也就是new User(1, "Xiao Bai")</span>        User user <span class="token operator">=</span> Optional                <span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>UserUtil<span class="token punctuation">.</span><span class="token function">getUserByUserId</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"Xiao Bai"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 工具类，随便写的，通过hashMap模拟查询用户</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Integer id<span class="token punctuation">;</span>    <span class="token keyword">public</span> String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">User</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">,</span> String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">UserUtil</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> User<span class="token operator">></span> hashMap<span class="token punctuation">;</span>    <span class="token function">UserUtil</span><span class="token punctuation">(</span>HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> User<span class="token operator">></span> hashMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>        UserUtil<span class="token punctuation">.</span>hashMap <span class="token operator">=</span> hashMap<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> User <span class="token function">getUserByUserId</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        User user <span class="token operator">=</span> hashMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> user<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>orElseGet</li></ol><p>和 orElse 不同，它的参数接受一个lambda表达式</p><pre class="line-numbers language-java"><code class="language-java">User user <span class="token operator">=</span> Optional                <span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>UserUtil<span class="token punctuation">.</span><span class="token function">getUserByUserId</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"Xiao Bai"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="3"><li>orElseThrow</li></ol><p>同理，传递一个lambda表达式异常(注意啊，方法是限定了参数的，触发异常就用orElseThrow，不能用orElseGet)</p><pre class="line-numbers language-java"><code class="language-java">User user <span class="token operator">=</span> Optional                <span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>UserUtil<span class="token punctuation">.</span><span class="token function">getUserByUserId</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">orElseThrow</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">AssertionError</span><span class="token punctuation">(</span><span class="token string">"AssertionError"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="4"><li>map</li></ol><p>调用map后，如果当前 Optional 为 Optional.empty，则依旧返回 Optional.empty；否则返回一个新的 Optional，该 Optional 包含的是：函数 mapper 在以 value 作为输入时的输出值</p><p>比如下面的例子，第一次调用map后，获取的是name，传递给下一个map的值相当于Optional.ofNullable(name)</p><pre class="line-numbers language-java"><code class="language-java">String user <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>UserUtil<span class="token punctuation">.</span><span class="token function">getUserByUserId</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>user1 <span class="token operator">-</span><span class="token operator">></span> user1<span class="token punctuation">.</span>name<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>toLowerCase<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 方法</span><span class="token keyword">public</span><span class="token operator">&lt;</span>U<span class="token operator">></span> Optional<span class="token operator">&lt;</span>U<span class="token operator">></span> <span class="token function">map</span><span class="token punctuation">(</span>Function<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">U</span><span class="token operator">></span> mapper<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>mapper<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>mapper<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个操作可以用在对对象做多次操作的场景下，并且保证为空的时候返回指定的值，比如先获取用户的名称，再获取用户的电话，做一下判断后，再通过电话查询到其它的数据，然后继续…，最后如果某一环节出现异常，那就返回orElse定义的对象</p><ol start="5"><li>flatMap</li></ol><p>flatMap 方法与 map 方法的区别在于，map 方法参数中的函数 mapper 输出的是值，然后 map 方法会使用 Optional.ofNullable 将其包装为 Optional；而 flatMap 要求参数中的函数 mapper 输出的就是 Optional</p><p>即 <code>.flatMap(user -&gt; Optional.of(user.name()))</code></p><ol start="6"><li>filter</li></ol><p>都是差不多的套路，这次我们先看源码，可以发现同样是接受lambda表达式，并且要是一个Boolean返回值的，如果本次操作的optional是empty的，就返回本身</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Optional<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">filter</span><span class="token punctuation">(</span>Predicate<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">></span> predicate<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>predicate<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span> predicate<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">this</span> <span class="token operator">:</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 函数式接口部分代码，可以看到test是要求返回Boolean类型的</span><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Predicate</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * Evaluates this predicate on the given argument.     *     * @param t the input argument     * @return {@code true} if the input argument matches the predicate,     * otherwise {@code false}     */</span>    <span class="token keyword">boolean</span> <span class="token function">test</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 例子</span>String name <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>UserUtil<span class="token punctuation">.</span><span class="token function">getUserByUserId</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>user <span class="token operator">-</span><span class="token operator">></span> user<span class="token punctuation">.</span>id <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>user <span class="token operator">-</span><span class="token operator">></span> user<span class="token punctuation">.</span>name<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过观察源码，我们可以看到，很多为空的都会返回empty，这让各个操作都能够互相调用</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>Optional是一个比较简单的类，推荐直接阅读源码，通过简单的包装，很优雅的解决的空指针问题，以前谷歌Guava库就实现了，后面Java8正式把规范加到 <code>java.util.Optional</code> 类中</p><p>PS: 如果你看源码有压力，快去补习一下lambda，函数式编程</p><p>另外，上面的做法是对于程序内的，如果是web开发，参数校验，请使用Hibernate-Validator即可，作为一个合格的后端，我不会让前端挑刺的</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Proxy 与 AOP</title>
      <link href="/2018/04/05/Java/java-proxy/"/>
      <url>/2018/04/05/Java/java-proxy/</url>
      
        <content type="html"><![CDATA[<h2 id="静态代理和动态代理"><a href="#静态代理和动态代理" class="headerlink" title="静态代理和动态代理"></a>静态代理和动态代理</h2><p>静态代理就是直接编码的形式，比如有一个UserDao，提供查询和修改数据库功能，假如我要扩展它，让每个数据库操作都在事务中执行，势必要修改代码。 可以代理这个UserDao，由代理类来处理事务，查询和修改的调用还是在UserDao中</p><p>参考 <a href="https://blog.csdn.net/hon_3y/article/details/70655966" target="_blank" rel="noopener">https://blog.csdn.net/hon_3y/article/details/70655966</a></p><p>例子</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>liuzhidream<span class="token punctuation">.</span>rrdtool<span class="token punctuation">.</span>store<span class="token punctuation">.</span>service<span class="token punctuation">.</span>proxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Description * @Author VanLiuZhi * @Date 2020-03-11 14:54 */</span><span class="token comment" spellcheck="true">// 服务接口</span><span class="token keyword">interface</span> <span class="token class-name">IUserDao</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span>Integer pk<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">delete</span><span class="token punctuation">(</span>Integer pk<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 服务实现</span><span class="token keyword">class</span> <span class="token class-name">UserDao</span> <span class="token keyword">implements</span> <span class="token class-name">IUserDao</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span>Integer pk<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"查询的数据id是"</span> <span class="token operator">+</span> pk<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> pk<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">delete</span><span class="token punctuation">(</span>Integer pk<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"删除的数据id是"</span> <span class="token operator">+</span> pk<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> pk<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 如果要扩展事务，需要修改代码</span><span class="token comment" spellcheck="true">//public int delete(Integer pk) {</span><span class="token comment" spellcheck="true">//    System.out.println("transaction staring");</span><span class="token comment" spellcheck="true">//    System.out.println("删除的数据id是" + pk);</span><span class="token comment" spellcheck="true">//    System.out.println("transaction end");</span><span class="token comment" spellcheck="true">//    return pk;</span><span class="token comment" spellcheck="true">//}</span><span class="token comment" spellcheck="true">// 使用静态代理</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StaticProxy</span> <span class="token keyword">implements</span> <span class="token class-name">IUserDao</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> UserDao userDao<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">StaticProxy</span><span class="token punctuation">(</span>UserDao userDao<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>userDao <span class="token operator">=</span> userDao<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span>Integer pk<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"transaction staring"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> userDao<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>pk<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"transaction end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">delete</span><span class="token punctuation">(</span>Integer pk<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"transaction staring"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> userDao<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>pk<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"transaction end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>缺点:</p><ol><li>代理类也是对接口的实现，如果接口改了，也要跟着改</li><li>代理对象需要实现和目标对象一样的接口，会有很多代理类，类太多</li></ol><p>动态代理: 可以使用动态代理，代理对象，不需要实现接口，就不会有太多的代理类。动态代理是在内存中创建对象的，利用JDKAPI</p><p>动态代理约束: <strong>目标对象一定是要有接口的，没有接口就不能实现动态代理</strong></p><p>动态代理举例，使用Proxy.newProxyInstance创建目标对象</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>liuzhidream<span class="token punctuation">.</span>rrdtool<span class="token punctuation">.</span>store<span class="token punctuation">.</span>service<span class="token punctuation">.</span>proxy<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>InvocationHandler<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Proxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Description * @Author VanLiuZhi * @Date 2020-03-11 14:02 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProxyFactory</span> <span class="token punctuation">{</span>    XiaoMing xiaoMing <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XiaoMing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> Person <span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*         * loader 生成代理对象使用哪个类装载器【一般我们使用的是代理类的装载器】         * interfaces 目标对象的接口。生成哪个对象的代理对象，通过接口指定【指定要代理类的接口】         * h 生成的代理对象的方法里干什么事【实现handler接口，我们想怎么实现就怎么实现】         *         * public static Object newProxyInstance(ClassLoader loader, Class&lt;?>[] interfaces, InvocationHandler h)         */</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>Person<span class="token punctuation">)</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>ProxyFactory<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> xiaoMing<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">InvocationHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 这里只实现了其中一个方法，就是代理对象实例调用getProxy后，再去调用方法，就由这里的逻辑来处理</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"sing"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1000"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>xiaoMing<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ProxyFactory proxyFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProxyFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Person proxy <span class="token operator">=</span> proxyFactory<span class="token punctuation">.</span><span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        proxy<span class="token punctuation">.</span><span class="token function">sing</span><span class="token punctuation">(</span><span class="token string">"你好"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">sing</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">dance</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">XiaoMing</span> <span class="token keyword">implements</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sing</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"小明唱"</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dance</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"小明跳"</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="cglib"><a href="#cglib" class="headerlink" title="cglib"></a>cglib</h2><p>引入cglib – jar文件，spring core包含了对应的代码，可以用spring的</p><p>cglib在内存中动态构建子类</p><p>代理的类不能为final，否则报错(在内存中构建子类来做扩展，当然不能为final，有final就不能继承了)</p><p>目标对象的方法如果为final/static, 那么就不会被拦截，即不会执行目标对象额外的业务方法</p><p>代码举例</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>liuzhidream<span class="token punctuation">.</span>rrdtool<span class="token punctuation">.</span>store<span class="token punctuation">.</span>service<span class="token punctuation">.</span>proxy<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>Enhancer<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>MethodInterceptor<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>MethodProxy<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @Description * @Author VanLiuZhi * @Date 2020-03-11 15:16 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CGlibProxyFactory</span> <span class="token keyword">implements</span> <span class="token class-name">MethodInterceptor</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 维护目标对象</span>    <span class="token keyword">private</span> Object target<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">CGlibProxyFactory</span><span class="token punctuation">(</span>Object target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 给目标对象创建代理对象</span>    <span class="token keyword">public</span> Object <span class="token function">getProxyInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//1. 工具类</span>        Enhancer en <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//2. 设置父类(目标对象)</span>        en<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//3. 设置回调函数</span>        en<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//4. 创建子类(代理对象)</span>        <span class="token keyword">return</span> en<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">intercept</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> MethodProxy methodProxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始事务....."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 执行目标对象的方法</span>        Object returnValue <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"提交事务....."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> returnValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span>Integer pk<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"query pk is"</span> <span class="token operator">+</span> pk<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> pk<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">delete</span><span class="token punctuation">(</span>Integer pk<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"delete pk is"</span> <span class="token operator">+</span> pk<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> pk<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        User user <span class="token operator">=</span> <span class="token punctuation">(</span>User<span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">CGlibProxyFactory</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getProxyInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// class com.liuzhidream.rrdtool.store.service.proxy.User$$EnhancerByCGLIB$$fa2d90ed</span>        <span class="token comment" spellcheck="true">// 对象已经不是原对象了</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不会被拦截</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="动态代理和cglib"><a href="#动态代理和cglib" class="headerlink" title="动态代理和cglib"></a>动态代理和cglib</h2><p>动态代理是jdk通过API创建的的(利用的是反射)，cglib是asm字节码操作框架实现的(利用字节码)。都是动态代理</p><p>但是jdk动态代理，<code>目标对象要实现接口</code>，有一定的局限性。cglib <code>目标对象不用实现接口</code></p><p>JDK是基于反射机制,生成一个实现代理接口的匿名类,然后重写方法,实现方法的增强.<br>它生成类的速度很快,但是运行时因为是基于反射,调用后续的类操作会很慢.<br>而且他是只能针对接口编程的.</p><p>CGLIB是基于继承机制,继承被代理类,所以方法不要声明为final,然后重写父类方法达到增强了类的作用.<br>它底层是基于asm第三方框架，是对代理对象类的class文件加载进来,通过修改其字节码生成子类来处理.<br>生成类的速度慢,但是后续执行类的操作时候很快.<br>可以针对类和接口。</p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>参考: 链接：<a href="https://juejin.im/post/5aa8edf06fb9a028d0432584" target="_blank" rel="noopener">https://juejin.im/post/5aa8edf06fb9a028d0432584</a></p><p>AOP这块，首先要把一些术语先记住，其实AOP个人感觉不是什么特别神奇的东西，和Python的装饰器很像，就像很多语言都有反射一样，但是这些术语不知道会<br>阻碍你学习AOP，所以先过一遍相关术语</p><p>关注点代码和核心代码: </p><ul><li><p>所谓关注点代码就是重复的代码，就行最开始举例中的事务相关的代码，它的特点就是重复出现(这个点也叫切面，横切关注点)</p></li><li><p>核心代码就是业务代码，比如查询用户(核心关注点)</p></li></ul><p>使用AOP的作用: <code>关注点代码和核心代码分离</code></p><p>这样做的好处: 1. 关注点代码只用写一次  2. 开发者把工作放到核心代码上 3. 运行时期，执行核心业务代码时候动态植入关注点代码，也就是代理</p><p>另外，这里聊的AOP主要是在spring中去运用，spring借鉴了Aspectj框架的概念和思想，但是spring没有依赖这个框架，只有一个注解@Aspect，看着好像是有用到Aspectj的东西，其实不是，它只是一个注解，刚好名字接近了</p><p>下面是概念：</p><p>切面(aspect):类是对物体特征的抽象，切面就是对横切关注点的抽象</p><p>横切关注点:对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点。</p><p>连接点(joinpoint):被拦截到的点，因为 Spring 只支持方法类型的连接点，所以在 Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器。</p><p>切入点(pointcut):对连接点进行拦截的定义</p><p>通知(advice):所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、 异常、最终、环绕通知五类。</p><p>目标对象:代理的目标对象</p><p>织入(weave):将切面应用到目标对象并导致代理对象创建的过程</p><p>引入(introduction):在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法 或字段。</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><ol><li><p>加入依赖</p></li><li><p>定义切面，它是一个bean</p></li><li><p>在切面中去定义连接点，就是要对哪个方法进行代理</p></li></ol><p>方法的代理涉及到通知类型，有前置通知，后置通知，异常通知，最终通知，环绕通知</p><p>通知是注解的方式，用在方法上，注解参数是切入点表达式，切入点表达式指定哪些方法会被代理</p><p>环绕通知比较特别，它能传递参数，需要我们在方法体内执行代理方法，并返回，然后围绕这个方法执行做一些事，比如方法执行时间计算</p><p>其它通知都不能传递参数(是不是一定不能传未知，因为大部分都是用环绕通知)</p><h3 id="相关注解"><a href="#相关注解" class="headerlink" title="相关注解"></a>相关注解</h3><ol><li>@Aspect    </li></ol><p>指定一个类为切面类</p><ol start="2"><li>@Pointcut(“execution( cn.itcast.e_aop_anno..(..))”)  </li></ol><p>指定切入点表达式，把这个注解运用到方法上。这样通知注解就不用写切入点表达式了，方法没有方法体</p><ol start="3"><li>@Before(“pointCut_()”)                </li></ol><p>前置通知: 目标方法之前执行，这里的参数就是被@Pointcut注解的方法</p><ol start="4"><li>@After(“pointCut_()”)                </li></ol><p>后置通知: 目标方法之后执行（始终执行）</p><ol start="5"><li>@AfterReturning(“pointCut_()”)            </li></ol><p>返回后通知: 执行方法结束前执行(异常不执行)</p><ol start="6"><li>@AfterThrowing(“pointCut_()”)    </li></ol><p>异常通知: 出现异常时候执行</p><ol start="7"><li>@Around(“pointCut_()”)                </li></ol><p>环绕通知: 环绕目标方法执行</p><h3 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h3><p><code>execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?)</code></p><p>符号讲解：</p><p>?号代表0或1，可以不写<br>“*”号代表任意类型，0或多<br>方法参数为..表示为可变参数</p><p>参数讲解：</p><ol><li>modifiers-pattern?【修饰的类型，可以不写】</li></ol><p>这个修饰类型有很多种，一般用execution，</p><p>还有@annotation，表明使用这个注解的方法会被代理，还有this，within，具体看文档</p><ol start="2"><li><p>ret-type-pattern【方法返回值类型，必写】</p></li><li><p>declaring-type-pattern?【方法声明的类型，可以不写】</p></li><li><p>name-pattern(param-pattern)【要匹配的名称，括号里面是方法的参数】</p></li><li><p>throws-pattern?【方法抛出的异常类型，可以不写】</p></li></ol><p>由于很多可以不写，而且这个表达式又长，不必特意记住，有个印象，具体用法查文档吧</p><p>举例</p><pre class="line-numbers language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 【拦截所有<span class="token keyword">public</span>方法】 <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span><span class="token operator">&lt;</span>aop<span class="token operator">:</span>pointcut expression<span class="token operator">=</span><span class="token string">"execution(public * *(..))"</span> id<span class="token operator">=</span><span class="token string">"pt"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 【拦截所有save开头的方法 】 <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span><span class="token operator">&lt;</span>aop<span class="token operator">:</span>pointcut expression<span class="token operator">=</span><span class="token string">"execution(* save*(..))"</span> id<span class="token operator">=</span><span class="token string">"pt"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 【拦截指定类的指定方法<span class="token punctuation">,</span> 拦截时候一定要定位到方法】 <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span><span class="token operator">&lt;</span>aop<span class="token operator">:</span>pointcut expression<span class="token operator">=</span><span class="token string">"execution(public * cn.itcast.g_pointcut.OrderDao.save(..))"</span> id<span class="token operator">=</span><span class="token string">"pt"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 【拦截指定类的所有方法】 <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span><span class="token operator">&lt;</span>aop<span class="token operator">:</span>pointcut expression<span class="token operator">=</span><span class="token string">"execution(* cn.itcast.g_pointcut.UserDao.*(..))"</span> id<span class="token operator">=</span><span class="token string">"pt"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 【拦截指定包，以及其自包下所有类的所有方法】 <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span><span class="token operator">&lt;</span>aop<span class="token operator">:</span>pointcut expression<span class="token operator">=</span><span class="token string">"execution(* cn..*.*(..))"</span> id<span class="token operator">=</span><span class="token string">"pt"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 【多个表达式】 <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span><span class="token operator">&lt;</span>aop<span class="token operator">:</span>pointcut expression<span class="token operator">=</span><span class="token string">"execution(* cn.itcast.g_pointcut.UserDao.save()) || execution(* cn.itcast.g_pointcut.OrderDao.save())"</span> id<span class="token operator">=</span><span class="token string">"pt"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span><span class="token operator">&lt;</span>aop<span class="token operator">:</span>pointcut expression<span class="token operator">=</span><span class="token string">"execution(* cn.itcast.g_pointcut.UserDao.save()) or execution(* cn.itcast.g_pointcut.OrderDao.save())"</span> id<span class="token operator">=</span><span class="token string">"pt"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 下面<span class="token number">2</span>个且关系的，没有意义 <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span><span class="token operator">&lt;</span>aop<span class="token operator">:</span>pointcut expression<span class="token operator">=</span><span class="token string">"execution(* cn.itcast.g_pointcut.UserDao.save()) &amp;amp;&amp;amp; execution(* cn.itcast.g_pointcut.OrderDao.save())"</span> id<span class="token operator">=</span><span class="token string">"pt"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span><span class="token operator">&lt;</span>aop<span class="token operator">:</span>pointcut expression<span class="token operator">=</span><span class="token string">"execution(* cn.itcast.g_pointcut.UserDao.save()) and execution(* cn.itcast.g_pointcut.OrderDao.save())"</span> id<span class="token operator">=</span><span class="token string">"pt"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 【取非值】 <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span><span class="token operator">&lt;</span>aop<span class="token operator">:</span>pointcut expression<span class="token operator">=</span><span class="token string">"!execution(* cn.itcast.g_pointcut.OrderDao.save())"</span> id<span class="token operator">=</span><span class="token string">"pt"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">--</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更多内容参考 官方文档: <a href="https://docs.spring.io/spring/docs/5.2.5.RELEASE/spring-framework-reference/core.html#aop-pointcuts-examples" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/5.2.5.RELEASE/spring-framework-reference/core.html#aop-pointcuts-examples</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Redis</title>
      <link href="/2018/04/05/Java/java-redis/"/>
      <url>/2018/04/05/Java/java-redis/</url>
      
        <content type="html"><![CDATA[<h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><p>Jedis：是Redis的Java实现客户端，提供了比较全面的Redis命令的支持，</p><p>Redisson：实现了分布式和可扩展的Java数据结构。</p><p>Lettuce：高级Redis客户端，用于线程安全同步，异步和响应使用，支持集群，Sentinel，管道和编码器。</p><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><p>Jedis：比较全面的提供了Redis的操作特性</p><p>Redisson：促使使用者对Redis的关注分离，提供很多分布式相关操作服务，例如，分布式锁，分布式集合，可通过Redis支持延迟队列</p><p>Lettuce：主要在一些分布式缓存框架上使用比较多</p><h2 id="可伸缩："><a href="#可伸缩：" class="headerlink" title="可伸缩："></a>可伸缩：</h2><p>Jedis：使用阻塞的I/O，且其方法调用都是同步的，程序流需要等到sockets处理完I/O才能执行，不支持异步。Jedis客户端实例不是线程安全的，所以需要通过连接池来使用Jedis。</p><p>Redisson：基于Netty框架的事件驱动的通信层，其方法调用是异步的。Redisson的API是线程安全的，所以可以操作单个Redisson连接来完成各种操作</p><p>Lettuce：基于Netty框架的事件驱动的通信层，其方法调用是异步的。Lettuce的API是线程安全的，所以可以操作单个Lettuce连接来完成各种操作</p><h2 id="redis的数据类型"><a href="#redis的数据类型" class="headerlink" title="redis的数据类型"></a>redis的数据类型</h2><p>总共5种</p><ol><li><p>String</p></li><li><p>hash</p></li></ol><p>hset key filed value 设置值<br>hget key filed 　获取值</p><p>相当于一个key对应一个map</p><ol start="3"><li>list</li></ol><p>链表(双向链表)，增删快，提供了操作某一段元素的API。适用于：最新消息排行等功能；消息队列</p><ol start="4"><li>set</li></ol><p>集合。哈希表实现，元素不重复，为集合提供了求交集、并集、差集等操作。适用于：共同好友；利用唯一性，统计访问网站的所有独立ip；&gt; 好友推荐时，根据tag求交集，大于某个阈值就可以推荐</p><ol start="5"><li>sorted set</li></ol><p>有序集合。将Set中的元素增加一个权重参数score，元素按score有序排列。数据插入集合时，已经进行天然排序。适用于：排行榜；带权重的消息队列</p><p>其它类型:</p><p>bitmap：更细化的一种操作，以bit为单位<br>hyperloglog：基于概率的数据结构<br>Geo：地理位置信息储存起来，并对这些信息进行操作</p><h2 id="StringRedisTemplate与RedisTemplate的区别"><a href="#StringRedisTemplate与RedisTemplate的区别" class="headerlink" title="StringRedisTemplate与RedisTemplate的区别?"></a>StringRedisTemplate与RedisTemplate的区别?</h2><p>两者的关系是StringRedisTemplate继承RedisTemplate。</p><p>两者的数据是不共通的；也就是说StringRedisTemplate只能管理StringRedisTemplate里面的数据<br>RedisTemplate只能管RedisTemplate中的数据。</p><p>SDR默认采用的序列化策略有两种，一种是String的序列化策略，一种是JDK的序列化策略。<br>StringRedisTemplate默认采用的是String的序列化策略，保存的key和value都是采用此策略序列化保存的。<br>RedisTemplate默认采用的是JDK的序列化策略，保存的key和value都是采用此策略序列化保存的。</p><p>总结：<br>当你的redis数据库里面本来存的是字符串数据或者你要存取的数据就是字符串类型数据的时候，那么你就使用StringRedisTemplate即可，但是如果你的数据是复杂的对象类型，而取出的时候又不想做任何的数据转换，直接从Redis里面取出一个对象，那么使用RedisTemplate是更好选择</p><h2 id="各个序列化类"><a href="#各个序列化类" class="headerlink" title="各个序列化类"></a>各个序列化类</h2><p>当我们的数据存储到Redis的时候，我们的键（key）和值（value）都是通过Spring提供的Serializer序列化到数据库的。RedisTemplate默认使用的是JdkSerializationRedisSerializer，StringRedisTemplate默认使用的是StringRedisSerializer。</p><p>Spring Data JPA为我们提供了下面的Serializer：GenericToStringSerializer、Jackson2JsonRedisSerializer、JacksonJsonRedisSerializer、JdkSerializationRedisSerializer、OxmSerializer、StringRedisSerializer。</p><p>序列化方式对比：</p><ul><li><p>JdkSerializationRedisSerializer: 使用JDK提供的序列化功能。 优点是反序列化时不需要提供类型信息(class)，但缺点是需要实现Serializable接口，还有序列化后的结果非常庞大，是JSON格式的5倍左右，这样就会消耗redis服务器的大量内存。</p></li><li><p>Jackson2JsonRedisSerializer： 使用Jackson库将对象序列化为JSON字符串。优点是速度快，序列化后的字符串短小精悍，不需要实现Serializable接口。但缺点也非常致命，那就是此类的构造函数中有一个类型参数，必须提供要序列化对象的类型信息(.class对象)。 通过查看源代码，发现其只在反序列化过程中用到了类型信息。 </p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java工具类整理</title>
      <link href="/2018/04/05/Java/util/"/>
      <url>/2018/04/05/Java/util/</url>
      
        <content type="html"><![CDATA[<p>Java工具类整理，收集和整理的Java相关工具类，大部分来源网络，不过我都测试过了，哈哈</p><h2 id="Byte-与hex互相转换，用在某些数据传输场景下"><a href="#Byte-与hex互相转换，用在某些数据传输场景下" class="headerlink" title="Byte[]与hex互相转换，用在某些数据传输场景下"></a>Byte[]与hex互相转换，用在某些数据传输场景下</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Byte[]与hex的相互转换 * @explain * @author Marydon * @creationTime 2018年6月11日下午2:29:11 * @version 1.0 * @since * @email marydon20170307@163.com */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ByteUtils</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 16进制字符</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> HEX_CHAR <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">'0'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'5'</span><span class="token punctuation">,</span> <span class="token string">'6'</span><span class="token punctuation">,</span> <span class="token string">'7'</span><span class="token punctuation">,</span> <span class="token string">'8'</span><span class="token punctuation">,</span> <span class="token string">'9'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'f'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 方法一：将byte类型数组转化成16进制字符串 * @explain 字符串拼接 * @param bytes * @return */</span><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">toHexString</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>    StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">byte</span> b <span class="token operator">:</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>        num <span class="token operator">=</span> b <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">256</span> <span class="token operator">+</span> b <span class="token operator">:</span> b<span class="token punctuation">;</span>        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>HEX_CHAR<span class="token punctuation">[</span>num <span class="token operator">/</span> <span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>HEX_CHAR<span class="token punctuation">[</span>num <span class="token operator">%</span> <span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 方法二： byte[] to hex string * @explain 使用数组 * @param bytes * @return */</span><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">toHexString2</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 一个byte为8位，可用两个十六进制位表示</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span>bytes<span class="token punctuation">.</span>length <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 使用除与取余进行转换</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">byte</span> b <span class="token operator">:</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            a <span class="token operator">=</span> <span class="token number">256</span> <span class="token operator">+</span> b<span class="token punctuation">;</span>        <span class="token keyword">else</span>            a <span class="token operator">=</span> b<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 偶数位用商表示</span>        buf<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> HEX_CHAR<span class="token punctuation">[</span>a <span class="token operator">/</span> <span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 奇数位用余数表示</span>        buf<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> HEX_CHAR<span class="token punctuation">[</span>a <span class="token operator">%</span> <span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// char[]-->String</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 方法三： byte[]-->hexString * @explain 使用位运算 * @param bytes * @return */</span><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">toHexString3</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span>bytes<span class="token punctuation">.</span>length <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 利用位运算进行转换，可以看作方法二的变型</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">byte</span> b <span class="token operator">:</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>        buf<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> HEX_CHAR<span class="token punctuation">[</span>b <span class="token operator">>>></span> <span class="token number">4</span> <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        buf<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> HEX_CHAR<span class="token punctuation">[</span>b <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 方法四：byte[]-->hexString * @param bytes * @return */</span><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">toHexString4</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>    StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span>bytes<span class="token punctuation">.</span>length <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 使用String的format方法进行转换</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">byte</span> b <span class="token operator">:</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%02x"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>b <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/** * 将16进制字符串转换为byte[] * @explain 16进制字符串不区分大小写，返回的数组相同 * @param hexString *            16进制字符串 * @return byte[] */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">fromHexString</span><span class="token punctuation">(</span>String hexString<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">==</span> hexString <span class="token operator">||</span> <span class="token string">""</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>hexString<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>hexString<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 16进制字符串</span>    String hex<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> hexString<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 每次截取2位</span>        hex <span class="token operator">=</span> hexString<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 16进制-->十进制</span>        bytes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>hex<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> bytes<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原本程序</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Throwable<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>crypto<span class="token punctuation">.</span>Cipher<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>crypto<span class="token punctuation">.</span>spec<span class="token punctuation">.</span>IvParameterSpec<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>crypto<span class="token punctuation">.</span>spec<span class="token punctuation">.</span>SecretKeySpec<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>axis<span class="token punctuation">.</span>encoding<span class="token punctuation">.</span>Base64<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">aesEncryption</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String CYPHER_MODE <span class="token operator">=</span> <span class="token string">"AES/CBC/NoPadding"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">encrypt</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> key<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> initVector<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            IvParameterSpec iv <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IvParameterSpec</span><span class="token punctuation">(</span>initVector<span class="token punctuation">)</span><span class="token punctuation">;</span>            SecretKeySpec skeySpec <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SecretKeySpec</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">"AES"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Cipher cipher <span class="token operator">=</span> Cipher<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>CYPHER_MODE<span class="token punctuation">)</span><span class="token punctuation">;</span>            cipher<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>Cipher<span class="token punctuation">.</span>ENCRYPT_MODE<span class="token punctuation">,</span> skeySpec<span class="token punctuation">,</span> iv<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> blockSize <span class="token operator">=</span> cipher<span class="token punctuation">.</span><span class="token function">getBlockSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> plaintext <span class="token operator">=</span> <span class="token function">padding</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> blockSize<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> cipher<span class="token punctuation">.</span><span class="token function">doFinal</span><span class="token punctuation">(</span>plaintext<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ex<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">decrypt</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> key<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> initVector<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> encrypted<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            IvParameterSpec iv <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IvParameterSpec</span><span class="token punctuation">(</span>initVector<span class="token punctuation">)</span><span class="token punctuation">;</span>            SecretKeySpec skeySpec <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SecretKeySpec</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">"AES"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Cipher cipher <span class="token operator">=</span> Cipher<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>CYPHER_MODE<span class="token punctuation">)</span><span class="token punctuation">;</span>            cipher<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>Cipher<span class="token punctuation">.</span>DECRYPT_MODE<span class="token punctuation">,</span> skeySpec<span class="token punctuation">,</span> iv<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token function">unpadding</span><span class="token punctuation">(</span>cipher<span class="token punctuation">.</span><span class="token function">doFinal</span><span class="token punctuation">(</span>encrypted<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ex<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">padding</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">,</span> <span class="token keyword">int</span> blockSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> plaintextLength <span class="token operator">=</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>plaintextLength <span class="token operator">%</span> blockSize <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            plaintextLength <span class="token operator">=</span> plaintextLength <span class="token operator">+</span> <span class="token punctuation">(</span>blockSize <span class="token operator">-</span> <span class="token punctuation">(</span>plaintextLength <span class="token operator">%</span> blockSize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> plaintext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>plaintextLength<span class="token punctuation">]</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> plaintext<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> value<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> plaintext<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">unpadding</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> bytes<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> bytes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token operator">--</span>i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> key <span class="token operator">=</span> <span class="token string">"keyskeyskeyskeys"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> iv <span class="token operator">=</span> <span class="token string">"keyskeyskeyskeys"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> content <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cyphertext <span class="token operator">=</span> <span class="token function">encrypt</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> iv<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>            String b64 <span class="token operator">=</span> Base64<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>cyphertext<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b64<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> de_b64 <span class="token operator">=</span> <span class="token function">decrypt</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> iv<span class="token punctuation">,</span> Base64<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>b64<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String plaintext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>de_b64<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>plaintext<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>            t<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Cipher <span class="token keyword">import</span> AES<span class="token keyword">import</span> base64<span class="token keyword">class</span> <span class="token class-name">AESEncrypt</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> iv<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>key <span class="token operator">=</span> key        self<span class="token punctuation">.</span>iv <span class="token operator">=</span> iv        self<span class="token punctuation">.</span>mode <span class="token operator">=</span> AES<span class="token punctuation">.</span>MODE_CBC    <span class="token keyword">def</span> <span class="token function">encrypt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">:</span>        cryptor <span class="token operator">=</span> AES<span class="token punctuation">.</span>new<span class="token punctuation">(</span>self<span class="token punctuation">.</span>key<span class="token punctuation">,</span> self<span class="token punctuation">.</span>mode<span class="token punctuation">,</span> self<span class="token punctuation">.</span>key<span class="token punctuation">)</span>        length <span class="token operator">=</span> AES<span class="token punctuation">.</span>block_size        text_pad <span class="token operator">=</span> self<span class="token punctuation">.</span>padding<span class="token punctuation">(</span>length<span class="token punctuation">,</span> text<span class="token punctuation">)</span>        ciphertext <span class="token operator">=</span> cryptor<span class="token punctuation">.</span>encrypt<span class="token punctuation">(</span>text_pad<span class="token punctuation">)</span>        cryptedStr <span class="token operator">=</span> str<span class="token punctuation">(</span>base64<span class="token punctuation">.</span>b64encode<span class="token punctuation">(</span>ciphertext<span class="token punctuation">)</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> cryptedStr    <span class="token keyword">def</span> <span class="token function">padding</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> length<span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">:</span>        count <span class="token operator">=</span> len<span class="token punctuation">(</span>text<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> count <span class="token operator">%</span> length <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>            add <span class="token operator">=</span> length <span class="token operator">-</span> <span class="token punctuation">(</span>count <span class="token operator">%</span> length<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            add <span class="token operator">=</span> <span class="token number">0</span>        text1 <span class="token operator">=</span> text <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token string">'\0'</span> <span class="token operator">*</span> add<span class="token punctuation">)</span>        <span class="token keyword">return</span> text1    <span class="token keyword">def</span> <span class="token function">decrypt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">:</span>        base_text <span class="token operator">=</span> base64<span class="token punctuation">.</span>b64decode<span class="token punctuation">(</span>text<span class="token punctuation">)</span>        cryptor <span class="token operator">=</span> AES<span class="token punctuation">.</span>new<span class="token punctuation">(</span>self<span class="token punctuation">.</span>key<span class="token punctuation">,</span> self<span class="token punctuation">.</span>mode<span class="token punctuation">,</span> self<span class="token punctuation">.</span>key<span class="token punctuation">)</span>        plain_text <span class="token operator">=</span> cryptor<span class="token punctuation">.</span>decrypt<span class="token punctuation">(</span>base_text<span class="token punctuation">)</span>        ne <span class="token operator">=</span> plain_text<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token string">'\0'</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> ne<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    aes_encrypt <span class="token operator">=</span> AESEncrypt<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token string">'keyskeyskeyskeys'</span><span class="token punctuation">,</span> iv<span class="token operator">=</span><span class="token string">"keyskeyskeyskeys"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 初始化key和IV</span>    text <span class="token operator">=</span> <span class="token string">'123'</span>    sign_data <span class="token operator">=</span> aes_encrypt<span class="token punctuation">.</span>encrypt<span class="token punctuation">(</span>text<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>sign_data<span class="token punctuation">)</span>    data <span class="token operator">=</span> aes_encrypt<span class="token punctuation">.</span>decrypt<span class="token punctuation">(</span>sign_data<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="通过反射操作对象私有方法和私有变量"><a href="#通过反射操作对象私有方法和私有变量" class="headerlink" title="通过反射操作对象私有方法和私有变量"></a>通过反射操作对象私有方法和私有变量</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReflectionUtils</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 获取私有成员变量的值     * @param instance     * @param filedName     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Object <span class="token function">getPrivateField</span><span class="token punctuation">(</span>Object instance<span class="token punctuation">,</span> String filedName<span class="token punctuation">)</span> <span class="token keyword">throws</span> NoSuchFieldException<span class="token punctuation">,</span> IllegalAccessException <span class="token punctuation">{</span>        Field field <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span>filedName<span class="token punctuation">)</span><span class="token punctuation">;</span>        field<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> field<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 设置私有成员的值     * @param instance     * @param fieldName     * @param value     * @throws NoSuchFieldException     * @throws IllegalAccessException     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setPrivateField</span><span class="token punctuation">(</span>Object instance<span class="token punctuation">,</span> String fieldName<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span> <span class="token keyword">throws</span> NoSuchFieldException<span class="token punctuation">,</span> IllegalAccessException <span class="token punctuation">{</span>        Field field <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span>fieldName<span class="token punctuation">)</span><span class="token punctuation">;</span>        field<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        field<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 访问私有方法     * @param instance     * @param methodName     * @param classes     * @param objects     * @return     * @throws NoSuchMethodException     * @throws InvocationTargetException     * @throws IllegalAccessException     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Object <span class="token function">invokePrivateMethod</span><span class="token punctuation">(</span>Object instance<span class="token punctuation">,</span> String methodName<span class="token punctuation">,</span> Class<span class="token punctuation">[</span><span class="token punctuation">]</span> classes<span class="token punctuation">,</span> String objects<span class="token punctuation">)</span> <span class="token keyword">throws</span> NoSuchMethodException<span class="token punctuation">,</span> InvocationTargetException<span class="token punctuation">,</span> IllegalAccessException <span class="token punctuation">{</span>        Method method <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span>methodName<span class="token punctuation">,</span> classes<span class="token punctuation">)</span><span class="token punctuation">;</span>        method<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> objects<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="restTemplate-响应泛型"><a href="#restTemplate-响应泛型" class="headerlink" title="restTemplate 响应泛型"></a>restTemplate 响应泛型</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token punctuation">,</span> A<span class="token operator">></span> T <span class="token function">exchange</span><span class="token punctuation">(</span>String url<span class="token punctuation">,</span> HttpMethod method<span class="token punctuation">,</span> ParameterizedTypeReference<span class="token operator">&lt;</span>T<span class="token operator">></span> responseBodyType<span class="token punctuation">,</span> A requestBody<span class="token punctuation">)</span> <span class="token punctuation">{</span>        RestTemplate restTemplate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 请求头</span>        HttpHeaders headers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HttpHeaders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        MimeType mimeType <span class="token operator">=</span> MimeTypeUtils<span class="token punctuation">.</span><span class="token function">parseMimeType</span><span class="token punctuation">(</span><span class="token string">"application/json"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        MediaType mediaType <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MediaType</span><span class="token punctuation">(</span>mimeType<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mimeType<span class="token punctuation">.</span><span class="token function">getSubtype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> StandardCharsets<span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 请求体</span>        headers<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span>mediaType<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 发送请求</span>        HttpEntity<span class="token operator">&lt;</span>A<span class="token operator">></span> entity <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HttpEntity</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>requestBody<span class="token punctuation">,</span> headers<span class="token punctuation">)</span><span class="token punctuation">;</span>        ResponseEntity<span class="token operator">&lt;</span>T<span class="token operator">></span> resultEntity <span class="token operator">=</span> restTemplate<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> method<span class="token punctuation">,</span> entity<span class="token punctuation">,</span> responseBodyType<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> resultEntity<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 调用</span>ParameterizedTypeReference<span class="token operator">&lt;</span>ResponseBean<span class="token operator">&lt;</span>BasePushData<span class="token operator">>></span> responseBodyType <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ParameterizedTypeReference</span><span class="token operator">&lt;</span>ResponseBean<span class="token operator">&lt;</span>BasePushData<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        String res = restTemplate.postForObject("http://localhost:8920/store", basePushData, String.class);</span>        ResponseBean<span class="token operator">&lt;</span>BasePushData<span class="token operator">></span> ret <span class="token operator">=</span> <span class="token function">exchange</span><span class="token punctuation">(</span><span class="token string">"http://localhost:8920/store"</span><span class="token punctuation">,</span> HttpMethod<span class="token punctuation">.</span>POST<span class="token punctuation">,</span> responseBodyType<span class="token punctuation">,</span> basePushData<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习笔记</title>
      <link href="/2018/01/05/Java/base/"/>
      <url>/2018/01/05/Java/base/</url>
      
        <content type="html"><![CDATA[<p>Java 学习笔记，Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程</p><p><img src="/images/Java/Java-base.jpg" alt="image"></p><a id="more"></a><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>大部分都是通用的，或者是设计模式，只是第一次接触难免有些生疏晦涩。</p><p>构件：其实就是组件，可以按照组件来理解，不过在这个范畴内一般翻译为构件</p><p>DAO：数据库访问模型 Data Access Object</p><p>DTO：数据传输对象（DTO)(Data Transfer Object)，是一种设计模式之间传输数据的软件应用系统。数据传输目标往往是数据访问对象从数据库中检索数据。数据传输对象与数据交互对象或数据访问对象之间的差异是一个以不具有任何行为除了存储和检索的数据（访问和存取器）。</p><p>Bean：它的定义为，描述Java的软件组件模型，EJB是Enterprise Java Bean的缩写。javaBean在MVC设计模型中是model，又称模型层，在一般的程序中，我们称它为数据层，就是用来设置数据的属性和一些行为，然后我会提供获取属性和设置属性的get/set方法JavaBean是一种JAVA语言写成的可重用组件。</p><p>JDBC（Java DataBase Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序，同时，JDBC也是个商标名。</p><p>JPA是Java Persistence API的简称，中文名Java持久层API，是JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。<br>Sun引入新的JPA ORM规范出于两个原因：其一，简化现有Java EE和Java SE应用开发工作；其二，Sun希望整合ORM技术，实现天下归一。</p><p>JNDI(Java Naming and Directory Interface,Java命名和目录接口)是SUN公司提供的一种标准的Java命名系统接口，JNDI提供统一的客户端API，通过不同的访问提供者接口JNDI服务供应接口(SPI)的实现，由管理者将JNDI API映射为特定的命名服务和目录系统，使得Java应用程序可以和这些命名服务和目录服务之间进行交互。</p><ul><li><p>PO：persistent object 持久对象<br>1 ．有时也被称为Data对象，对应数据库中的entity，可以简单认为一个PO对应数据库中的一条记录<br>2 ．在hibernate持久化框架中与insert/delet操作密切相关<br>3 ．PO中不应该包含任何对数据库的操作</p></li><li><p>POJO ：plain ordinary java object 无规则简单java对象<br>一个中间对象，可以转化为PO、DTO、VO</p></li></ul><p>1 ．POJO持久化之后==〉PO<br>（在运行期，由Hibernate中的cglib动态把POJO转换为PO，PO相对于POJO会增加一些用来管理数据库entity状态的属性和方法。PO对于programmer来说完全透明，由于是运行期生成PO，所以可以支持增量编译，增量调试）<br>2 ．POJO传输过程中==〉DTO<br>3 ．POJO用作表示层==〉VO</p><p>PO 和VO都应该属于它</p><ul><li>BO：business object 业务对象<br>业务对象主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象</li></ul><p>比如一个简历，有教育经历、工作经历、社会关系等等。我们可以把教育经历对应一个PO，工作经历对应一个PO，社会关系对应一个PO<br>建立一个对应简历的BO对象处理简历，每个BO包含这些PO</p><p>这样处理业务逻辑时，我们就可以针对BO去处理<br>封装业务逻辑为一个对象（可以包括多个PO，通常需要将BO转化成PO，才能进行数据的持久化，反之，从DB中得到的PO，需要转化成BO才能在业务层使用）</p><p>关于BO主要有三种概念</p><p>1 、只包含业务对象的属性<br>2 、只包含业务方法<br>3 、两者都包含</p><p>在实际使用中，认为哪一种概念正确并不重要，关键是实际应用中适合自己项目的需要</p><ul><li>VO：value object 值对象 / view object 表现层对象</li></ul><p>1 ．主要对应页面显示（web页面/swt、swing界面）的数据对象<br>2 ．可以和表对应，也可以不，这根据业务的需要</p><ul><li>DTO（TO）：Data Transfer Object 数据传输对象</li></ul><p>1 ．用在需要跨进程或远程传输时，它不应该包含业务逻辑<br>2 ．比如一张表有100个字段，那么对应的PO就有100个属性（大多数情况下，DTO内的数据来自多个表）。但view层只需显示10个字段，没有必要把整个PO对象传递到client，这时我们就可以用只有这10个属性的DTO来传输数据到client，这样也不会暴露server端表结构。到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO</p><ul><li>DAO：data access object数据访问对象</li></ul><p>1 ．主要用来封装对DB的访问（CRUD操作）<br>2 ．通过接收Business层的数据，把POJO持久化为PO</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>配置环境变量，保证 java javac java -version 都能输出正确信息</p><h2 id="classpath路径"><a href="#classpath路径" class="headerlink" title="classpath路径"></a>classpath路径</h2><p>Java项目中classpath路径<br>1、src不是classpath, WEB-INF/classes、lib、resources才是classpath，WEB-INF/是资源目录, 客户端不能直接访问。</p><p>2、WEB-INF/classes目录存放src目录java文件编译之后的class文件，xml、properties等资源配置文件，这是一个定位资源的入口。</p><p>3、引用classpath路径下的文件，只需在文件名前加classpath:<br><code>&lt;property name="configLocation" value="classpath:/mybatis/mybatis-config.xml" /&gt;</code><br>4、lib和classes同属classpath，两者的访问优先级为: lib&gt;classes。</p><p>5、classpath 和 classpath* 区别：<br>classpath：只会到你的class路径中查找找文件;<br>classpath*：不仅包含class路径，还包括jar文件中(class路径)进行查找。</p><h2 id="关于版本"><a href="#关于版本" class="headerlink" title="关于版本"></a>关于版本</h2><p>你肯定听说过<br>Java SE（Java Platform，Standard Edition）<br>Java EE（Java Platform，Enterprise Edition）<br>Java ME（Java Platform，Micro Edition）</p><p>服务端开发，要用java ee，其实只要下载jdk就行了，jdk(Java SE Development Kit 8 Downloads) Java开发工具包，包含了jre(Java运行时环境，如果只是跑代码，只需要jre就可以了)</p><p>JDK与Java SE/EE/ME的区别</p><p>jdk是不区分se、ee、me的，所以你在oracle的官网上只要下载java se对应的版本jdk即可，你可能会奇怪，不是ee才是企业级开发吗？为什么下载jdk就可以了？</p><p>参考引文 <a href="http://javaligang.blog.51cto.com/5026500/1825681" target="_blank" rel="noopener">http://javaligang.blog.51cto.com/5026500/1825681</a></p><p>Java刚开始的时候，因为各种应用和生态不成熟，很多东西需要有人牵头制定强制规范引导Java的发展，于是Java EE曾经引领了企业级应用的开发。</p><p>但随着时代的进步，以及越来越多的公司和组织参与到Java世界，出现了各种各样的Java EE组件的代替者，比如Hibernate、Spring就是其中两个典型。相反，Java官方制定的各种Java EE规范反而不太受欢迎，他们制定了JSF规范，但实际企业开发喜欢用Struts 2、Spring MVC；他们制定了EJB规范，但实际企业开发往往还是喜欢用Spring；他们制定了JPA规范，但实际企业开发往往还是喜欢直接用Hibernate、MyBatis。</p><p>现代企业级应用常用的各种框架和工具，比如Struts 2、Spring、Hibernate、jBPM、Activiti、Lucene、Hadoop、Drools、CXF等这些大家耳熟能详的组件，全部都不是来自Oracle官方，但是却在企业应用中开发经常用到的。</p><p>现在企业里面，真正常用的JavaEE规范有什么？Servlet、JSP、JMS、JNDI。这些技术都只是充当了一个程序的入口而已。</p><p>Oracle之所以可能考虑放弃Java EE，正体现了Oracle对丧失Java控制权的无奈。企业的本质是逐利，Oracle每年为制定Java EE规范投入不少人力、财力，但制定的规范最终并没有获得市场的青睐，所以Oracle可能放弃这种吃亏不讨好的事情。</p><p>但Java不同，2016年6月，Java在商业语言排行榜上的市场份额将近21%，庞大到恐怖的市场份额，背后隐藏着巨大各种专利使用费和盈利商机，任何一个理智的公司都不会放弃这个会下金蛋的母鸡。</p><p>由此可见，oracle上提供的java EE是官方指定的javaEE规范，里面都是符合官方指定的javaEE组件，我们用SSM，SSH开发后台时使用到的只有Servlet、JSP、JMS等少量的java EE规范，没有必要使用orcale提供的java EE版本，直接使用jdk就可以（当然还需要maven等管理第三方的jar包来实现功能）</p><p>有时会有这样的一个说法，选择jdk1.x的版本还是jdk8的版本这样的，jdk1.x的说法是很多年前遗留下来的说法，而现在我们统称的叫法是jdk8这样子。</p><h2 id="Oracle-jdk-和-Open-jdk"><a href="#Oracle-jdk-和-Open-jdk" class="headerlink" title="Oracle jdk 和 Open jdk"></a>Oracle jdk 和 Open jdk</h2><p>java -version</p><p>(1) 如果是SUN/OracleJDK, 显示信息为:</p><p>[root@localhost ~]# java -version<br>java version “1.8.0_162”<br>Java(TM) SE Runtime Environment (build 1.8.0_162-b12)<br>Java HotSpot(TM) 64-Bit Server VM (build 25.162-b12, mixed mode)</p><p>Java HotSpot(TM) 64-Bit Server VM 表明, 此JDK的JVM是Oracle的64位HotSpot虚拟机, 运行在Server模式下(虚拟机有Server和Client两种运行模式).<br>Java(TM) SE Runtime Environment (build 1.8.0_162-b12) 是Java运行时环境(即JRE)的版本信息.</p><p>(2) 如果OpenJDK, 显示信息为:</p><p>[root@localhost ~]# java -version<br>openjdk version “1.8.0_144”<br>OpenJDK Runtime Environment (build 1.8.0_144-b01)<br>OpenJDK 64-Bit Server VM (build 25.144-b01, mixed mode)</p><h2 id="对象与类"><a href="#对象与类" class="headerlink" title="对象与类"></a>对象与类</h2><p>Java是一门面向对象很强的语言</p><h3 id="基本特点"><a href="#基本特点" class="headerlink" title="基本特点"></a>基本特点</h3><p>return 只能返回一个对象，python可以返回多个，面向对象体现更明显，强类型<br>面向对象部分是Java核心和难点部分，不过语言还是要在实践中学习，而实践又会用框架，等代码感熟练了，慢慢的去看源码的时候，再来体会面向对象更容易掌握，初期可以跳过繁琐的概念，因为看了也记不住。<br>面向对象集中在7，8，9，10章节(Java编程思想)，有其它语言的基础可以快速过一遍，先理解11章后的内容</p><p>对象成员不进行初始化会设定默认值(原始类型才这样，引用类型都是null)，不过对于局部变量不适用，也就是在方法内的变量都必须初始化。</p><p>面向对象：字段或数据成员，方法，Python中叫做属性。</p><p>方法签名，可能在Python中不怎么提及这个概念，由于Java是静态语言，所以方法签名唯一确定方法。</p><p>java.lang 是一个类库，每个Java文件都会默认导入它。</p><p>main() 方法的参数是一个String对象的数组，以及一个args，一般都要写这两个，否则编译器报错，因为args要用来存储命令行参数。</p><p>注释文档：javadoc是JDK安装的一部分，用于提取注释的工具。该工具提取注释，可以生产html文件。可以对工具输出风格做调整，通过编写自己的被称为 “doclets” 的javadoc处理器来实现。javadoc 有特定的语法。</p><p>所有的javadoc语法只能在 “/**  */” 注释中出现，“//” 是不可以的。</p><p>使用方式：嵌入HTML，使用文档标签。</p><h3 id="原始类型和封装类"><a href="#原始类型和封装类" class="headerlink" title="原始类型和封装类"></a>原始类型和封装类</h3><p>引用类型和原始类型（或内置类型）。比如:Int是java的原始数据类型，Integer是java为int提供的封装类</p><p>8种基本类型</p><p>整型：byte 8, short 16, int 32, long 64</p><p>字符型：char<br>char类型是一个单一的 16 位 Unicode 字符；<br>最小值是 \u0000（即为0）；<br>最大值是 \uffff（即为65,535）；<br>char 数据类型可以储存任何字符；<br>例子：char letter = ‘A’;。</p><p>浮点型：float 32, double 64<br>布尔型：boolean</p><p>  原始类型           封装类<br>  boolean           Boolean<br>  char              Character<br>  byte              Byte<br>  short             Short<br>  int               Integer<br>  long              Long<br>  float             Float<br>  double            Double  </p><p>引用类型和原始类型的区别:</p><ol><li>两者的初始化方式不同</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">// 原始类型</span>Integer j <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 对象引用  java 1.5以后支持自动装箱所以   Integer j = 10; 也可以</span><span class="token comment" spellcheck="true">// 使用原始类型无须调用 new，也无须创建对象。这节省了时间和空间。混合使用原始类型和对象也可能导致与赋值有关的意外结果。 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li>原始类型是类，引用类型是对象</li></ol><p>原始类型大小比较用”==”, 引用类型大小比较用”equals”</p><ol start="3"><li><p>引用类型可以被序列化，原始类型不行。</p></li><li><p>引用类型提供的方法可以灵活转换，可以扩展，原始类型不行</p></li><li><p>在集合类中只能使用引用类型，不能使用原始类型</p></li><li><p>原始类型没有null的概念，引用类型有，某些情况下需要辨别某个参数是否被初始化了，如果使用原始类型，那么0的值不知道是初始值还是没有初始化系统自动给的。</p></li><li><p>有些时候必须要用封装类</p></li></ol><p>比如你要用request.setAttribute(String key ,Object value);这个方法时，第二个参数为Object类型，而你要放的是一个整数的时候，那就只能放Integer不能放int。</p><p>总结:</p><p>原始类型和封装类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为null，而原始类型实例变量的缺省值与它们的类型有关。</p><p>int(原始类型)   一般做为数值参数就够了<br>integer (封装类型)  一般做类型转换的时候用的较</p><h3 id="大数值"><a href="#大数值" class="headerlink" title="大数值"></a>大数值</h3><p>java.math中的 <code>BigInteger</code> 和 <code>BigDecimal</code> 可以处理包含任意长度数字序列的数值<br>BigInteger 任意精度的整数运算<br>BigDecimal 任意精度的浮点数运算</p><h3 id="算术运算的强制转换"><a href="#算术运算的强制转换" class="headerlink" title="算术运算的强制转换"></a>算术运算的强制转换</h3><p>直接常量可以添加标识符，使表达更加清晰<br>类型转换操作符 long i = (long) j  将整形j转换成长整形并赋值给i，转换总是截尾，要想四舍五入需要使用round库<br>提升：对基本类型执行按位运算或算术运算，只要类型比int小（比如char,byte,short），那么在运算之前，会自动转换成int。较大的数据类型决定了结果，比如double和float相乘，结果是double<br>sizeof：c,c++中用来计算数据占的字节，这导致移植代码很头疼，不同的处理器对数据存储所占的字节是不一样的，而Java不会这样，它的数据类型在所有机器上都是一样的</p><h3 id="初始化与清理"><a href="#初始化与清理" class="headerlink" title="初始化与清理"></a>初始化与清理</h3><p>构造器：构造器的命名和类名相同，可以带访问修饰符，不能有返回值。</p><p>方法重载：构造器也可以方法重载，方法重载要求函数名相同，参数不一样，参数的顺序不一样也是方法重载，但是一般不建议这么做。一般动态语言不需要方法重载。方法重载一定要写的明确，这样编译器在调用方法的时候才知道是调用哪个方法。</p><p>缺省构造器：构造器可以不提供，编译器默认创建一个，这个时候构造器没做任何事情</p><p>this关键字：通常不需要显示的写出它来，和python不一样，另外它是关键字</p><p>垃圾回收：</p><ol><li>对象可能不被垃圾回收 </li><li>垃圾回收并不等于析构</li></ol><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类是指在一个外部类的内部再定义一个类。内部类作为外部类的一个成员，并且依附于外部类而存在的。内部类可为静态，可用protected和private修饰（而外部类只能使用public和缺省的包访问权限）。内部类主要有以下几类：成员内部类、局部内部类、静态内部类、匿名内部类</p><p>内部类的共性:</p><ol><li><p>内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号</p></li><li><p>内部类不能用普通的方式访问</p></li><li><p>内部类声明成静态的，就不能随便的访问外部类的成员变量了，此时内部类只能访问外部类的静态成员变量</p></li><li><p>外部类不能直接访问内部类的的成员，但可以通过内部类对象来访问</p></li></ol><p>内部类是外部类的一个成员，因此内部类可以自由地访问外部类的成员变量，无论是否是private的。<br>因为当某个外围类的对象创建内部类的对象时，此内部类会捕获一个隐式引用，它引用了实例化该内部对象的外围类对象。通过这个指针，可以访问外围类对象的全部状态，主要是通过以下几步做到的:</p><p>1 编译器自动为内部类添加一个成员变量，这个成员变量的类型和外部类的类型相同， 这个成员变量就是指向外部类对象的引用</p><p>2 编译器自动为内部类的构造方法添加一个参数，参数的类型是外部类的类型， 在构造方法内部使用这个参数为1中添加的成员变量赋值</p><p>3 在调用内部类的构造函数初始化内部类对象时，会默认传入外部类的引用</p><p>那静态内部类与普通内部类有什么区别呢？<br>问得好，区别如下：</p><p>1 静态内部类不持有外部类的引用 在普通内部类中，我们可以直接访问外部类的属性、方法，即使是private类型也可以访问，这是因为内部类持有一个外部类的引用，可以自由访问。而静态内部类，则只可以访问外部类的静态方法和静态属性（如果是private权限也能访问，这是由其代码位置所决定的），其他则不能访问。</p><p>2 静态内部类不依赖外部类 普通内部类与外部类之间是相互依赖的关系，内部类实例不能脱离外部类实例，也就是说它们会同生同死，一起声明，一起被垃圾回收器回收。而静态内部类是可以独立存在的，即使外部类消亡了，静态内部类还是可以存在的。</p><p>3 普通内部类不能声明static的方法和变量 普通内部类不能声明static的方法和变量，注意这里说的是变量，常量（也就是final static修饰的属性）还是可以的，而静态内部类形似外部类，没有任何限制。</p><p>为什么普通内部类不能有静态变量呢？</p><p>1 成员内部类 之所以叫做成员 就是说他是类实例的一部分 而不是类的一部分</p><p>2 结构上来说 他和你声明的成员变量是一样的地位 一个特殊的成员变量 而静态的变量是类的一部分和实例无关</p><p>3 你若声明一个成员内部类 让他成为主类的实例一部分 然后又想在内部类声明和实例无关的静态的东西 你让JVM情何以堪啊</p><p>4 若想在内部类内声明静态字段 就必须将其内部类本身声明为静态</p><p>例子</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> interior<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Interior</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Integer a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>    Test test<span class="token punctuation">;</span>    <span class="token function">Interior</span><span class="token punctuation">(</span>Integer a<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Interior<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Test test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        test<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Interior integer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Interior</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        Test test = new Test(); 内部类依托于当前实例，不能在这里创建实例，如果是静态内部类就可以了</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>类之间的关系: 继承，接口实现，依赖，聚合，关联，直接关联</p><p>方法签名: 只有方法名，参数类型才能描述方法签名，不包含返回类型，所以不能定义两个返回类型不同方法名参数类型相同的方法</p><p>在构造器中调用this()将调用另外的构造器，根据参数来决定</p><p>this的常见用法：调用构造器，直接this()。调用方法，指代当前调用对象。由于大括号内封闭作用域，如果形参定义了和对象成员同名的属性，直接使用该名称无法取到对象成员，此时应该用this关键字。</p><p>静态块的初始化</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> nextId<span class="token punctuation">;</span><span class="token keyword">static</span><span class="token punctuation">{</span>    Random generator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    nextId <span class="token operator">=</span> generator<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a>finalize方法</h3><p>可以为类添加finalize方法，在垃圾回收器清除对象之前调用</p><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>补充一个知识点，静态导入: 可以导入静态方法和静态域 <code>import static java.lang.System.out;</code> 这样<code>out.println()</code>就能打印内容了</p><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>java后缀的源代码通常称为编译单元，每个编译单元内只能有一个public类。</p><p>代码组织：当编译一个java后缀文件时，文件的每个类都会生成.class文件。</p><p>关于package语句，必须是文件中除注释外的第一句代码。包命名规则全部使用小写字母，包括中间的字也是如此。导包用的星号如果两个包包含同一个类，那么这肯定是有问题的，但是只要不写调用的代码编译器是不会报错的，这种情况应该用完整路径来引用对象。</p><p>理解编译单元，默认包，friendly权限是java的默认权限，也称作包（package）访问权限</p><p>public private</p><ol><li><p>默认包：同一个包下的两个类，可以做到A类访问B类的未修饰方法，如果C类和A类不属于同一个包，那么C类的方法要修饰为public，A类才能访问到。这种默认的机制保护了包下的类，但是最好做修饰，在IDEA中，你不对类的方法做修饰，会有告警级别的提示，因为默认的包访问权限可以访问包，对不属于同一个包的访问做保护，但是最好考虑清楚，然后合理运用private。</p></li><li><p>另外即使使用了private修饰，仍然可以在当前类定义新的方法去访问private，所有不能因为在类中某个对象的引用是private，就认为其他的对象无法拥有该对象的public引用</p></li></ol><p>protected: 受保护的</p><p>一个类继承了另一个包中的类，那么唯一可访问的成员就是源包的public成员。（如果继承在同一个包中，就可以访问所有的拥有包访问权限的成员）。基类的创建者希望某个成员，把他的访问权限给予派生类而不是所有类，这时候就可以使用protected，protected也提供包访问权限，同一包内的其它类可以访问protected元素。这是为了在拥有包访问权限下，为了让跨包继承类也能访问的一种做法，否则就要用public来修饰。</p><p><code>访问权限的控制常被称为是具体实现的隐藏</code></p><p>类的访问权限：一个包下的类，要遵守他的文件名定义规则，然后只能有一个public类，可以把public去掉，这样该类就只有包访问权限，其它包即使导入他，也不能访问，通过也很少这么做。另外当不用public修饰类时，类命可以不和文件名一致。</p><p>再次强调，类前面不加修饰，权限就是包访问权限，当前包内的其它类可以访问，跨包不行。</p><h3 id="复用类"><a href="#复用类" class="headerlink" title="复用类"></a>复用类</h3><p>组合，继承，代理</p><p>如果子类的构造器没有显示地调用超类的构造器，则将自动地调用超类默认(没有参数)的构造器。如果超类没有不带参数的构造器，并且在子类的构造器中又没有显示地调用超类的其他构造器，则Java编译器报错。</p><p>每一个非基本类型对象都有一个toString方法，类似python的 <code>__str__</code></p><p>初始化，继承的基类初始化的时候，默认会调用基类的构造方法，构建过程是从基类“向外”扩散的，当然这只能调用默认不带参数的构造器，带参数的构造器需要显示的调用super方法。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Cleanser</span> <span class="token punctuation">{</span>    <span class="token function">Cleanser</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">Cleanser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Detergent</span> <span class="token keyword">extends</span> <span class="token class-name">Cleanser</span> <span class="token punctuation">{</span>    <span class="token function">Detergent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// super(321)</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Detergent x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Detergent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Testing base class"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果去掉Cleanser类的默认构造函数，IDEA会警告，因为找不到满足条件的构造函数，编译代码会去调用需要传递参数的构造函数导致报错。注释部分为显示调用。</p><p>名称屏蔽：如果Java的基类拥有某个已被多次重载的方法名称，那么在导出类中重新定义该方法名称并不会屏蔽在基类中的任何版本，这一点与C++不同<code>（如果C++要这么做需要屏蔽基类方法，另外本书比较旧了，不排除c++做了改动）</code></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Homer</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token function">doh</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"doh(char)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">'d'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">float</span> <span class="token function">doh</span><span class="token punctuation">(</span><span class="token keyword">float</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"doh(float)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1.0f</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Milhouse</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Bart</span> <span class="token keyword">extends</span> <span class="token class-name">Homer</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">doh</span><span class="token punctuation">(</span>Milhouse m<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"doh(Milhouse)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Hide</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Bart b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        b<span class="token punctuation">.</span><span class="token function">doh</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        b<span class="token punctuation">.</span><span class="token function">doh</span><span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        b<span class="token punctuation">.</span><span class="token function">doh</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        b<span class="token punctuation">.</span><span class="token function">doh</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Milhouse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// doh(float)</span><span class="token comment" spellcheck="true">// doh(char)</span><span class="token comment" spellcheck="true">// doh(float)</span><span class="token comment" spellcheck="true">// doh(Milhouse)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>向上转型：基类A，有一个方法，参数类型为A的引用，导出类B，调用A的方法，传递参数为B的实例，这似乎和强类型语言Java违背，但在继承中是可以的，你需要认识到B对象同样也是一种A对象，这种将B的引用转换为A的引用的动作，称为向上转型。父类引用变量可以引用子类对象。</p><p>final:</p><ol><li>允许空白final，但是在构造函数中必须进行初始化。</li><li>final 参数，可以用来修饰参数。被修饰的参数不能在方法中去修改它。</li><li>修饰方法，防止方法被继承类修改。</li><li>类修饰，那么该类无法被继承。类方法都会隐式的指向final。</li></ol><p>private 和 final: 类中的private方法都隐式的指定为final。可以对private添加final，但这并不能给该方法增加任何额外的意义。 “覆盖”只有在某方法是基类的接口的一部分才会出现，即<code>必须能将一个对象向上转型</code>为它的基本类型并调用相同的方法。如果某方法为private，它就不是基类接口的一部分，用private修饰的方法在基类中同名方法不是方法覆盖，而是生成一个新的方法。<br>static、final、static final的区别(转自：<a href="http://blog.csdn.net/qq1623267754/article/details/36190715" target="_blank" rel="noopener">http://blog.csdn.net/qq1623267754/article/details/36190715</a>)</p><ol><li>final </li></ol><p>final类不能被继承，没有子类，final类中的方法默认是final的<br>final方法不能被子类的方法复盖，但可以被继承<br>final成员变量表示常量，只能被赋值一次，赋值后不能再被改变<br>final不能用于修饰构造方法<br>private不能被子类方法覆盖，private类型的方法默认是final类型的</p><p>final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。<br>注意：final变量定义的时候，可以先声明，而不给初值，这中变量也称为final空白，无论什么情况，编译器都确保空白final在使用之前必须被初始化。</p><p>final 关键字只是表示存储在变量中的对象的引用不会再指向其它对象，对象本身可以被修改(限于可更改对象)</p><ol start="2"><li>static</li></ol><p>static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块，但是Java语言中没有全局变量的概念。</p><p>被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。</p><p>用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象市，不生成static变量的副本，而是类的所有实例共享同一个static变量。</p><ul><li>类成员变量<ul><li>静态变量（类变量）: static修饰</li><li>实例变量      : 无static修饰</li></ul></li><li>局部变量</li></ul><ol start="3"><li>static和final一起使用</li></ol><p>static final用来修饰成员变量和成员方法，可以理解为“全局变量，类常量，静态常量”</p><p>例如: System类的 <code>public static final PrintStream out = ...</code> 调用 System.out</p><p>对于变量，表示一旦给值就不可修改，并且通过类名可以访问。<br>对于方法，表示不可覆盖，并且可以通过类名直接访问。</p><p>注意：<br>对于被static和final修饰过的实例常量，实例本身不能再改变了，但对于一些容器类型（比如，ArrayList、HashMap）的实例变量，不可以改变容器变量本身，但可以修改容器中存放的对象。</p><p><code>继承与初始化</code></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Insect</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> j<span class="token punctuation">;</span>    <span class="token function">Insect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i = "</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">", j= "</span> <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>        j <span class="token operator">=</span> <span class="token number">39</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> x1 <span class="token operator">=</span> <span class="token function">printInt</span><span class="token punctuation">(</span><span class="token string">"static Insecr.x1 initialized"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">printInt</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">47</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Beetle</span> <span class="token keyword">extends</span> <span class="token class-name">Insect</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token function">printInt</span><span class="token punctuation">(</span><span class="token string">"Beetle.k initialized"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Beetle</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"k = "</span> <span class="token operator">+</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"j = "</span> <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> x2 <span class="token operator">=</span> <span class="token function">printInt</span><span class="token punctuation">(</span><span class="token string">"static Beetle.x2 initialized"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Beetle constructor"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Beetle b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Beetle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//static Insecr.x1 initialized</span><span class="token comment" spellcheck="true">//static Beetle.x2 initialized</span><span class="token comment" spellcheck="true">//Beetle constructor</span><span class="token comment" spellcheck="true">//i = 9, j= 0</span><span class="token comment" spellcheck="true">//Beetle.k initialized</span><span class="token comment" spellcheck="true">//k = 47</span><span class="token comment" spellcheck="true">//j = 39</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>理解以上输出结果。</p><ol><li>每个类的编译代码都存在于它自己的独立文件夹中。</li><li>该文件只在需要使用程序代码时才会被加载。</li><li>一般来说类的代码在初次使用时才会加载，这通常指加载发生于创建类的第一个对象之时（但是访问static域或static方法时，也会加载。构造器也是static方法，它没有显示的表示出来，更准确的说，类是在其任何static成员被访问时才加载的）</li><li>按照继承先加载对象，继承最顶层的类先被加载，然后是下面的类。然后创建对象，基本类型设置为默认值，对象的引用设置为null（通常是将对象内存二进制设置为零），然后是构造器调用。</li></ol><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>Polymoph 多态</p><ol><li>到底什么是多态呢？</li></ol><ul><li><p>官方说：<br>接口的多种不同的实现方式即为多态。<br>多态性是允许你将父对象设置成为一个或更多的他的子对象相等的技术。<br>我们在程序中定义的引用变量所指向的具体类型和通过该引用变量的方法调用在编程的时候并不确定，当处于运行期间才确定。就是这个引用变量究竟指向哪一个实例对象，在编译期间是不确定的，只有运行期才能确定，这样不用修改源码就可以把变量绑定到不同的类实例上，让程序拥有了多个运行状态，这就是多态。</p></li><li><p>说人话：<br>允许将子类类型的指针赋值给父类类型的指针，把不同的子类对象都当作父类来看。比如你家有亲属结婚了，让你们家派个人来参加婚礼，邀请函写的是让你爸来，但是实际上你去了，或者你妹妹去了，这都是可以的，因为你们代表的是你爸，但是在你们去之前他们也不知道谁会去，只知道是你们家的人。可能是你爸爸，可能是你们家的其他人代表你爸参加。这就是多态。</p></li></ul><p>多态又分为 编译时多态和运行时多态。<br>编译时多态：比如重载<br>运行时多态：比如重写</p><ol start="2"><li>多态的实现机制</li></ol><ul><li>简单版本：</li></ul><p>原理也很简单，父类或者接口定义的引用变量可以指向子类或者具体实现类的实例对象，由于程序调用方法是在运行期才动态绑定的，那么引用变量所指向的具体实例对象在运行期才确定。所以这个对象的方法是运行期正在内存运行的这个对象的方法而不是引用变量的类型中定义的方法。</p><ul><li>术语版本：</li></ul><p>我们将引入Java静态分派和动态分派这个概念。</p><p>静态分派:所有依赖静态类型来定位方法执行版本的分派动作。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的，而是由编译器来完成。（编译时多态）<br>动态分派：在运行期根据实际类型确定方法执行版本的分派动作。（运行时多态）</p><p>在面向对象程序设计语言中，多态是继数据抽象和继承之后的第三种基本特征。</p><p>“封装”通过合并特征和行为来创建新的数据类型。“实现隐藏”则通过将细节“私有化”把接口和实现分离开来。多态的作用是消除类型之间的耦合关系。</p><p>方法调用绑定：在程序执行前就把方法同相关联的方法主体关联起来称为前期绑定，与之相对的就是后期绑定，就是在运行时根据对象类型进行绑定。所有编译器需要有一种机制在运行时判断对象类型。Java除了static和final（private也是final）之外，其它都是后期绑定。使用final就可以告诉编译器关系动态绑定，一定程度优化代码，不过完全没有这个必要。<br>Java中的所有方法都是通过动态绑定来实现多态的。</p><p>需要注意私有方法，确定你是要覆盖还是重载。</p><p>多态存在的三个必要条件</p><ol><li>继承</li><li>重写</li><li>父类引用指向子类对象</li></ol><p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。</p><p>动态链接: 当父类中的一个方法只有在父类中定义而在子类中没有重写的情况下，才可以被父类类型的引用调用； 对于父类中定义的方法，如果子类中重写了该方法，那么父类类型的引用将会调用子类中的这个方法，这就是动态连接。</p><p>协变返回类型: 在Java1.4及以前，子类方法如果要覆盖超类的某个方法，必须具有完全相同的方法签名，包括返回值也必须完全一样。Java5.0放宽了这一限制，只要子类方法与超类方法具有相同的方法签名，或者子类方法的返回值是超类方法的子类型，就可以覆盖。</p><p>“协变返回(covariant return)”，仅在subclass（子类）的返回类型是superclass（父类）返回类型的extension（继承）时才被容许。</p><blockquote><p>方法是放在代码区(code seg)里面的，里面的方法就是一句句代码。<br>因此当使用pet引用去访问父类对象的方法时，首先是找到这个父类对象，然后看看它里面的方法到底在哪里存着，找到那个方法再去执行。<br>这里头就比较有意思了，code seg里面有很多个enjoy方法，有父类的enjoy()方法，也有子类重写了从父类继续下来的enjoy()方法，那么调用的时候到底调用的是哪一个呢？是根据谁来确定呢？</p><p>注意：这是根据你实际当中的对象来确定的，你实际当中new出来的是谁，就调用谁的enjoy方法，当你找这个方法的时候，通过pet引用能找得到这个方法，但调用代码区里面的哪一个enjoy方法不是通过引用类型来确定的，如果是通过引用类型pet来确定，那么调用的肯定是Animal的enjoy()方法，可是现在是根据实际的类型来确定，我们的程序运行以后才在堆内存里面创建出一只Cat，然后根据你实际当中new出来的类型来判断我到底应该调用哪一个enjoy()方法。如果是根据实际类型，那么调用的就应该是Cat的enjoy()方法。如果是根据引用类型，那么调用的就应该是Animal的enjoy()方法。</p><p>现在动态绑定这种机制指的是实际当中new的是什么类型，就调用谁的enjoy方法。所以说虽然你是根据我父类里面的enjoy方法来调用，可是实际当中却是你new的是谁调用的就是谁的enjoy()方法。</p><p>即实际当中调用的却是子类里面重写后的那个enjoy方法。</p><p>当然，讲一点更深的机制，你实际当中找这个enjoy方法的时候，在父类对象的内部有一个enjoy方法的指针，指针指向代码区里面父类的Animal的enjoy方法，只不过当你new这个对象的时候，这个指针随之改变，你new的是什么对象，这个指针就指向这个对象重写后的那个enjoy方法，所以这就叫做动态绑定。<br>只有在动起来的时候，也就是在程序运行期间，new出了这个对象了以后你才能确定到底要调用哪一个方法。我实际当中的地址才会绑定到相应的方法的地址上面，所以叫动态绑定。<br>调这个方法的时候，只要你这个方法重写了，实际当中调哪一个，要看你实际当中new的是哪个对象，这就叫多态，也叫动态绑定。</p><p>动态绑定带来莫大的好处是使程序的可扩展性达到了最好，我们原来做这个可扩展性的时候，首先都是要在方法里面判断一下这只动物是哪一类里面的动物，通过if (object instanceof class)这样的条件来判断这个new出来的对象到底是属于哪一个类里面的，如果是一只猫，就调用猫的enjoy方法，如果是一条狗，就调用狗的enjoy方法。</p><p>如果我现在增加了一个Bird类，那么扩展的时候，你又得在方法里面写判断这只鸟属于哪一个类然后才能调用这只鸟的enjoy方法。每增加一个对象，你都要在方法里面增加一段判断这个对象到底属于哪个类里面的代码然后才能执行这个对象相应的方法。</p><p>即每增加一个新的对象，都要改变方法里面的处理代码，而现在，你不需要再改变方法里面的处理代码了，因为有了动态绑定。</p><p>你要增加哪一个对象，你实际当中把这个对象new出来就完了，不再用去修改对象的处理方法里面的代码了。也就是当你实际当中要增加别的东西的时候，很简单，你直接加上去就成了，不用去改原来的结构，你要在你们家大楼的旁边盖一个厨房，很简单，直接在旁边一盖就行了，大楼的主要支柱什么的你都不用动，这就可以让可扩展性达到了极致，这就为将来的可扩展打下了基础，也只有动态绑定（多态）这种机制能帮助我们做到这一点——让程序的可扩展性达到极致。因此动态绑定是面向对象的核心，如果没有动态绑定，那么面向对象绝对不可能发展得像现在这么流行，所以动态绑定是面向对象核心中的核心。</p><p>总结动态绑定（多态）：动态绑定是指在“执行期间”（而非编译期间）判断所引用的实际对象类型，根据其实际的类型调用其相应的方法。所以实际当中找要调用的方法时是动态的去找的，new的是谁就找谁的方法，这就叫动态绑定。动态绑定帮助我们的程序的可扩展性达到了极致。</p><p>虽然及其的啰嗦，这也是先入为主的影响吧，如果你先学的python，你会觉得这是理所当然的。</p></blockquote><p>多态和普通引用代码举例</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> polymoph<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SupperParents</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">supperFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"supperFunc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">package</span> polymoph<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Parents</span> <span class="token keyword">extends</span> <span class="token class-name">SupperParents</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String name <span class="token operator">=</span> <span class="token string">"123456"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> String name2 <span class="token operator">=</span> <span class="token string">"qweasd"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"parents func1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">parentsFunc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"parents parentsFunc1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">package</span> polymoph<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Children</span> <span class="token keyword">extends</span> <span class="token class-name">Parents</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String name <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> String name1 <span class="token operator">=</span> <span class="token string">"mnb"</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"children func1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"children func2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/**         * 多态 方法 向上转型         * 1. 对于方法，只能调用父类中定义的，如果这个方法子类重写了，实际执行使用子类的，如func1         * 2. 如果方法子类没有，调用父类的，如parentsFunc1         * 3. 不能调用只有子类才有的方法，如func2         *         * 多态 属性         * 1. 属性则不会这样，只能调用父类的属性，name属性子父类都有，使用父类的         * 2. 子类才有的属性，父类无法调用，如name1         */</span>        Parents children <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Children</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        children<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// children func1</span>        children<span class="token punctuation">.</span><span class="token function">parentsFunc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// parents parentsFunc1</span>        <span class="token comment" spellcheck="true">// children.func2(); 无法调用</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>children<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 123456</span>        <span class="token comment" spellcheck="true">// System.out.println(children.name1); 无法调用</span>        children<span class="token punctuation">.</span><span class="token function">supperFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Parents 继承类 SupperParents 的方法，情况参照 2，你就把supperFunc当成是 Parents 类的方法，</span>        <span class="token comment" spellcheck="true">// 因为supperFunc是Parents通过继承得到的</span>        <span class="token comment" spellcheck="true">/**         * 使用对象自身的引用的情况就简单多了，自己有的属性和方法就调用自己的，否则看父类有没有         */</span>        Children children1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Children</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        children1<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// children func1</span>        children1<span class="token punctuation">.</span><span class="token function">parentsFunc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// parents parentsFunc1</span>        children1<span class="token punctuation">.</span><span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// children func2</span>        children1<span class="token punctuation">.</span><span class="token function">supperFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Parents 继承类的方法</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>children1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 123</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>children1<span class="token punctuation">.</span>name1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// mnb</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>children1<span class="token punctuation">.</span>name2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// qweasd</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><p>Java程序在运行时，Java运行时系统一直对所有的对象进行所谓的运行时类型标识，即所谓的RTTI(Run-Time Type Identification)。</p><p>这项信息纪录了每个对象所属的类。虚拟机通常使用运行时类型信息选准正确方法去执行，用来保存这些类型信息的类是Class类。Class类封装一个对象和接口运行时的状态，当装载类时，Class类型的对象自动创建。</p><p>说白了就是：</p><p>Class类也是类的一种，只是名字和class关键字高度相似。Java是大小写敏感的语言。</p><p>Class类的对象内容是你创建的类的类型信息，比如你创建一个shapes类，那么，Java会生成一个内容是shapes的Class类的对象</p><p>Class类的对象不能像普通类一样，以 new shapes() 的方式创建，它的对象只能由JVM创建，因为这个类没有public构造函数</p><p>Class类的作用是运行时提供或获得某个对象的类型信息，和C++中的typeid()函数类似。这些信息也可用于反射。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">,</span>            InstantiationException<span class="token punctuation">,</span> NoSuchMethodException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Class类的作用是运行时提供或获得某个对象的类型信息</span>        <span class="token comment" spellcheck="true">// 获取Class对象的方式</span>        Class <span class="token class-name">class_user1</span> <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"ioclearn.User"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User instance_user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Class <span class="token class-name">class_user2</span> <span class="token operator">=</span> instance_user<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Class <span class="token class-name">class_user3</span> <span class="token operator">=</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 使用Class类的对象来生成目标类的实例</span>        Object user <span class="token operator">=</span> class_user1<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"Display"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object newShape <span class="token operator">=</span> class_user3<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// newInstance返回的对象，只能是Object类型</span>        <span class="token comment" spellcheck="true">// 利用泛型</span>        Class <span class="token class-name">obj1</span> <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        Class<span class="token operator">&lt;</span>Integer<span class="token operator">></span> obj2 <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        obj1 <span class="token operator">=</span> <span class="token keyword">double</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// obj2=double.class; 错误</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> Double<span class="token operator">></span> obj3 <span class="token operator">=</span> Double<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Class&lt;Number> obj3 = Double.class; // 这里很特殊，不能直接用超类的引用，要用&lt;? super Double>，记住就行了</span>        obj3 <span class="token operator">=</span> Number<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法</p><p>抽象类或抽象方法：abstract定义抽象方法，如果一个类包含一个抽象方法，必须修饰为抽象类。在C++中，这相当于虚函数，纯虚函数。</p><p>接口使得抽象的概念更向前迈进了一步，接口产生一个完全抽象的类，允许创建者确定方法名，列表参数，返回类型，不提供方法体。</p><p>接口中的方法默认是public的，接口类默认是包访问权限。</p><p>通过关键字implements(实现)来像继承一样声明当前类是哪个接口的实现。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">B</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">interface</span> <span class="token class-name">A</span> <span class="token keyword">extends</span> <span class="token class-name">B</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 接口继承</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">implements</span> <span class="token class-name">B</span><span class="token comment" spellcheck="true">// 普通的实现</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">implements</span> <span class="token class-name">B</span><span class="token punctuation">,</span> C<span class="token punctuation">,</span> D<span class="token comment" spellcheck="true">// 实现来自多个接口</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">extends</span> <span class="token class-name">B</span> <span class="token keyword">implements</span> <span class="token class-name">C</span><span class="token punctuation">,</span> D <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 实现了多继承，也避免了钻石继承问题</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接口适配：允许一个接口有多个不同的实现</p><p>接口的域：由于接口的任何域都是final和static，历史代码会用接口来做常量，Java SE5 后，一般用枚举enum来代替了</p><p>嵌套接口：接口可以嵌套在类中，可能这种运用有点少见，要知道可以这么做，遇到了可以来看看书</p><p>接口特性：接口不能被实例化，可以声明接口类型的变量，接口可以包含常量</p><p>在JavaSE8中，可以在接口中定义默认方法，default关键字修饰。接口的在实现的时候，默认方法可以不用覆盖</p><p>特点:</p><ol><li>接口不能用于实例化对象。</li><li>接口没有构造方法。</li><li>接口中所有的方法必须是抽象方法。</li><li>接口不能包含成员变量，除了 static 和 final 变量。</li><li>接口不是被类继承了，而是要被类实现。</li><li>接口支持多继承。</li></ol><ul><li><p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p></li><li><p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p></li><li><p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p></li><li><p>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。</p></li><li><p>接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。</p></li><li><p>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</p></li></ul><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>abstract 修饰抽象类或抽象方法</p><p>特点:</p><ol><li>方法和类都可以被修饰为抽象</li><li>只要类中有一个方法被修饰为抽象，这个类就必须加上抽象修饰</li><li>抽象方法不能有方法体</li><li>抽象类不能被实例化</li><li>abstract interfact 可以修饰接口，不过其实从本质上来说接口就是抽象的，这么写不会报错，但是没意义(具体没考证过，不过没有这么写的，写了也不会报错)</li><li>由于抽象类不能被实例化，它都是用来被继承的，但是它本身也有类的大多数功能，比如成员变量，自己的方法，构造函数等，抽象类的构造函数由子类去调用</li><li>不能有抽象构造方法或抽象静态方法</li></ol><p>第6点举例</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> polymophIntface<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">BaoMa</span> <span class="token keyword">implements</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> Integer price<span class="token punctuation">;</span>    <span class="token function">BaoMa</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Integer price<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>price <span class="token operator">=</span> price<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">abstract</span> <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Integer <span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> price<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">package</span> polymophIntface<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QQCar</span> <span class="token keyword">extends</span> <span class="token class-name">BaoMa</span> <span class="token punctuation">{</span>    <span class="token function">QQCar</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Integer price<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> price<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 抽象类有构造函数，其实结合前面聊到的构造函数的东西，就能理解抽象类需要调用构造函数对成员变量赋值</span>        <span class="token comment" spellcheck="true">// 如果是无参构造器，当然就不需要子类去帮抽象类初始化了</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h2><ol><li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。</li><li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ol><blockquote><p>注：JDK 1.8 以后，接口里可以有静态方法和方法体了，静态方法直接用接口类名调用，也不需要实现</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> String <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>java 8 以后还可以定义默认方法，不过这个默认方法要接口的实现类才可以调用</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">stu</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"stu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="容器和基本对象"><a href="#容器和基本对象" class="headerlink" title="容器和基本对象"></a>容器和基本对象</h2><p>容器相关知识点</p><h3 id="容器类-持有对象"><a href="#容器类-持有对象" class="headerlink" title="容器类(持有对象)"></a>容器类(持有对象)</h3><p>容器类是整个语言最重要的一部分，或者称为集合框架，记住，定义容器类的时候，最好使用泛型</p><p>Java集合主要有两个接口派生而出：Collection和Map，这个两个接口是Java集合框架的根接口</p><p>Collection: 容器类型对象的父接口</p><p>容器类：基本类型是List，set，Queue和Map，这些对象类型也称为集合类，但由于Java的类库使用了Collection这个名字来指代该类库的一个特殊子集，所有更广泛的称为容器</p><p>Map：也被称为关联数组</p><p>List：基本的ArrayList，它长于随机访问元素，但是在List的中间插入和移除元素时较慢。LinkedList，它通过代价较低的在List中间进行的插入和删除操作，提供了优化的顺序访问，在随机访问较慢，占空间也大。</p><p>迭代器：对容器的访问</p><p>Collection 是描述所有序列容器的共性的根接口</p><p>Foreach 也可以用于任何Collection对象</p><p>容器不能持有基本类型，但是自动包装机制会仔细地执行基本类型到容器中所持有的包装器类型之间的双向转换</p><p>大量的随机访问，使用ArrayList，经常从中间插入或删除元素使用LinkedList，各种Queue以及栈的行为，由LinkedList提供支持</p><p>关于Map，HashMap用于快速访问，TreeMap始终让键保持在排序状态(类似二叉树插入)，LinkedHashMap保持插入顺序，也提供散列提供快速访问的能力</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p><p>我理解了，hashmap如果直接对hash值取模结果会有明显的局部性，并且引起堆积。 解决了哈希碰撞问题，思想就是把高位和低位混合进行计算，提高分散性</p><h3 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a>自动装箱</h3><pre class="line-numbers language-java"><code class="language-java">ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上诉的add操作将自动的变成 <code>list.add(Integer.ValueOf(3));</code>，这种变换称之为自动装箱(autoboxing)</p><p>将一个包装器对象赋值给一个基本对象，称为自动拆箱</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span> n <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> n <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>装箱和拆箱是编译器认可的，而不是虚拟机。编译器在生成类的字节码时，插入必要的方法调用。虚拟机只是执行这些字节码。</p><h3 id="Integer的自动装箱"><a href="#Integer的自动装箱" class="headerlink" title="Integer的自动装箱"></a>Integer的自动装箱</h3><pre class="line-numbers language-java"><code class="language-java">Integer f1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span> f2 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span> f3 <span class="token operator">=</span> <span class="token number">150</span><span class="token punctuation">,</span> f4 <span class="token operator">=</span> <span class="token number">150</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>f1 <span class="token operator">==</span> f2<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>f3 <span class="token operator">==</span> f4<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面的代码，由于是引用比较，会认为都是false，但是f1 == f2是true，原因是:</p><p>如果整型字面量的值在-128 到 127 之间，那么不会 new 新的 Integer对象，而是直接引用常量池中的 Integer 对象</p><p>具体可以追溯到源码，自动装箱后调用valueof，IntegerCache做了判断，字面量的值在-128 到 127 之间</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> IntegerCache<span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> IntegerCache<span class="token punctuation">.</span>high<span class="token punctuation">)</span>            <span class="token keyword">return</span> IntegerCache<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span>IntegerCache<span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组声明方法：</p><p>dataType[] arrayRefVar;   // 首选的方法</p><p>或</p><p>dataType arrayRefVar[];  // 效果相同，但不是首选方法</p><p>声明后通过new关键字创建数组，完整实例：double[] myList = new double[10];</p><p>元素是10个的固定数组，元素类型是double，数组大小是固定的，不固定请使用集合框架的相关数组类</p><p>记住数组的定义是<code>类型</code>加上<code>[]</code>，double[] 作为数组类型声明，然后再写一个数组变量名，最后就组成了 dataType[] arrayRefVar</p><p>常见写法:</p><p><code>int[] abc = new int[]{1, 2, 3};</code><br><code>char[] words = {'1', '2'};</code><br><code>String[] words = {"1", "2"};</code> // 字符和字符串是不同的</p><p>声名二维数组: <code>int[][] array</code></p><p>打印数组: Arrays.toString(a) 该方法会将数组拼成字符串</p><p>数组值拷贝(不是引用): <code>int[] array = Arrays.copyOf(array1, array1.length</code>，可以调整长度的值，做的扩充数组，多余的元素会被赋初值，int为0，booler为false，如果是小于原长度，则截取，只拷贝前面的数值</p><p>数组排序: Arrays.sort()</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ol><li>基本概念<br>字符串由char值序列组成，char数据类型是一个采用UTF-16编码表示Unicode码点的代码单元，大多数的常用Unicode字符串使用一个代码单元就可以表示，而辅助字符需要一对代码单元表示</li></ol><p>码点和代码单元可能是一个需要去了解的概念:</p><ul><li>码点: 就是某个任意字符在Unicode编码表中对应的代码值</li><li>代码单元: 是在计算机中用来表示码点的，大部分码点只需要一个代码单元表示，但是有一些是需要两个代码单元表示的</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> codePoints<span class="token punctuation">,</span> <span class="token keyword">int</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 可以用一个由码点值组成的数组来创建字符串</span>String greeting <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> greeting<span class="token punctuation">.</span><span class="token function">codePoints</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> array<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>length方法返回代码单元数量，实际长度即码点数调用<code>int cpCount = "Hello".codePointCount(0, "Hello".length());</code>，由于这是一个比较简单的纯英文字符串，码点数量和代码单元都是5</p><p>获取指定位置的代码单元: <code>str.charAt(0)</code> 返回0位置的代码单元</p><p>获取指定位置的码点: <code>str.offsetByCodePoints(0, index); int cp = greeting.codePointAt(index);</code></p><ol start="2"><li>常用方法和操作</li></ol><p>字面量也可以调用很多方法</p><p>例子：</p><pre class="line-numbers language-java"><code class="language-java">str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>str<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>str <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true">// 检查既不是null也不是空串</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>截取操作: subString(0, 3) 实例方法<br>join方法合并字符串，可以指定分隔符，静态方法</p><pre class="line-numbers language-java"><code class="language-java">String<span class="token punctuation">[</span><span class="token punctuation">]</span> list <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>s <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">"mn"</span><span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>s <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">"mn"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>构建字符串</li></ol><p>拼接字符串的效率是低下的，每次连接字符串都需要频繁的创建对象，可以使用StringBuilder类来实现</p><pre class="line-numbers language-java"><code class="language-java">StringBuilder builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>character or string<span class="token punctuation">)</span><span class="token punctuation">;</span>String completedString <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>StringBuilder 和 StringBuffer 两者都有相同的API，StringBuffer运行在多线程中操作，单线程用StringBuilder</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>一个异常的例子：throw new NullPointerException(“abc”)</p><p>异常根类 Throwable</p><p>try 处理块：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception2</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p><p>Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p><p>在JavaSE7之后的版本，构造函数中可以省略泛型类型</p><ol><li>参数化类型:</li></ol><p>把类型当作是参数一样传递<br>&lt;数据类型&gt; 只能是引用类型</p><ol start="2"><li>相关术语：</li></ol><p>ArrayList<e>中的E称为类型参数变量<br>ArrayList<integer>中的Integer称为实际类型参数<br>整个称为ArrayList<e>泛型类型<br>整个ArrayList<integer>称为参数化的类型ParameterizedType</integer></e></integer></e></p><ol><li>泛型方法</li></ol><ul><li>定义：</li></ul><p>所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前<br>每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符<br>类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符<br>泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像int,double,char的等）</p><p>泛型方法可以定义在泛型类或普通类中</p><ul><li>举例：</li></ul><p>假设当前类名是MyClass</p><p><code>public static &lt;E&gt; void printArray(E[] inputArray)</code><br><code>public static &lt;T&gt; T printArray(T[] inputArray)</code></p><p>可以看到和一般方法的区别就是在返回类型前面加上参数类型的定义，然后这个参数类型就可以被用在<code>(1.返回类型，2.方法参数类型，3.方法体内)</code><br>调用泛型方法：<code>MyClass.&lt;String&gt;printArray(参数为String类型的数组)</code></p><ol start="2"><li>泛型类</li></ol><ul><li>定义：</li></ul><p>泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分<br>和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型</p><ul><li>举例：</li></ul><p><code>public class Box&lt;T&gt;</code></p><ol start="3"><li>通配符类型</li></ol><p>类型参数使用规范：<br>E: 表示集合元素类型<br>K,V: 表示表的关键字和值<br>T(U 或 S): 表示任意类型 </p><p>通配符类型一般是使用?代替具体的类型参数。例如 List&lt;?&gt; 在逻辑上是List<string>,List<integer> 等所有List&lt;具体类型实参&gt;的父类<br>这是一个很抽象的概念，能不能学会泛型，就看能不能理解通配符</integer></string></p><ol start="4"><li>类型限制</li></ol><p>extends 关键字来限制泛型参数的超类 <t extends="" comparable=""> 这样实际类型参数就必须是Comparable的子类</t></p><ol start="5"><li>类型擦除</li></ol><p>这是一个很重要的概念，无论何时定义一个泛型类型，都自动提供了一个相应的原始类型</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>理解jvm和Class对象就能理解了反射</p><p>最重要的一步，获得Class对象，方式如下:</p><p>类名.class 泛型为T<br>getClass() 实例调用 泛型为?<br>Class.forName(“ioclearn.Test”) 泛型为?</p><p>所以，只有<code>类名.class</code>的形式能确定类型，其它情况获取的对象，在后续的使用中要么类型转换或者用Object对象</p><p>其它方法补充:<br>getName() Class的实例调用，返回 字符串 ioclearn.Test</p><h3 id="判断是否为某个类的实例"><a href="#判断是否为某个类的实例" class="headerlink" title="判断是否为某个类的实例"></a>判断是否为某个类的实例</h3><p>son instanceof Son</p><p>Student.class.isInstance(student)</p><h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><ol><li>利用newInstance创建对象：调用的类必须有无参的构造器</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Class&lt;?>代表任何类的一个类对象。</span><span class="token comment" spellcheck="true">//使用这个类对象可以为其他类进行实例化</span><span class="token comment" spellcheck="true">//因为jvm加载类以后自动在堆区生成一个对应的*.Class对象</span><span class="token comment" spellcheck="true">//该对象用于让JVM对进行所有*对象实例化。</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Class&lt;?> 中的 ? 是通配符，其实就是表示任意符合泛类定义条件的类，和直接使用 Class</span><span class="token comment" spellcheck="true">//效果基本一致，但是这样写更加规范，在某些类型转换时可以避免不必要的 unchecked 错误。</span>Object str <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。</li></ol><p><code>public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</code> 观察getConstructor的方法签名，它接收Class&lt;?&gt;对象，这里就是和有参数的构造器要想对应，比如构造器需要<code>String a, Integer b</code>，那么getConstructor传递<code>String.class, Integer.class</code></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//获取String所对应的Class对象</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取String类带一个String参数的构造器</span>Constructor constructor <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//根据构造器创建实例</span>Object obj <span class="token operator">=</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token string">"23333"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Constructor<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>InvocationTargetException<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String a<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Student</span><span class="token punctuation">(</span>String a<span class="token punctuation">,</span> Integer b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">Student</span><span class="token punctuation">(</span>String a<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">Student</span><span class="token punctuation">(</span>Boolean b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Student{"</span> <span class="token operator">+</span>                <span class="token string">"a='"</span> <span class="token operator">+</span> a <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>                <span class="token string">'}'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>            <span class="token keyword">throws</span> IllegalAccessException<span class="token punctuation">,</span> InstantiationException<span class="token punctuation">,</span> NoSuchMethodException<span class="token punctuation">,</span> InvocationTargetException <span class="token punctuation">{</span>        Class<span class="token operator">&lt;</span>Student<span class="token operator">></span> c <span class="token operator">=</span> Student<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        Constructor<span class="token operator">&lt;</span>Student<span class="token operator">></span> constructor <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Student student <span class="token operator">=</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><ol><li>getDeclaredMethods<br>返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法</li><li>getMethods<br>返回某个类的所有公用（public）方法，包括其继承类的公用方法</li><li>getMethod<br>方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象</li></ol><p>包含Declared描述的方法，获取的是自己类的，继承的没有(包含私有，公有的)，不包含的返回公有的，包括继承的(只返回公有的)<br>这个在获取字段中也是类似的情况</p><p>再次强调，获取字段也是类似的：</p><p>getDeclaredMethod<em>()获取的是类自身声明的所有方法，包含public、protected和private方法。<br>getMethod</em>()获取的是类的所有共有方法，这就包括自身的所有public方法，和从基类继承的、从接口实现的所有public方法。</p><h3 id="获取构造器"><a href="#获取构造器" class="headerlink" title="获取构造器"></a>获取构造器</h3><p>getConstructor</p><h3 id="获取成员变量，字段"><a href="#获取成员变量，字段" class="headerlink" title="获取成员变量，字段"></a>获取成员变量，字段</h3><p>getFiled: 访问公有的成员变量<br>getDeclaredField：所有已声明的成员变量。但不能得到其父类的成员变量 </p><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><p>这个例子包含了调用的很多情况</p><pre class="line-numbers language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>            <span class="token keyword">throws</span> IllegalAccessException<span class="token punctuation">,</span>            InstantiationException<span class="token punctuation">,</span> NoSuchMethodException<span class="token punctuation">,</span> InvocationTargetException <span class="token punctuation">{</span>        Class<span class="token operator">&lt;</span>UserBean<span class="token operator">></span> userBeanClass <span class="token operator">=</span> UserBean<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取该类所有的方法，包括静态方法，实例方法。</span>        <span class="token comment" spellcheck="true">// 此处也包括了私有方法，只不过私有方法在用invoke访问之前要设置访问权限</span>        <span class="token comment" spellcheck="true">// 也就是使用setAccessible使方法可访问，否则会抛出异常</span>        <span class="token comment" spellcheck="true">// getDeclaredMethod*()获取的是类自身声明的所有方法，包含public、protected和private方法。</span>        <span class="token comment" spellcheck="true">// getMethod*()获取的是类的所有共有方法，这就包括自身的所有public方法，和从基类继承的、从接口实现的所有public方法。</span>        <span class="token comment" spellcheck="true">// IllegalAccessException的解释是</span>        <span class="token comment" spellcheck="true">// * An IllegalAccessException is thrown when an application tries</span>        <span class="token comment" spellcheck="true">// * to reflectively create an instance (other than an array),</span>        <span class="token comment" spellcheck="true">// * set or get a field, or invoke a method, but the currently</span>        <span class="token comment" spellcheck="true">// * executing method does not have access to the definition of</span>        <span class="token comment" spellcheck="true">// * the specified class, field, method or constructor.</span>        <span class="token comment" spellcheck="true">//IllegalAccessException的解释是 就是说，当这个类，域或者方法被设为私有访问，使用反射调用但是却没有权限时会抛出异常。</span>        Method<span class="token punctuation">[</span><span class="token punctuation">]</span> methods <span class="token operator">=</span> userBeanClass<span class="token punctuation">.</span><span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取所有成员方法</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Method method <span class="token operator">:</span> methods<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//反射可以获取方法上的注解，通过注解来进行判断</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span>Invoke<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 判断是否被 @Invoke 修饰</span>                <span class="token comment" spellcheck="true">// 判断方法的修饰符是是static</span>                <span class="token comment" spellcheck="true">// getModifiers获取方法的修饰</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>Modifier<span class="token punctuation">.</span><span class="token function">isStatic</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果是 static 方法</span>                    <span class="token comment" spellcheck="true">//反射调用该方法</span>                    <span class="token comment" spellcheck="true">//类方法可以直接调用，不必先实例化</span>                    method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token string">"wingjay"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 直接调用，并传入需要的参数 devName</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//如果不是类方法，需要先获得一个实例再调用方法</span>                    <span class="token comment" spellcheck="true">//传入构造方法需要的变量类型</span>                    Class<span class="token punctuation">[</span><span class="token punctuation">]</span> params <span class="token operator">=</span> <span class="token punctuation">{</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">long</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//获取该类指定类型的构造方法</span>                    <span class="token comment" spellcheck="true">//如果没有这种类型的方法会报错</span>                    Constructor<span class="token operator">&lt;</span>UserBean<span class="token operator">></span> constructor <span class="token operator">=</span> userBeanClass<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取参数格式为 String,long 的构造函数</span>                    <span class="token comment" spellcheck="true">//通过构造方法的实例来进行实例化</span>                    Object userBean <span class="token operator">=</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token string">"wingjay"</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 利用构造函数进行实例化，得到 Object</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>Modifier<span class="token punctuation">.</span><span class="token function">isPrivate</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        method<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果是 private 的方法，需要获取其调用权限</span>                        <span class="token comment" spellcheck="true">//     Set the {@code accessible} flag for this object to</span>                        <span class="token comment" spellcheck="true">//     * the indicated boolean value.  A value of {@code true} indicates that</span>                        <span class="token comment" spellcheck="true">//     * the reflected object should suppress Java language access</span>                        <span class="token comment" spellcheck="true">//     * checking when it is used.  A value of {@code false} indicates</span>                        <span class="token comment" spellcheck="true">//     * that the reflected object should enforce Java language access checks.</span>                        <span class="token comment" spellcheck="true">//通过该方法可以设置其可见或者不可见，不仅可以用于方法</span>                        <span class="token comment" spellcheck="true">//后面例子会介绍将其用于成员变量</span>                        <span class="token comment" spellcheck="true">//打印结果</span>                        <span class="token comment" spellcheck="true">// I'm a public method</span>                        <span class="token comment" spellcheck="true">// Hi wingjay, I'm a static methodI'm a private method</span>                    <span class="token punctuation">}</span>                    method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>userBean<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用 method，无须参数</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="利用反射创建数组"><a href="#利用反射创建数组" class="headerlink" title="利用反射创建数组"></a>利用反射创建数组</h3><p><code>import java.lang.reflect.Array;</code> 利用反射中提供的Array类来创建</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> cls <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            cls <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"java.lang.String"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Object array <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//往数组里添加内容</span>        Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"Java"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"fuck"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"Scala"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">"Clojure"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取某一项的内容</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//Scala</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h2><p>Scanner类实现标准输入流(可以留意构造函数，它指定了流的来源)，在调用读取输入方法的时候，会阻塞进程等待输入，得到输入后程序继续</p><pre class="line-numbers language-java"><code class="language-java">String greeting <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span>Scanner in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"what is your name?"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String name <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>包含三种标准注解和四种元注解</p><p>标准注解，就是JDK内置的注解，位于java.lang.annotation中:</p><ol><li>Override<br>编译器可以给你验证@Override下面的方法名是否是你父类中所有的，如果没有则报错。例如，你如果没写@Override，而你下面的方法名又写错了，这时你的编译器是可以编译通过的，因为编译器以为这个方法是你的子类中自己增加的方法</li><li>Deprecated<br>弃用的，一个方法被加上这个注解后，在子类中重写这个方法，idea工具会把这个方法名划线，表示这个方法被弃用了，最好不要用，但是，此方法有可能在以后的版本升级中会被慢慢的淘汰(因为我查到的资料说编译器会有提示，运行了没有，JDK1.8下测试的，补充，可能是idea工具的原因，因为编译程序的时候是可以指定参数的，个人猜测idea优化了这些东西了)</li><li>SuppressWarnings<br>根据传递的参数来抑制警告</li></ol><p>Java8新增 @FunctionalInterface</p><ul><li>此注解是 Java8 提出的函数式接口，接口中只允许有一个抽象方法</li><li>加上这个注解之后，类中多一个抽象方法或者少一个抽象方法都会报错</li></ul><p>元注解，用来注解其它注解的，自定义注解一般会用到：</p><ol><li><p>@Documented –注解是否将包含在JavaDoc中</p></li><li><p>@Retention –什么时候使用该注解<br>定义该注解的生命周期，参数如下：</p></li></ol><ul><li><p>RetentionPolicy.SOURCE :<br>在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解</p></li><li><p>RetentionPolicy.CLASS :<br>在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式</p></li><li><p>RetentionPolicy.RUNTIME :<br>始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。</p></li></ul><ol start="3"><li>@Target –注解用于什么地方<br>表示该注解用于什么地方。<code>默认值为任何元素</code>，表示该注解用于什么地方，不能把用于字段的用在方法上，可用的ElementType参数包括</li></ol><p>● ElementType.CONSTRUCTOR:用于描述构造器<br>● ElementType.FIELD:成员变量、对象、属性（包括enum实例）<br>● ElementType.LOCAL_VARIABLE:用于描述局部变量<br>● ElementType.METHOD:用于描述方法<br>● ElementType.PACKAGE:用于描述包<br>● ElementType.PARAMETER:用于描述参数<br>● ElementType.TYPE:用于描述类、接口(包括注解类型) 或enum声明</p><ol start="4"><li>@Inherited – 是否允许子类继承该注解<br>@inherited注解修饰的注解@A，@A修饰某个类，则该类的子类也被@A修饰</li></ol><h3 id="注解的属性"><a href="#注解的属性" class="headerlink" title="注解的属性"></a>注解的属性</h3><p>注解的属性是注解里面使用的，注解的属性也叫做成员变量，注解只有成员变量，没有方法。<br>注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型<br>在注解中定义属性时它的类型必须是 8 种基本数据类型外加 类、接口、注解及它们的数组，String类型也可以用</p><p>示例:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">TestAnnotation</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token function">id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String <span class="token function">msg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认值<code>public int id() default -1;</code></p><p>如果一个注解内仅仅只有一个名字为 value 的属性时，应用这个注解时可以直接把属性值填写到括号内，比如上面的测试注解只有id属性时<code>@TestAnnotation(123)</code></p><p>注解没有属性可以省略括号</p><p>当注解中含有数组属性时，使用{}赋值，各个元素使用逗号分隔<br>定义 <code>String[] parentsName();</code><br>赋值 <code>@ParentsAnnotation(parentsName = {"1", "2"})</code></p><p>注解的属性可以是另外一个注解</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">MyAnnotation</span> <span class="token punctuation">{</span>    String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ParentsAnnotation <span class="token function">parentsannotation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ParentsAnnotation parentsannotation() default  @ParentsAnnotation(parentsName = {"!"}, parentsAge = 1); 设置默认值，这样对方法添加注解的时候就不用赋值了</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>FIELD<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">ParentsAnnotation</span> <span class="token punctuation">{</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">parentsName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">parentsAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token annotation punctuation">@MyAnnotation</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"x"</span><span class="token punctuation">,</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> parentsannotation <span class="token operator">=</span> <span class="token annotation punctuation">@ParentsAnnotation</span><span class="token punctuation">(</span>parentsName <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> parentsAge <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// annotation.parentsannotation().parentsAge() 获取到继承注解的属性</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>属性数组的元素可以是另外一个注解<br><code>Hello[] helloArrayValue() default {@Hello,@Hello};</code></p><p>以上，就是注解属性定义的各种情况</p><h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h3><p>注解是一种标记，基本注解用来决定注解到什么地方，什么时候发挥作用。我们需要读取注解的工具，也就是<code>创建与使用注解处理器</code>。注解处理器是一个单独的类，通过获取被注解的类，然后调用获取注解信息的方法得到注解信息，之后进行操作。有各种反射方法来获取注解标记的信息。</p><p>第一步，当然是获取注解数据了</p><p>Class.getAnnotation(Class&lt; A &gt; annotationClass) 获取指定的注解，该注解可以是自己声明的，也可以是继承的<br>Class.getDeclaredAnnotations() 获取自己声明的注解<br>Class.getAnnotations() 获取所有的注解，包括自己声明的以及继承的</p><p>上面是类的注解获取方式，方法和字段的注解用对应类型即可</p><p>后两种返回的是数组，这个继承是说使用了<code>@Inherited</code>的情况，也就是说是对于<code>类的注解</code>这两个方法有区别，其它是一样的(测试是这样的)</p><p>得到注解后，获取注解标注的属性</p><pre class="line-numbers language-java"><code class="language-java">Class<span class="token operator">&lt;</span>Test<span class="token operator">></span> c <span class="token operator">=</span> Test<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>Method method <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Annotation<span class="token punctuation">[</span><span class="token punctuation">]</span> annotationsArray <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getDeclaredAnnotations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MyAnnotation annotation <span class="token operator">=</span> <span class="token punctuation">(</span>MyAnnotation<span class="token punctuation">)</span> annotationsArray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>annotation<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 普通属性</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>annotation<span class="token punctuation">.</span><span class="token function">parentsannotation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parentsAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 属性是注解，再去获取这个注解的属性</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="内置包"><a href="#内置包" class="headerlink" title="内置包"></a>内置包</h2><p>jdk内置包使用方法总结</p><h3 id="java-io-Serializable"><a href="#java-io-Serializable" class="headerlink" title="java.io.Serializable"></a>java.io.Serializable</h3><p>在序列化的时候需要使用到，只有实现这个接口的类才能序列化，这个Serializable不包含任何方法，所以实现类不需要做任何处理(这里的原理待后续展开)。<br>运用：比如把一个普通对象通过FileOutputStream文件输出流写到文件中，然后通过FileInputStream读取对象恢复它，序列化只能处理简单的对象值，方法等复杂的成员不能被处理。</p><h2 id="扩展包"><a href="#扩展包" class="headerlink" title="扩展包"></a>扩展包</h2><p>扩展包用法记录</p><h3 id="lombok"><a href="#lombok" class="headerlink" title="lombok"></a>lombok</h3><p>一个插件，减少对象操作的代码编写</p><h2 id="语法部分"><a href="#语法部分" class="headerlink" title="语法部分"></a>语法部分</h2><p>主要是Java语言语法特点部分，和一些关键字概念</p><h3 id="控制执行流程"><a href="#控制执行流程" class="headerlink" title="控制执行流程"></a>控制执行流程</h3><p>不允许将一个数字作为布尔值使用，应该if(a==0)，for循环语法，for(int i : range(100))</p><p>for 循环的3部分组成 for(int i;i&lt;=10;i++)，在for循环中定义的变量i作用域只在for循环内，要在循环外使用，应该一开始就声名变量</p><p>不允许在嵌套块中对已存在的变量再从声名，c++可以</p><p>while 和 do while 接收一个布尔变量作为循环执行条件</p><p>switch语法，case 和 break case标签类型可以是char，byte，short，int常量，枚举常量，SE7可以使用字符串字面量</p><p>break和continue 控制循环执行，可以加标签跳到指定标签处，在嵌套循环中发挥作用，如果没有嵌套，标签写不写都可以</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>labels<span class="token operator">:</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span><span class="token number">10</span><span class="token punctuation">;</span> j <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a <span class="token operator">+=</span> <span class="token number">1234</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> ii<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> ii<span class="token operator">&lt;=</span><span class="token number">2</span><span class="token punctuation">;</span> ii<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">12345</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span> labels<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h3><p>Java中transient关键字的作用，简单地说，就是让某些被修饰的成员属性变量不被序列化，这一看好像很好理解，就是不被序列化，那么什么情况下，一个对象的某些字段不需要被序列化呢？如果有如下情况，可以考虑使用关键字transient修饰：</p><p>1、类中的字段值可以根据其它字段推导出来，如一个长方形类有三个属性：长度、宽度、面积（示例而已，一般不会这样设计），那么在序列化的时候，面积这个属性就没必要被序列化了；</p><p>2、其它，看具体业务需求吧，哪些字段不想被序列化；</p><h3 id="操作符"><a href="#操作符" class="headerlink" title="++操作符"></a>++操作符</h3><p>分为前缀与后缀</p><p>后缀:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 先将1与变量的值相加，将新值(11)存回变量</span><span class="token comment" spellcheck="true">// 表达式返回旧值(10)</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>前缀:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 先将1与变量的值相加，将新值(11)存回变量</span><span class="token comment" spellcheck="true">// 表达式返回新值(11)</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token operator">++</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这个后缀的形式不太友好，如果选用后缀++, 那么表达式将返回变量的旧值，那么这一瞬间，内存将同时记录（保存）旧值和新值两个变量，其中旧值是返回后就不被使用的临时变量。但这个临时变量是不必要的，亦即“拷贝旧值的动作”以及“占用的内存”都是不必要的。所以我说，在不关心表达式的返回值时，优先用前缀++, 以避免不必要的拷贝和内存浪费。</p><p>Python里面没有++这种做法，最好Java也用 i += 1</p><h3 id="…符号"><a href="#…符号" class="headerlink" title="…符号"></a>…符号</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">MyTest</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> basePackages<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>basePackages<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//    static void MyTest(String[] basePackages) {</span><span class="token comment" spellcheck="true">//        System.out.println(basePackages[2]);</span><span class="token comment" spellcheck="true">//    }</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">MyTest</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">MyTest</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大致上来说 <code>String...</code> 和 <code>String[]</code> 差不多，在上面的例子中，两种传参都可以(但是不推荐这样用)，但是参数类型换成数组的时候，<code>MyTest("1", "2", "3");</code>就不行了。另外此时两种MyTest方法不能同时存在，会被认为是方法重复。</p><h3 id="取余和取模"><a href="#取余和取模" class="headerlink" title="取余和取模"></a>取余和取模</h3><p>Python3中，” / “就一定表示<code>浮点数除法</code>，返回浮点结果，” // “表示<code>整数除法</code></p><p>Java中两个整数类型相除，结果是整数，其中一个是浮点数，结果就是浮点数</p><p>上面回顾了除法的问题，在Java中 %为取余（rem），Math.floorMod()为取模（mod）</p><p>取余运算在计算商值向0方向舍弃小数位<br>取模运算在计算商值向负无穷方向舍弃小数位</p><p>例如： 4 / (-3) 约等于-1.3<br>在取余运算时候商值向0方向舍弃小数位位 -1<br>在取模运算时商值向负无穷方向舍弃小数位为 -2</p><p>这个概念很重要，未完待续</p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>栈内存：是一种连续储存的数据结构，具有先进后出的性质。<br>通常的操作有入栈（压栈），出栈和栈顶元素。想要读取栈中的某个元素，就是将其之间的所有元素出栈才能完成</p><p>堆内存：是一种非连续的树形储存数据结构，每个节点有一个值，整棵树是经过排序的。特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。常用来实现优先队列，存取随意。</p><ol><li>栈：为编译器自动分配和释放，如函数参数、局部变量、临时变量等等</li><li>堆：为成员分配和释放，由程序员自己申请、自己释放。否则发生内存泄露。典型为使用new申请的堆内容。<br>除了这两部分，还有一部分是：</li><li>静态存储区：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。</li></ol><h3 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h3><p><code>本章重点，class后缀文件，和类加载器</code></p><p>RTTI：运行时类型识别</p><p>Class对象，它是一个特殊的对象，每当编译一个新类就会产生其同名的Class对象，后缀名是Class，也就是字节码。为了生成这个类对象，运行这个程序的JVM将使用被称为“类加载器的”子系统。该部分都是运行时涉及到的概念。<br>所以的类对象都是在对其第一次使用的时候，动态的加载到JVM中的。使用new关键字创建类的新对象被当作对类的静态成员的引用。</p><h2 id="javac-和-javap"><a href="#javac-和-javap" class="headerlink" title="javac 和 javap"></a>javac 和 javap</h2><p>编译java文件</p><ol><li><p>程序中编译<br>java提供了JavaCompiler，我们可以通过它来编译java源文件为class文件，这个相关的类，用来在代码中编译，大致流程就是读取一个java后缀文件，把它编译成class后缀文件</p></li><li><p>命令编译<br>classpath是什么？</p></li></ol><p>在dos下编译java程序，就要用到classpath这个概念，尤其是在没有设置环境变量的时候。classpath就是存放.class等编译后文件的路径</p><p>javac：如果当前你要编译的java文件中引用了其它的类(比如说：继承)，但该引用类的.class文件不在当前目录下，这种情况下就需要在javac命令后面加上-classpath参数，通过使用以下三种类型的方法 来指导编译器在编译的时候去指定的路径下查找引用类。</p><p>(1).绝对路径：javac -classpath c:/junit3.8.1/junit.jar Xxx.java</p><p>(2).相对路径：javac -classpath ../junit3.8.1/Junit.javr Xxx.java</p><p>(3).系统变量：javac -classpath %CLASSPATH% Xxx.java (注意：%CLASSPATH%表示使用系统变量CLASSPATH的值进行查找，这里假设Junit.jar的路径就包含在CLASSPATH系统变量中)</p><h2 id="Java中的代码块"><a href="#Java中的代码块" class="headerlink" title="Java中的代码块"></a>Java中的代码块</h2><p>Java中，静态代码块、构造代码块、构造函数、普通代码块，要记住和理解它们的执行顺序</p><ol><li>静态代码块</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"静态代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>特点: 程序启动就执行，所以不能在方法，也不能访问普通变量，只能访问静态变量</p><ol start="2"><li>构造代码块</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"构造代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>执行时机，在对象被创建的时候就会执行一次，所以可以用来统计对象创建的次数，存在多个构造代码块，按顺序执行它们</p><ol start="3"><li>构造函数</li></ol><p>这个就不展开说了</p><ol start="4"><li>普通代码块</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"普通代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>普通代码块和构造代码块的区别是，构造代码块是在类中定义的，而普通代码块是在方法体中定义的。且普通代码块的执行顺序和书写顺序一致</p><ul><li>执行顺序</li></ul><p><code>静态代码块&gt;构造代码块&gt;构造函数&gt;普通代码块</code></p><p>对象的初始化顺序：</p><p>首先执行父类静态的内容，父类静态的内容执行完毕后，接着去执行子类的静态的内容，当子类的静态内容执行完毕之后，再去看父类有没有构造代码块，如果有就执行父类的构造代码块，父类的构造代码块执行完毕，接着执行父类的构造方法；父类的构造方法执行完毕之后，它接着去看子类有没有构造代码块，如果有就执行子类的构造代码块。子类的构造代码块执行完毕再去执行子类的构造方法。</p><p>总之一句话，静态代码块内容先执行，接着执行父类构造代码块和构造方法，然后执行子类构造代码块和构造方法。</p><h2 id="jdk工具"><a href="#jdk工具" class="headerlink" title="jdk工具"></a>jdk工具</h2><table><thead><tr><th>Command</th><th align="center">Description</th></tr></thead><tbody><tr><td>appletviewer.exe</td><td align="center">用于运行并浏览applet小程序。</td></tr><tr><td>apt.exe</td><td align="center">注解处理工具(AnnotationProcessingTool)，主要用于注解处理。</td></tr><tr><td>extcheck.exe</td><td align="center">扩展检测工具，主要用于检测指定jar文件与当前已安装的JavaSDK扩展之间是否存在版本冲突。</td></tr><tr><td>idlj.exe</td><td align="center">IDL转Java编译器(IDL-to-JavaCompiler)，用于为指定的IDL文件生成Java绑定。IDL意即接口定义语言(InterfaceDefinitionLanguage)。</td></tr><tr><td>jabswitch.exe</td><td align="center">Java访问桥开关(JavaAccessBridgeswitch)，用于启用/禁用Java访问桥。Java访问桥内置于Java7Update6及以上版本，主要为Windows系统平台提供一套访问Java应用的API。</td></tr><tr><td>jar.exe</td><td align="center">jar文件管理工具，主要用于打包压缩、解压jar文件。</td></tr><tr><td>jarsigner.exe</td><td align="center">jar密匙签名工具。</td></tr><tr><td>java.exe</td><td align="center">Java运行工具，用于运行.class字节码文件或.jar文件。</td></tr><tr><td>javac.exe</td><td align="center">Java编译工具(JavaCompiler)，用于编译Java源代码文件。</td></tr><tr><td>javadoc.exe</td><td align="center">Java文档工具，主要用于根据Java源代码中的注释信息生成HTML格式的API帮助文档。</td></tr><tr><td>javafxpackager.exe</td><td align="center">JavaFX包装器，用于执行与封装或签名JavaFX应用有关的任务。</td></tr><tr><td>javah.exe</td><td align="center">Java头文件工具，用于根据Java类生成C/C++头文件和源文件(主要用于JNI开发领域)。</td></tr><tr><td>javap.exe</td><td align="center">Java反编译工具，主要用于根据Java字节码文件反汇编为Java源代码文件。</td></tr><tr><td>java-rmi.exe</td><td align="center">Java远程方法调用(JavaRemoteMethodInvocation)工具，主要用于在客户机上调用远程服务器上的对象。</td></tr><tr><td>javaw.exe</td><td align="center">Java运行工具，用于运行.class字节码文件或.jar文件，但不会显示控制台输出信息，适用于运行图形化程序。</td></tr><tr><td>javaws.exe</td><td align="center">JavaWebStart，使您可以从Web下载和运行Java应用程序，下载、安装、运行、更新Java应用程序都非常简单方便。</td></tr><tr><td>jcmd.exe</td><td align="center">Java命令行(JavaCommand)，用于向正在运行的JVM发送诊断命令请求。</td></tr><tr><td>jconsole.exe</td><td align="center">图形化用户界面的监测工具，主要用于监测并显示运行于Java平台上的应用程序的性能和资源占用等信息。</td></tr><tr><td>jdb.exe</td><td align="center">Java调试工具(JavaDebugger)，主要用于对Java应用进行断点调试。</td></tr><tr><td>jhat.exe</td><td align="center">Java堆分析工具(JavaHeapAnalysisTool)，用于分析Java堆内存中的对象信息。</td></tr><tr><td>jinfo.exe</td><td align="center">Java配置信息工具(JavaConfigurationInformation)，用于打印指定Java进程、核心文件或远程调试服务器的配置信息。</td></tr><tr><td>jmap.exe</td><td align="center">Java内存映射工具(JavaMemoryMap)，主要用于打印指定Java进程、核心文件或远程调试服务器的共享对象内存映射或堆内存细节。</td></tr><tr><td>jmc.exe</td><td align="center">Java任务控制工具(JavaMissionControl)，主要用于HotSpotJVM的生产时间监测、分析、诊断。</td></tr><tr><td>jps.exe</td><td align="center">JVM进程状态工具(JVMProcessStatusTool)，用于显示目标系统上的HotSpotJVM的Java进程信息。</td></tr><tr><td>jrunscript.exe</td><td align="center">Java命令行脚本外壳工具(commandlinescriptshell)，主要用于解释执行javascript、groovy、ruby等脚本语言。</td></tr><tr><td>jsadebugd.exe</td><td align="center">Java可用性代理调试守护进程(JavaServiceabilityAgentDebugDaemon)，主要用于附加到指定的Java进程、核心文件，或充当一个调试服务器。</td></tr><tr><td>jstack.exe</td><td align="center">Java堆栈跟踪工具，主要用于打印指定Java进程、核心文件或远程调试服务器的Java线程的堆栈跟踪信息。</td></tr><tr><td>jstat.exe</td><td align="center">JVM统计监测工具(JVMStatisticsMonitoringTool)，主要用于监测并显示JVM的性能统计信息。</td></tr><tr><td>jstatd.exe</td><td align="center">jstatd(VMjstatdDaemon)工具是一个RMI服务器应用，用于监测HotSpotJVM的创建和终止，并提供一个接口，允许远程监测工具附加到运行于本地主机的JVM上。</td></tr><tr><td>jvisualvm.exe</td><td align="center">JVM监测、故障排除、分析工具，主要以图形化界面的方式提供运行于指定虚拟机的Java应用程序的详细信息。</td></tr><tr><td>keytool.exe</td><td align="center">密钥和证书管理工具，主要用于密钥和证书的创建、修改、删除等。</td></tr><tr><td>kinit.exe</td><td align="center">主要用于获取或缓存Kerberos协议的票据授权票据。</td></tr><tr><td>klist.exe</td><td align="center">允许用户查看本地凭据缓存和密钥表中的条目(用于Kerberos协议)。</td></tr><tr><td>ktab.exe</td><td align="center">Kerberos密钥表管理工具，允许用户管理存储于本地密钥表中的主要名称和服务密钥。</td></tr><tr><td>native2ascii.exe</td><td align="center">本地编码到ASCII编码的转换器(Native-to-ASCIIConverter)，用于”任意受支持的字符编码”和与之对应的”ASCII编码和(或)Unicode转义”之间的相互转换。</td></tr><tr><td>orbd.exe</td><td align="center">对象请求代理守护进程(ObjectRequestBrokerDaemon)，它使客户端能够透明地定位和调用位于CORBA环境的服务器上的持久对象。</td></tr><tr><td>pack200.exe</td><td align="center">JAR文件打包压缩工具，它可以利用Java类特有的结构，对普通JAR文件进行高效压缩，以便于能够更快地进行网络传输。</td></tr><tr><td>packager.exe</td><td align="center">这是微软提供的对象包装程序，用于对象安装包。</td></tr><tr><td>policytool.exe</td><td align="center">策略工具，用于管理用户策略文件(.java.policy)。</td></tr><tr><td>rmic.exe</td><td align="center">JavaRMI编译器，为使用JRMP或IIOP协议的远程对象生成stub、skeleton、和tie类，也用于生成OMGIDL。</td></tr><tr><td>rmid.exe</td><td align="center">JavaRMI激活系统守护进程，rmid启动激活系统守护进程，允许在虚拟机中注册或激活对象。</td></tr><tr><td>rmiregistry.exe</td><td align="center">Java远程对象注册表，用于在当前主机的指定端口上创建并启动一个远程对象注册表。</td></tr><tr><td>schemagen.exe</td><td align="center">XMLschema生成器，用于生成XMLschema文件。</td></tr><tr><td>serialver.exe</td><td align="center">序列版本命令，用于生成并返回serialVersionUID。</td></tr><tr><td>servertool.exe</td><td align="center">JavaIDL服务器工具，用于注册、取消注册、启动和终止持久化的服务器。</td></tr><tr><td>tnameserv.exe</td><td align="center">JavaIDL瞬时命名服务。</td></tr><tr><td>unpack200.exe</td><td align="center">JAR文件解压工具，将一个由pack200打包的文件解压提取为JAR文件。</td></tr><tr><td>wsgen.exe</td><td align="center">XMLWebService2.0的JavaAPI，生成用于JAX-WSWebService的JAX-WS便携式产物。</td></tr><tr><td>wsimport.exe</td><td align="center">XMLWebService2.0的JavaAPI，主要用于根据服务端发布的wsdl文件生成客户端存根及框架</td></tr><tr><td>xjc.exe</td><td align="center">主要用于根据XMLschema文件生成对应的Java类。</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
